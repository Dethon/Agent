@using WebChat.Client.State.UserIdentity
@inherits StoreSubscriberComponent

@inject MessagesStore MessagesStore
@inject TopicsStore TopicsStore
@inject StreamingStore StreamingStore
@inject UserIdentityStore UserIdentityStore
@inject IDispatcher Dispatcher
@inject IJSRuntime Js
@inject RenderCoordinator RenderCoordinator

@code {
    private IReadOnlyList<ChatMessageModel> _messages = [];
    private string? _topicId;
    private bool _isStreaming;
    private AgentInfo? _selectedAgent;
    private ElementReference _messagesArea;
    private string? _currentUserId;
    private IDisposable? _streamingContentSubscription;
    private bool _forceScrollToBottom;

    protected override void OnInitialized()
    {
        // Subscribe to selected topic ID
        Subscribe(TopicsStore.StateObservable,
            state => state.SelectedTopicId,
            id =>
            {
                _topicId = id;
                _forceScrollToBottom = true; // Scroll to bottom when switching topics
                UpdateMessages();
                UpdateStreamingStatus();
                UpdateStreamingContentSubscription();
            });

        // Subscribe to selected agent
        Subscribe(TopicsStore.StateObservable,
            state => state.Agents.FirstOrDefault(a => a.Id == state.SelectedAgentId),
            agent => _selectedAgent = agent);

        // Subscribe to messages for current topic
        Subscribe(MessagesStore.StateObservable,
            state => state,
            _ => UpdateMessages());

        // Subscribe to streaming status and content for auto-scroll
        Subscribe(StreamingStore.StateObservable,
            state => state.StreamingTopics,
            _ =>
            {
                UpdateStreamingStatus();
                UpdateStreamingContentSubscription();
            });

        // Subscribe to user identity
        Subscribe(UserIdentityStore.StateObservable,
            state => state.SelectedUserId,
            userId => _currentUserId = userId);
    }

    private void UpdateMessages()
    {
        _messages = _topicId != null
            ? MessagesStore.State.MessagesByTopic.GetValueOrDefault(_topicId, [])
            : [];
    }

    private void UpdateStreamingStatus()
    {
        _isStreaming = _topicId != null && StreamingStore.State.StreamingTopics.Contains(_topicId);
    }

    private void UpdateStreamingContentSubscription()
    {
        // Dispose existing subscription
        _streamingContentSubscription?.Dispose();
        _streamingContentSubscription = null;

        // Subscribe to streaming content if topic is streaming (triggers re-render for auto-scroll)
        if (_isStreaming && !string.IsNullOrEmpty(_topicId))
        {
            _streamingContentSubscription = RenderCoordinator
                .CreateStreamingObservable(_topicId)
                .Subscribe(OnStreamingContentChanged);
        }
    }

    private void OnStreamingContentChanged(StreamingContent? _)
    {
        InvokeAsync(StateHasChanged);
    }

    public override void Dispose()
    {
        _streamingContentSubscription?.Dispose();
        try
        {
            ((IJSInProcessRuntime)Js).InvokeVoid("chatScroll.dispose");
        }
        catch
        {
            // JS runtime may not be available during dispose
        }
        base.Dispose();
    }

    private void HandleSuggestionClicked(string suggestion)
    {
        Dispatcher.Dispatch(new SendMessage(_topicId, suggestion));
    }

    private bool ShouldShowAvatar(int index)
    {
        if (index == 0) return true;

        var current = _messages[index];
        var previous = _messages[index - 1];

        // Show avatar if sender OR role changed
        return current.SenderId != previous.SenderId
            || current.Role != previous.Role;
    }

    private bool IsOwnMessage(ChatMessageModel message)
    {
        return message.Role == "user"
            && !string.IsNullOrEmpty(message.SenderId)
            && message.SenderId == _currentUserId;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Js.InvokeVoidAsync("chatScroll.initStickyScroll", _messagesArea);
            await Js.InvokeVoidAsync("chatScroll.scrollToBottom", _messagesArea, false);
        }
        else if (_forceScrollToBottom)
        {
            _forceScrollToBottom = false;
            await Js.InvokeVoidAsync("chatScroll.scrollToBottom", _messagesArea, false);
        }
        else
        {
            // Sticky scroll: only scroll if user hasn't scrolled away
            await Js.InvokeVoidAsync("chatScroll.scrollToBottomIfSticky", _messagesArea);
        }
    }
}

<div class="messages-area" @ref="_messagesArea">
    @if (_messages.Count == 0 && !_isStreaming)
    {
        <EmptyState SelectedAgent="_selectedAgent" OnSuggestionClicked="HandleSuggestionClicked"/>
    }
    else
    {
        @foreach (var (message, index) in _messages.Select((m, i) => (m, i)))
        {
            <ChatMessage Message="@message"
                         ShowAvatar="@ShouldShowAvatar(index)"
                         IsOwnMessage="@IsOwnMessage(message)" />
        }

        @if (_isStreaming && !string.IsNullOrEmpty(_topicId))
        {
            <StreamingMessageDisplay TopicId="@_topicId"/>
        }
    }
</div>
