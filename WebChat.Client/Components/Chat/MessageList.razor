@using WebChat.Client.Helpers
@using WebChat.Client.State.UserIdentity
@inherits StoreSubscriberComponent

@inject MessagesStore MessagesStore
@inject TopicsStore TopicsStore
@inject StreamingStore StreamingStore
@inject UserIdentityStore UserIdentityStore
@inject IDispatcher Dispatcher
@inject IJSRuntime Js
@inject RenderCoordinator RenderCoordinator

@code {
    private IReadOnlyList<ChatMessageModel> _messages = [];
    private string? _topicId;
    private bool _isStreaming;
    private AgentInfo? _selectedAgent;
    private string? _carriedReasoning;
    private string? _carriedToolCalls;
    private ElementReference _messagesArea;
    private string? _currentUserId;
    private IDisposable? _streamingContentSubscription;
    private bool _forceScrollToBottom;

    protected override void OnInitialized()
    {
        // Subscribe to selected topic ID
        Subscribe(TopicsStore.StateObservable,
            state => state.SelectedTopicId,
            id =>
            {
                _topicId = id;
                _forceScrollToBottom = true; // Scroll to bottom when switching topics
                UpdateMessages();
                UpdateStreamingStatus();
                UpdateStreamingContentSubscription();
            });

        // Subscribe to selected agent
        Subscribe(TopicsStore.StateObservable,
            state => state.Agents.FirstOrDefault(a => a.Id == state.SelectedAgentId),
            agent => _selectedAgent = agent);

        // Subscribe to messages for current topic
        Subscribe(MessagesStore.StateObservable,
            state => state,
            _ => UpdateMessages());

        // Subscribe to streaming status and content for auto-scroll
        Subscribe(StreamingStore.StateObservable,
            state => state.StreamingTopics,
            _ =>
            {
                UpdateStreamingStatus();
                UpdateStreamingContentSubscription();
            });

        // Subscribe to user identity
        Subscribe(UserIdentityStore.StateObservable,
            state => state.SelectedUserId,
            userId => _currentUserId = userId);
    }

    private void UpdateMessages()
    {
        var raw = _topicId != null
            ? MessagesStore.State.MessagesByTopic.GetValueOrDefault(_topicId, [])
            : [];
        var merged = MergeConsecutiveAssistantMessages(raw);

        if (_isStreaming && merged.Count > 0
            && merged[^1] is { Role: "assistant", Content: "" or null } last
            && (last.Reasoning is not null || last.ToolCalls is not null))
        {
            _carriedReasoning = last.Reasoning;
            _carriedToolCalls = last.ToolCalls;
            _messages = merged.Take(merged.Count - 1).ToList();
        }
        else
        {
            _carriedReasoning = null;
            _carriedToolCalls = null;
            _messages = merged;
        }
    }

    // Merges consecutive assistant messages into a single bubble.
    // Reasoning concatenated with "\n-----\n", tool calls with "\n".
    // Content taken from whichever message has it. Empty trailing bubble kept (expecting more data).
    internal static IReadOnlyList<ChatMessageModel> MergeConsecutiveAssistantMessages(
        IReadOnlyList<ChatMessageModel> messages)
    {
        if (messages.Count <= 1)
        {
            return messages;
        }

        var result = new List<ChatMessageModel>(messages.Count);
        string? accReasoning = null;
        string? accToolCalls = null;
        string? accContent = null;
        ChatMessageModel? anchor = null;

        for (var i = 0; i < messages.Count; i++)
        {
            var message = messages[i];

            if (message.Role != "assistant")
            {
                Flush(result, ref anchor, ref accContent, ref accReasoning, ref accToolCalls);
                result.Add(message);
                continue;
            }

            if (!string.IsNullOrEmpty(message.Content))
            {
                if (accContent is not null)
                {
                    // Previous message(s) already had content â€” flush them as a separate bubble
                    Flush(result, ref anchor, ref accContent, ref accReasoning, ref accToolCalls);
                }

                accContent = message.Content;
            }

            accReasoning = MessageFieldMerger.Merge(
                accReasoning, message.Reasoning, MessageFieldMerger.ReasoningSeparator);
            accToolCalls = MessageFieldMerger.Merge(
                accToolCalls, message.ToolCalls, MessageFieldMerger.ToolCallsSeparator);

            // Prefer the message that carries content as anchor for MessageId/Timestamp
            anchor = anchor is null || !string.IsNullOrEmpty(message.Content) ? message : anchor;

            var nextIsAssistant = i < messages.Count - 1 && messages[i + 1].Role == "assistant";
            if (!nextIsAssistant)
            {
                Flush(result, ref anchor, ref accContent, ref accReasoning, ref accToolCalls);
            }
        }

        Flush(result, ref anchor, ref accContent, ref accReasoning, ref accToolCalls);
        return result;

        static void Flush(
            List<ChatMessageModel> result,
            ref ChatMessageModel? anchor,
            ref string? content,
            ref string? reasoning,
            ref string? toolCalls)
        {
            if (anchor is null)
            {
                return;
            }

            result.Add(anchor with
            {
                Content = content ?? "",
                Reasoning = reasoning,
                ToolCalls = toolCalls
            });

            anchor = null;
            content = null;
            reasoning = null;
            toolCalls = null;
        }
    }

    private void UpdateStreamingStatus()
    {
        var wasStreaming = _isStreaming;
        _isStreaming = _topicId != null && StreamingStore.State.StreamingTopics.Contains(_topicId);

        if (wasStreaming && !_isStreaming)
        {
            UpdateMessages();
        }
    }

    private void UpdateStreamingContentSubscription()
    {
        // Dispose existing subscription
        _streamingContentSubscription?.Dispose();
        _streamingContentSubscription = null;

        // Subscribe to streaming content if topic is streaming (triggers re-render for auto-scroll)
        if (_isStreaming && !string.IsNullOrEmpty(_topicId))
        {
            _streamingContentSubscription = RenderCoordinator
                .CreateStreamingObservable(_topicId)
                .Subscribe(OnStreamingContentChanged);
        }
    }

    private void OnStreamingContentChanged(StreamingContent? _)
    {
        InvokeAsync(StateHasChanged);
    }

    public override void Dispose()
    {
        _streamingContentSubscription?.Dispose();
        try
        {
            ((IJSInProcessRuntime)Js).InvokeVoid("chatScroll.dispose");
        }
        catch
        {
            // JS runtime may not be available during dispose
        }
        base.Dispose();
    }

    private void HandleSuggestionClicked(string suggestion)
    {
        Dispatcher.Dispatch(new SendMessage(_topicId, suggestion));
    }

    private bool ShouldShowAvatar(int index)
    {
        if (index == 0)
        {
            return true;
        }

        var current = _messages[index];
        var previous = _messages[index - 1];

        // Show avatar if sender OR role changed
        return current.SenderId != previous.SenderId
            || current.Role != previous.Role;
    }

    private bool IsOwnMessage(ChatMessageModel message)
    {
        return message.Role == "user"
            && !string.IsNullOrEmpty(message.SenderId)
            && message.SenderId == _currentUserId;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Js.InvokeVoidAsync("chatScroll.initStickyScroll", _messagesArea);
            await Js.InvokeVoidAsync("chatScroll.scrollToBottom", _messagesArea, false);
        }
        else if (_forceScrollToBottom)
        {
            _forceScrollToBottom = false;
            await Js.InvokeVoidAsync("chatScroll.scrollToBottom", _messagesArea, false);
        }
        else
        {
            // Sticky scroll: only scroll if user hasn't scrolled away
            await Js.InvokeVoidAsync("chatScroll.scrollToBottomIfSticky", _messagesArea);
        }
    }
}

<div class="messages-area" @ref="_messagesArea">
    @if (_messages.Count == 0 && !_isStreaming)
    {
        <EmptyState SelectedAgent="_selectedAgent" OnSuggestionClicked="HandleSuggestionClicked"/>
    }
    else
    {
        @foreach (var (message, index) in _messages.Select((m, i) => (m, i)))
        {
            <ChatMessage Message="@message"
                         ShowAvatar="@ShouldShowAvatar(index)"
                         IsOwnMessage="@IsOwnMessage(message)" />
        }

        @if (_isStreaming && !string.IsNullOrEmpty(_topicId))
        {
            <StreamingMessageDisplay TopicId="@_topicId"
                                     CarriedReasoning="@_carriedReasoning"
                                     CarriedToolCalls="@_carriedToolCalls"/>
        }
    }
</div>
