@page "/"
@inject ChatHubService HubService
@inject IJSRuntime Js
@implements IDisposable

<div class="chat-layout">
    <TopicList Topics="@_topics"
               SelectedTopic="@_selectedTopic"
               Agents="@_agents"
               SelectedAgentId="@_selectedAgentId"
               OnTopicSelected="HandleTopicSelected"
               OnTopicDeleted="HandleTopicDeleted"
               OnNewTopic="HandleNewTopic"
               OnAgentChanged="HandleAgentChanged"
               IsStreaming="@IsStreaming"/>

    <div class="chat-container">
        <div class="messages-area" @ref="_messagesArea">
            @if (CurrentMessages.Count == 0 && !IsStreaming)
            {
                <div class="empty-state">
                    <h2>Start a conversation</h2>
                    <p>Select an agent and type a message to begin.</p>
                </div>
            }
            else
            {
                @foreach (var message in CurrentMessages)
                {
                    <ChatMessage Message="@message"/>
                }

                @if (IsStreaming && CurrentStreamingMessage is not null)
                {
                    <ChatMessage Message="@CurrentStreamingMessage" IsStreaming="true"/>
                }
            }
        </div>

        <div class="input-area">
            <ChatInput OnSend="HandleSend"
                       OnCancel="HandleCancel"
                       IsStreaming="IsStreaming"
                       Disabled="string.IsNullOrEmpty(_selectedAgentId) || !HubService.IsConnected"/>
        </div>
    </div>
</div>

@code {
    private List<AgentInfo> _agents = [];
    private List<StoredTopic> _topics = [];
    private StoredTopic? _selectedTopic;
    private string? _selectedAgentId;

    // Per-topic message storage for background streaming
    private readonly Dictionary<string, List<ChatMessageModel>> _messagesByTopic = new();
    private readonly Dictionary<string, ChatMessageModel?> _streamingMessageByTopic = new();
    private readonly HashSet<string> _streamingTopics = new();
    private readonly HashSet<string> _resumingTopics = new();

    // Auto-scroll tracking
    private ElementReference _messagesArea;
    private bool _shouldAutoScroll = true;

    private List<ChatMessageModel> CurrentMessages =>
        _selectedTopic is not null && _messagesByTopic.TryGetValue(_selectedTopic.TopicId, out var msgs) ? msgs : [];

    private ChatMessageModel? CurrentStreamingMessage =>
        _selectedTopic is not null && _streamingMessageByTopic.TryGetValue(_selectedTopic.TopicId, out var msg) ? msg : null;

    private bool IsStreaming => _selectedTopic is not null && _streamingTopics.Contains(_selectedTopic.TopicId);

    protected override async Task OnInitializedAsync()
    {
        HubService.OnStateChanged += StateHasChanged;
        HubService.OnReconnected += HandleReconnected;

        await HubService.ConnectAsync();
        _agents = (await HubService.GetAgentsAsync()).ToList();

        var serverTopics = await HubService.GetAllTopicsAsync();
        _topics = serverTopics.Select(StoredTopic.FromMetadata).ToList();

        if (_agents.Count > 0)
        {
            _selectedAgentId = _agents[0].Id;
        }

        // Check for any active streams after page refresh
        foreach (var topic in _topics)
        {
            _ = TryResumeStreamAsync(topic);
        }

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldAutoScroll)
        {
            await Js.InvokeVoidAsync("chatScroll.scrollToBottom", _messagesArea);
        }
    }

    private async Task CheckAndUpdateAutoScroll()
    {
        try
        {
            _shouldAutoScroll = await Js.InvokeAsync<bool>("chatScroll.isAtBottom", _messagesArea);
        }
        catch
        {
            // JS interop might fail during initialization
            _shouldAutoScroll = true;
        }
    }

    private async Task HandleReconnected()
    {
        if (_selectedTopic is not null)
        {
            await HubService.StartSessionAsync(_selectedTopic);
        }

        // Check for any active streams after reconnection
        foreach (var topic in _topics)
        {
            _ = TryResumeStreamAsync(topic);
        }
    }

    private Task HandleAgentChanged(string agentId)
    {
        if (_selectedAgentId == agentId)
        {
            return Task.CompletedTask;
        }

        _selectedAgentId = agentId;
        _selectedTopic = null;
        HubService.ClearCurrentTopic();
        StateHasChanged();

        return Task.CompletedTask;
    }

    private async Task HandleTopicSelected(StoredTopic topic)
    {
        if (_selectedTopic?.TopicId == topic.TopicId)
        {
            return;
        }

        _selectedTopic = topic;
        _selectedAgentId = topic.AgentId;

        // Load messages if not already cached
        if (!_messagesByTopic.ContainsKey(topic.TopicId))
        {
            await HubService.StartSessionAsync(topic);
            var history = await HubService.GetHistoryAsync(topic.ChatId, topic.ThreadId);
            _messagesByTopic[topic.TopicId] = history.Select(h => new ChatMessageModel
            {
                Role = h.Role,
                Content = h.Content
            }).ToList();
        }

        _shouldAutoScroll = true; // Scroll to bottom when switching topics
        StateHasChanged();
    }

    private async Task HandleTopicDeleted(StoredTopic topic)
    {
        await HubService.DeleteTopicAsync(topic);
        _topics.RemoveAll(t => t.TopicId == topic.TopicId);
        _messagesByTopic.Remove(topic.TopicId);
        _streamingMessageByTopic.Remove(topic.TopicId);
        _streamingTopics.Remove(topic.TopicId);

        if (_selectedTopic?.TopicId == topic.TopicId)
        {
            _selectedTopic = null;
        }

        StateHasChanged();
    }

    private Task HandleNewTopic()
    {
        _selectedTopic = null;
        HubService.ClearCurrentTopic();
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task HandleSend(string message)
    {
        if (string.IsNullOrWhiteSpace(message) || _selectedAgentId is null)
        {
            return;
        }

        StoredTopic topic;
        if (_selectedTopic is null)
        {
            var topicName = message.Length > 50 ? message[..50] + "..." : message;
            var topicId = ChatHubService.GenerateTopicId();
            topic = new StoredTopic
            {
                TopicId = topicId,
                ChatId = ChatHubService.GetChatIdForTopic(topicId),
                ThreadId = ChatHubService.GetThreadIdForTopic(topicId),
                AgentId = _selectedAgentId,
                Name = topicName,
                CreatedAt = DateTime.UtcNow
            };

            var success = await HubService.StartSessionAsync(topic);
            if (!success)
            {
                return;
            }

            _selectedTopic = topic;
            _topics.Add(topic);
            _messagesByTopic[topic.TopicId] = [];
            await HubService.SaveTopicAsync(topic.ToMetadata());
            StateHasChanged();
        }
        else
        {
            topic = _selectedTopic;
            if (HubService.CurrentTopic?.TopicId != topic.TopicId)
            {
                await HubService.StartSessionAsync(topic);
            }
        }

        // Get or create message list for this topic
        if (!_messagesByTopic.TryGetValue(topic.TopicId, out var messages))
        {
            messages = [];
            _messagesByTopic[topic.TopicId] = messages;
        }

        messages.Add(new ChatMessageModel
        {
            Role = "user",
            Content = message
        });

        _streamingTopics.Add(topic.TopicId);
        _streamingMessageByTopic[topic.TopicId] = new ChatMessageModel { Role = "assistant" };
        _shouldAutoScroll = true; // Always scroll when user sends a message
        StateHasChanged();

        // Run streaming in background
        _ = StreamResponseAsync(topic, message);
    }

    private async Task StreamResponseAsync(StoredTopic topic, string message)
    {
        var streamingMessage = _streamingMessageByTopic[topic.TopicId]!;
        var messages = _messagesByTopic[topic.TopicId];
        var currentMessageIndex = 0;

        try
        {
            await foreach (var chunk in HubService.SendMessageAsync(message))
            {
                if (chunk.Error is not null)
                {
                    streamingMessage.Content = chunk.Error;
                    streamingMessage.IsError = true;
                    break;
                }

                if (chunk.IsComplete)
                {
                    break;
                }

                // New message turn - save current and start fresh
                if (chunk.MessageIndex > currentMessageIndex && currentMessageIndex > 0)
                {
                    if (!string.IsNullOrEmpty(streamingMessage.Content)
                        || !string.IsNullOrEmpty(streamingMessage.ToolCalls)
                        || !string.IsNullOrEmpty(streamingMessage.Reasoning))
                    {
                        messages.Add(streamingMessage);
                    }

                    streamingMessage = new ChatMessageModel { Role = "assistant" };
                    _streamingMessageByTopic[topic.TopicId] = streamingMessage;
                }

                currentMessageIndex = chunk.MessageIndex;

                if (!string.IsNullOrEmpty(chunk.Content))
                {
                    streamingMessage.Content = string.IsNullOrEmpty(streamingMessage.Content)
                        ? chunk.Content
                        : streamingMessage.Content + "\n\n" + chunk.Content;
                }

                if (!string.IsNullOrEmpty(chunk.Reasoning))
                {
                    streamingMessage.Reasoning = string.IsNullOrEmpty(streamingMessage.Reasoning)
                        ? chunk.Reasoning
                        : streamingMessage.Reasoning + "\n-----\n" + chunk.Reasoning;
                }

                if (!string.IsNullOrEmpty(chunk.ToolCalls))
                {
                    streamingMessage.ToolCalls = string.IsNullOrEmpty(streamingMessage.ToolCalls)
                        ? chunk.ToolCalls
                        : streamingMessage.ToolCalls + "\n-----\n" + chunk.ToolCalls;
                }

                await InvokeAsync(async () =>
                {
                    await CheckAndUpdateAutoScroll();
                    StateHasChanged();
                });
            }

            if (!string.IsNullOrEmpty(streamingMessage.Content)
                || !string.IsNullOrEmpty(streamingMessage.ToolCalls)
                || !string.IsNullOrEmpty(streamingMessage.Reasoning))
            {
                messages.Add(streamingMessage);
            }

            topic.LastMessageAt = DateTime.UtcNow;
            await HubService.SaveTopicAsync(topic.ToMetadata());
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessageModel
            {
                Role = "assistant",
                Content = $"Error: {ex.Message}",
                IsError = true
            });
        }
        finally
        {
            _streamingTopics.Remove(topic.TopicId);
            _streamingMessageByTopic.Remove(topic.TopicId);
            await InvokeAsync(async () =>
            {
                await CheckAndUpdateAutoScroll();
                StateHasChanged();
            });
        }
    }

    private async Task TryResumeStreamAsync(StoredTopic topic)
    {
        // Prevent concurrent resume attempts for the same topic
        if (!_resumingTopics.Add(topic.TopicId))
        {
            return;
        }

        try
        {
            // Skip if already streaming this topic
            if (_streamingTopics.Contains(topic.TopicId))
            {
                return;
            }

            var state = await HubService.GetStreamStateAsync(topic.TopicId);
            if (state is null || (!state.IsProcessing && state.BufferedMessages.Count == 0))
            {
                return;
            }

            // Ensure we have a session
            await HubService.StartSessionAsync(topic);

            // Ensure we have a message list for this topic
            if (!_messagesByTopic.ContainsKey(topic.TopicId))
            {
                var history = await HubService.GetHistoryAsync(topic.ChatId, topic.ThreadId);
                _messagesByTopic[topic.TopicId] = history.Select(h => new ChatMessageModel
                {
                    Role = h.Role,
                    Content = h.Content
                }).ToList();
            }

            // Restore streaming state from buffer
            _streamingTopics.Add(topic.TopicId);
            var messages = _messagesByTopic.GetValueOrDefault(topic.TopicId) ?? [];

            // Restore user prompt if not already in messages
            if (!string.IsNullOrEmpty(state.CurrentPrompt))
            {
                var promptExists = messages.Any(m =>
                    m.Role == "user" && m.Content == state.CurrentPrompt);

                if (!promptExists)
                {
                    messages.Add(new ChatMessageModel
                    {
                        Role = "user",
                        Content = state.CurrentPrompt
                    });
                }
            }

            // Get all known content from history for deduplication
            var historyContent = messages
                .Where(m => m.Role == "assistant" && !string.IsNullOrEmpty(m.Content))
                .Select(m => m.Content)
                .ToHashSet();

            var (completedTurns, streamingMessage) = RebuildFromBuffer(state.BufferedMessages, historyContent);

            // Add completed turns (already deduplicated by RebuildFromBuffer)
            foreach (var turn in completedTurns.Where(HasContent))
            {
                messages.Add(turn);
            }

            // Strip known content from streaming message
            StripKnownContent(streamingMessage, historyContent);

            _streamingMessageByTopic[topic.TopicId] = streamingMessage;

            await InvokeAsync(StateHasChanged);

            // Continue streaming
            await ResumeStreamResponseAsync(topic, streamingMessage, state.CurrentMessageIndex);
        }
        finally
        {
            _resumingTopics.Remove(topic.TopicId);
        }
    }

    private static (List<ChatMessageModel> CompletedTurns, ChatMessageModel StreamingMessage) RebuildFromBuffer(
        IReadOnlyList<ChatStreamMessage> bufferedMessages,
        HashSet<string> historyContent)
    {
        var streamingMessage = new ChatMessageModel { Role = "assistant" };
        var completedTurns = new List<ChatMessageModel>();

        if (bufferedMessages.Count == 0)
        {
            return (completedTurns, streamingMessage);
        }

        // Group messages by MessageIndex and process each turn
        var turnGroups = bufferedMessages
            .GroupBy(m => m.MessageIndex)
            .OrderBy(g => g.Key)
            .ToList();

        foreach (var turnGroup in turnGroups)
        {
            var chunks = turnGroup.ToList();
            var isComplete = chunks.Any(m => m.IsComplete);

            if (isComplete)
            {
                // This turn is complete - add to completed turns
                var completedMessage = new ChatMessageModel { Role = "assistant" };
                foreach (var chunk in chunks.Where(m => !m.IsComplete && m.Error is null))
                {
                    AccumulateChunk(completedMessage, chunk);
                }

                // Strip any content already in history
                StripKnownContent(completedMessage, historyContent);

                if (HasContent(completedMessage))
                {
                    completedTurns.Add(completedMessage);
                }
            }
            else
            {
                // This turn is incomplete - it's the streaming message
                foreach (var chunk in chunks.Where(m => m.Error is null))
                {
                    AccumulateChunk(streamingMessage, chunk);
                }
            }
        }

        return (completedTurns, streamingMessage);
    }

    private static void StripKnownContent(ChatMessageModel message, HashSet<string> historyContent)
    {
        if (string.IsNullOrEmpty(message.Content))
        {
            return;
        }

        // Remove any history content that appears in this message
        foreach (var known in historyContent)
        {
            if (message.Content.Contains(known))
            {
                message.Content = message.Content.Replace(known, "").Trim();
            }
        }

        // Clean up any leftover separators
        while (message.Content.StartsWith("\n\n"))
        {
            message.Content = message.Content[2..];
        }

        while (message.Content.EndsWith("\n\n"))
        {
            message.Content = message.Content[..^2];
        }
    }

    private static void AccumulateChunk(ChatMessageModel streamingMessage, ChatStreamMessage chunk)
    {
        if (!string.IsNullOrEmpty(chunk.Content))
        {
            streamingMessage.Content = string.IsNullOrEmpty(streamingMessage.Content)
                ? chunk.Content
                : streamingMessage.Content + "\n\n" + chunk.Content;
        }

        if (!string.IsNullOrEmpty(chunk.Reasoning))
        {
            streamingMessage.Reasoning = string.IsNullOrEmpty(streamingMessage.Reasoning)
                ? chunk.Reasoning
                : streamingMessage.Reasoning + "\n-----\n" + chunk.Reasoning;
        }

        if (!string.IsNullOrEmpty(chunk.ToolCalls))
        {
            streamingMessage.ToolCalls = string.IsNullOrEmpty(streamingMessage.ToolCalls)
                ? chunk.ToolCalls
                : streamingMessage.ToolCalls + "\n-----\n" + chunk.ToolCalls;
        }
    }

    private static bool HasContent(ChatMessageModel msg)
    {
        return !string.IsNullOrEmpty(msg.Content) ||
               !string.IsNullOrEmpty(msg.ToolCalls) ||
               !string.IsNullOrEmpty(msg.Reasoning);
    }

    private async Task ResumeStreamResponseAsync(
        StoredTopic topic,
        ChatMessageModel streamingMessage,
        int startMessageIndex)
    {
        var messages = _messagesByTopic.GetValueOrDefault(topic.TopicId) ?? [];
        var currentMessageIndex = startMessageIndex;

        // Track content for deduplication - skip chunks already in streaming message
        var knownContent = streamingMessage.Content;
        var knownReasoning = streamingMessage.Reasoning ?? "";
        var knownToolCalls = streamingMessage.ToolCalls ?? "";

        try
        {
            await foreach (var chunk in HubService.ResumeStreamAsync(topic.TopicId))
            {
                if (chunk.Error is not null)
                {
                    streamingMessage.Content = chunk.Error;
                    streamingMessage.IsError = true;
                    break;
                }

                if (chunk.IsComplete)
                {
                    break;
                }

                // Handle message turn changes
                if (chunk.MessageIndex > currentMessageIndex && currentMessageIndex > 0)
                {
                    if (HasContent(streamingMessage))
                    {
                        messages.Add(streamingMessage);
                    }

                    streamingMessage = new ChatMessageModel { Role = "assistant" };
                    _streamingMessageByTopic[topic.TopicId] = streamingMessage;

                    // Reset tracking for new message
                    knownContent = "";
                    knownReasoning = "";
                    knownToolCalls = "";
                }

                currentMessageIndex = chunk.MessageIndex;

                // Skip chunks whose content is already known
                var isNew = false;

                if (!string.IsNullOrEmpty(chunk.Content) && !knownContent.Contains(chunk.Content))
                {
                    AccumulateChunk(streamingMessage, new ChatStreamMessage { Content = chunk.Content });
                    knownContent = streamingMessage.Content ?? "";
                    isNew = true;
                }

                if (!string.IsNullOrEmpty(chunk.Reasoning) && !knownReasoning.Contains(chunk.Reasoning))
                {
                    AccumulateChunk(streamingMessage, new ChatStreamMessage { Reasoning = chunk.Reasoning });
                    knownReasoning = streamingMessage.Reasoning ?? "";
                    isNew = true;
                }

                if (!string.IsNullOrEmpty(chunk.ToolCalls) && !knownToolCalls.Contains(chunk.ToolCalls))
                {
                    AccumulateChunk(streamingMessage, new ChatStreamMessage { ToolCalls = chunk.ToolCalls });
                    knownToolCalls = streamingMessage.ToolCalls ?? "";
                    isNew = true;
                }

                if (isNew)
                {
                    await InvokeAsync(async () =>
                    {
                        await CheckAndUpdateAutoScroll();
                        StateHasChanged();
                    });
                }
            }

            // Finalize message
            if (HasContent(streamingMessage))
            {
                messages.Add(streamingMessage);
            }

            topic.LastMessageAt = DateTime.UtcNow;
            await HubService.SaveTopicAsync(topic.ToMetadata());
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessageModel
            {
                Role = "assistant",
                Content = $"Error resuming stream: {ex.Message}",
                IsError = true
            });
        }
        finally
        {
            _streamingTopics.Remove(topic.TopicId);
            _streamingMessageByTopic.Remove(topic.TopicId);
            await InvokeAsync(async () =>
            {
                await CheckAndUpdateAutoScroll();
                StateHasChanged();
            });
        }
    }

    private async Task HandleCancel()
    {
        if (_selectedTopic is not null)
        {
            await HubService.CancelAsync();
            _streamingTopics.Remove(_selectedTopic.TopicId);
            _streamingMessageByTopic.Remove(_selectedTopic.TopicId);
            StateHasChanged();
        }
    }

    public void Dispose()
    {
        HubService.OnStateChanged -= StateHasChanged;
        HubService.OnReconnected -= HandleReconnected;
    }

}
