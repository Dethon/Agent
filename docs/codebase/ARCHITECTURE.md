# Architecture

> Auto-generated by /codemap-creator. Prescriptive guide for system architecture.

## Architecture Pattern

**Pattern**: Layered Architecture with MCP Microservices

The system follows a classic three-layer architecture (Agent -> Infrastructure -> Domain) for the core application, combined with independently deployable MCP (Model Context Protocol) servers that expose tool capabilities over HTTP. The main Agent process connects to MCP servers as a client at runtime, loading tools, prompts, and resources dynamically. A Blazor WebAssembly frontend (WebChat) communicates with the Agent backend via SignalR.

## Layers

### Domain Layer (Innermost)

- **Location**: `Domain/`
- **Responsibility**: Pure business logic, contracts, DTOs, domain tools, prompts, and agent abstractions. Contains zero external dependencies.
- **Can import from**: Only .NET BCL, `Microsoft.Extensions.AI.Abstractions`, `Microsoft.Agents.AI.Abstractions`, `FluentResults`, `NCrontab`, `Microsoft.Extensions.Logging.Abstractions`, `Microsoft.Extensions.Caching.Abstractions`
- **Cannot import from**: `Infrastructure`, `Agent`, any MCP server project, any concrete external client library (HttpClient, Redis, Telegram, etc.)
- **Enforcement**: See `Domain/Domain.csproj` -- no `ProjectReference` to Infrastructure or Agent. Violations will break compilation.

### Infrastructure Layer (Middle)

- **Location**: `Infrastructure/`
- **Responsibility**: Implements Domain interfaces. Handles external service clients (OpenRouter, Telegram, Redis, Playwright, Azure Service Bus), MCP client management, agent implementations, state persistence, CLI GUI, and HTML processing.
- **Can import from**: `Domain`, external NuGet packages (Redis, Telegram.Bot, Playwright, MCP SDK, Polly, etc.)
- **Cannot import from**: `Agent`, any `McpServer*` project. Infrastructure must never reference the composition root.
- **Enforcement**: See `Infrastructure/Infrastructure.csproj` -- only `ProjectReference` is to `Domain`.

### Agent Layer (Composition Root)

- **Location**: `Agent/`
- **Responsibility**: Application entry point, dependency injection wiring, hosted services (ChatMonitoring, ScheduleMonitoring), SignalR hub, configuration binding, and command-line parsing.
- **Can import from**: `Infrastructure`, `Domain`
- **Cannot import from**: Any `McpServer*` project, `WebChat`, `WebChat.Client`
- **Enforcement**: See `Agent/Agent.csproj` -- only `ProjectReference` is to `Infrastructure`.

### MCP Server Layer (Sidecar Microservices)

- **Location**: `McpServerLibrary/`, `McpServerText/`, `McpServerWebSearch/`, `McpServerMemory/`, `McpServerIdealista/`, `McpServerCommandRunner/`
- **Responsibility**: Each MCP server is an independent executable that exposes domain tools over the Model Context Protocol via HTTP. They wrap Domain tool classes with MCP attributes and run as standalone ASP.NET processes.
- **Can import from**: `Infrastructure`, `Domain`
- **Cannot import from**: `Agent`, other `McpServer*` projects, `WebChat`
- **Enforcement**: Each `McpServer*.csproj` has a single `ProjectReference` to `Infrastructure`.

### WebChat Layer (Frontend)

- **Location**: `WebChat/` (server host), `WebChat.Client/` (Blazor WASM client)
- **Responsibility**: Blazor WebAssembly chat UI. The server (`WebChat/`) serves static files and a config endpoint. The client (`WebChat.Client/`) contains components, state management (Redux-like), and SignalR connection logic.
- **Can import from**: `WebChat.Client` imports `Domain` (for shared DTOs). `WebChat` imports `Domain`, `Infrastructure` (for middleware), and `WebChat.Client`.
- **Cannot import from**: `Agent`, any `McpServer*` project

## Key Abstractions

### IChatMessengerClient

- **Interface**: `Domain/Contracts/IChatMessengerClient.cs`
- **Implementations**: `Infrastructure/Clients/Messaging/Cli/CliChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/Telegram/TelegramChatClient.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/Cli/OneShotChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/ServiceBus/ServiceBusChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/CompositeChatMessengerClient.cs`
- **Purpose**: Abstracts message input/output across chat interfaces (CLI, Telegram, WebChat, ServiceBus). The `ChatMonitor` consumes this to read user prompts and send AI responses regardless of the transport.
- **Selection**: Configured at startup via `--chat` CLI flag in `Agent/Modules/InjectorModule.cs`.

### IAgentFactory / IScheduleAgentFactory

- **Interface**: `Domain/Contracts/IAgentFactory.cs`, `Domain/Contracts/IScheduleAgentFactory.cs`
- **Implementation**: `Infrastructure/Agents/MultiAgentFactory.cs`
- **Purpose**: Creates `DisposableAgent` instances (specifically `McpAgent`) based on configuration. Each agent definition specifies its LLM model, MCP server endpoints, custom instructions, and whitelisted tool patterns.

### DisposableAgent / McpAgent

- **Base class**: `Domain/Agents/DisposableAgent.cs` (extends `Microsoft.Agents.AI.AIAgent`)
- **Implementation**: `Infrastructure/Agents/McpAgent.cs`
- **Purpose**: Wraps an LLM chat client with MCP tool integration, resource management, and session lifecycle. Each `McpAgent` instance manages its own `ThreadSession` which holds MCP client connections, loaded tools, and resource subscriptions.

### IToolApprovalHandler / IToolApprovalHandlerFactory

- **Interface**: `Domain/Contracts/IToolApprovalHandler.cs`, `Domain/Contracts/IToolApprovalHandlerFactory.cs`
- **Implementations**: `Infrastructure/Clients/ToolApproval/AutoToolApprovalHandler.cs`, `Infrastructure/Clients/ToolApproval/CliToolApprovalHandler.cs`, `Infrastructure/Clients/ToolApproval/TelegramToolApprovalHandler.cs`, `Infrastructure/Clients/ToolApproval/WebToolApprovalHandler.cs`
- **Purpose**: Intercepts tool calls before execution. Tools matching whitelist patterns are auto-approved; others require user confirmation. The `ToolApprovalChatClient` (`Infrastructure/Agents/ChatClients/ToolApprovalChatClient.cs`) wraps the LLM chat client and invokes the approval handler before each function call.

### IDomainToolFeature / IDomainToolRegistry

- **Interface**: `Domain/Contracts/IDomainToolFeature.cs`, `Domain/Contracts/IDomainToolRegistry.cs`
- **Implementation**: `Infrastructure/Agents/DomainToolRegistry.cs`
- **Purpose**: Registers domain-level tools (e.g., scheduling) that are injected directly into the agent rather than exposed via MCP servers. Each `IDomainToolFeature` provides a named feature with associated `AIFunction` tools. Agent definitions specify which features to enable via `EnabledFeatures`.

### IThreadStateStore

- **Interface**: `Domain/Contracts/IThreadStateStore.cs`
- **Implementation**: `Infrastructure/StateManagers/RedisThreadStateStore.cs`
- **Purpose**: Persists chat history and topic metadata in Redis. Keyed by `AgentKey` (chatId + threadId + agentId).

### Store<TState> (WebChat.Client Redux pattern)

- **Base class**: `WebChat.Client/State/Store.cs`
- **Purpose**: Generic reactive store using `System.Reactive` `BehaviorSubject`. State updates happen through `Dispatch(action, reducer)`. Components subscribe via `StateObservable`. Place new stores in `WebChat.Client/State/{Feature}/`.
- **Pattern**: Actions (`{Feature}Actions.cs`) -> Reducers (`{Feature}Reducers.cs`) -> Store (`{Feature}Store.cs`). Side effects go in `WebChat.Client/State/Effects/`.

## Data Flow

### Chat Message Pipeline

```
User Input
    |
    v
IChatMessengerClient.ReadPrompts()     <-- Telegram / CLI / WebChat / ServiceBus
    |
    v
ChatMonitor.Monitor()                  <-- Domain/Monitor/ChatMonitor.cs
    |
    v
ChatThreadResolver.Resolve(agentKey)   <-- Domain/Agents/ChatThreadResolver.cs
    |
    v
IAgentFactory.Create(agentKey)         <-- Infrastructure/Agents/MultiAgentFactory.cs
    |
    v
McpAgent.RunStreamingAsync()           <-- Infrastructure/Agents/McpAgent.cs
    |
    v
ToolApprovalChatClient                 <-- Infrastructure/Agents/ChatClients/ToolApprovalChatClient.cs
    |                                       (intercepts tool calls for approval)
    v
OpenRouterChatClient                   <-- Infrastructure/Agents/ChatClients/OpenRouterChatClient.cs
    |                                       (calls OpenRouter LLM API)
    v
MCP Tool Execution                     <-- via McpClientManager -> MCP Servers (HTTP)
    |
    v
IChatMessengerClient.ProcessResponseStreamAsync()
    |
    v
User Output (streamed)
```

### Typical Request Flow (WebChat)

1. User types message in Blazor WebAssembly UI (`WebChat.Client/Components/ChatInput.razor`)
2. `SendMessageEffect` dispatches the action, which calls `ChatHub.SendMessage()` via SignalR
3. `WebChatMessengerClient` enqueues the prompt and creates a response stream
4. `ChatMonitoring` background service continuously calls `ChatMonitor.Monitor()`
5. `ChatMonitor` reads prompts from `IChatMessengerClient.ReadPrompts()`, groups by thread
6. For each thread, it creates/resolves an `McpAgent` via `IAgentFactory`
7. The agent streams through `ToolApprovalChatClient` -> `OpenRouterChatClient` -> OpenRouter API
8. Tool calls are intercepted: whitelisted tools auto-execute; others await user approval via `IToolApprovalHandler`
9. Tools execute against MCP servers over HTTP (loaded dynamically per `AgentDefinition.McpServerEndpoints`)
10. Response updates stream back through `IChatMessengerClient.ProcessResponseStreamAsync()`
11. `WebChatMessengerClient` pushes `ChatStreamMessage` chunks to the SignalR client
12. `HubEventDispatcher` dispatches actions to the Redux-like stores, updating the Blazor UI reactively

### MCP Server Request Flow

1. `McpAgent` creates `ThreadSession` which initializes `McpClientManager`
2. `McpClientManager.CreateAsync()` connects to each MCP server endpoint via HTTP
3. Tools, prompts, and resources are loaded from all connected MCP servers
4. When the LLM calls a tool, `ToolApprovalChatClient` checks approval, then MCP SDK routes the call to the correct server
5. MCP server receives the call, resolves DI, executes the MCP tool class (which inherits from the Domain tool)
6. Result flows back through MCP protocol to the agent

## Dependency Injection

**Pattern**: Module-based registration with extension methods on `IServiceCollection`

- **Agent composition root**: `Agent/Modules/ConfigModule.cs` orchestrates registration via `ConfigureAgents()` which calls `AddAgent()`, `AddScheduling()`, `AddChatMonitoring()`
- **Agent DI module**: `Agent/Modules/InjectorModule.cs` -- registers core services (Redis, ChatThreadResolver, AgentFactory, chat interface clients)
- **Scheduling DI module**: `Agent/Modules/SchedulingModule.cs` -- registers schedule stores, tools, dispatchers
- **MCP Server DI**: Each MCP server has its own `Modules/ConfigModule.cs` and optionally `Modules/InjectorModule.cs`
- **WebChat.Client DI**: `WebChat.Client/Extensions/ServiceCollectionExtensions.cs`
- **Registration style**: Use `IServiceCollection` extension methods. Group registrations by feature in static module classes using C# 14 `extension` blocks.

## Error Handling

- **MCP tool errors**: Centralized via `AddCallToolFilter` in each MCP server's `ConfigModule.cs`. Catches all exceptions and returns `ToolResponse.Create(ex)`. Do NOT add try/catch in individual MCP tool methods.
- **Chat pipeline errors**: `ChatMonitor.Monitor()` catches exceptions at the outer and inner levels, logging via `ILogger<ChatMonitor>`.
- **Tool approval rejection**: `ToolApprovalChatClient` sets `context.Terminate = true` and returns a rejection message to the LLM.
- **Result type**: `FluentResults` is available in Domain but the primary pattern is exception-based with catch at boundaries.

## Cross-Cutting Concerns

### Logging

- **Pattern**: Inject `ILogger<T>` via primary constructor. Use structured logging with `LogError`, `LogWarning`, `LogInformation`.
- **Rule**: Never use `Console.WriteLine` or `Console.Log`. Use the `Microsoft.Extensions.Logging` abstractions.

### Authentication / Authorization

- **WebChat**: DDNS IP allowlist middleware (`Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs`) registered via `app.UseDdnsIpAllowlist()`. No token-based auth -- relies on network-level access control.
- **Telegram**: Allowed usernames configured in `AgentSettings.Telegram.AllowedUserNames`.
- **MCP Servers**: No built-in auth -- expected to run on a private Docker network.

### Tool Approval

- **Middleware**: `Infrastructure/Agents/ChatClients/ToolApprovalChatClient.cs` wraps the LLM chat client as a `FunctionInvokingChatClient` delegating handler.
- **Pattern**: Each tool call is checked against whitelist patterns (`AgentDefinition.WhitelistPatterns`). Matching tools auto-execute with notification. Non-matching tools require explicit user approval via the interface-specific `IToolApprovalHandler`.
- **Dynamic approval**: Users can choose "Approve and Remember" to whitelist a tool for the session.

### Configuration

- **Pattern**: Strongly-typed settings bound from `IConfiguration` (appsettings.json + environment variables + user secrets).
- **Agent settings**: `Agent/Settings/AgentSettings.cs` -- OpenRouter config, Telegram config, Redis config, ServiceBus config, agent definitions.
- **MCP settings**: Each MCP server has `Settings/McpSettings.cs` with server-specific config.
- **CLI params**: `Agent/Settings/CommandLineParams.cs` parsed via `System.CommandLine` in `Agent/Modules/ConfigModule.cs`.

### Resilience

- **HTTP retry**: `Infrastructure/Extensions/HttpClientBuilderExtensions.cs` provides `AddRetryWithExponentialWaitPolicy()` using Polly.
- **MCP client retry**: `McpClientManager` uses Polly `WaitAndRetryAsync` for initial MCP server connections.
- **Chat monitoring**: `ChatMonitoring` background service wraps `ChatMonitor.Monitor()` in a `while` loop, restarting on failure.

### Real-time Communication

- **Protocol**: SignalR (WebSocket with fallback)
- **Hub**: `Agent/Hubs/ChatHub.cs` -- handles session management, message sending/receiving, stream resumption, topic CRUD, and tool approval responses.
- **Notifications**: `Infrastructure/Clients/Messaging/WebChat/HubNotifier.cs` pushes server-initiated events (topic changes, stream state changes, approval resolutions) to all connected clients via `IHubContext<ChatHub>`.
- **Client-side**: `WebChat.Client/State/Hub/HubEventDispatcher.cs` receives SignalR events and dispatches Redux actions to update stores.

### Scheduling

- **Components**: `Domain/Monitor/ScheduleDispatcher.cs` (checks due schedules), `Domain/Monitor/ScheduleExecutor.cs` (executes scheduled agent runs), `Agent/App/ScheduleMonitoring.cs` (background service)
- **Storage**: `Infrastructure/StateManagers/RedisScheduleStore.cs` via `Domain/Contracts/IScheduleStore.cs`
- **Tools**: `Domain/Tools/Scheduling/ScheduleCreateTool.cs`, `ScheduleListTool.cs`, `ScheduleDeleteTool.cs` -- registered as `IDomainToolFeature` via `SchedulingToolFeature`
