# Architecture

> Auto-generated by /codemap-creator. Prescriptive guide for system architecture.

## Architecture Pattern

**Pattern**: Clean Architecture (Domain-centric layered) with MCP satellite services

The system follows a three-layer architecture where `Domain` is the innermost layer with zero external dependencies, `Infrastructure` implements domain contracts against real services, and `Agent` is the composition root that wires everything together. MCP servers run as independent HTTP processes that the agent connects to at runtime via the Model Context Protocol.

## Layers

### Domain (Innermost -- Pure Business Logic)
- **Location**: `Domain/`
- **Responsibility**: Contracts, DTOs, domain tools, prompts, agent orchestration, scheduling logic
- **Can import from**: Only .NET BCL and abstraction packages (`Microsoft.Extensions.AI.Abstractions`, `FluentResults`, `NCrontab`)
- **Cannot import from**: `Infrastructure`, `Agent`, any framework-specific type (`HttpClient`, `DbContext`, Redis, Telegram, etc.)
- **Enforced by**: `.claude/rules/domain-layer.md` -- no concrete implementations, no external service references

### Infrastructure (Middle -- External Integrations)
- **Location**: `Infrastructure/`
- **Responsibility**: Implement domain interfaces against real services (OpenRouter, Redis, Telegram, Playwright, MCP, ServiceBus, qBittorrent, Jackett)
- **Can import from**: `Domain`, NuGet packages for external clients
- **Cannot import from**: `Agent` namespace -- the composition root is off-limits
- **Enforced by**: `.claude/rules/infrastructure-layer.md`

### Agent (Outermost -- Composition Root)
- **Location**: `Agent/`
- **Responsibility**: DI container setup, hosted service registration, SignalR hub, CLI argument parsing, application entry point
- **Can import from**: `Domain`, `Infrastructure`
- **Cannot import from**: Nothing restricts it -- this is the outermost shell

### WebChat.Client (Parallel -- Blazor WASM Frontend)
- **Location**: `WebChat.Client/`
- **Responsibility**: Browser-side UI, Redux-like state management, SignalR client, streaming display
- **Can import from**: `Domain` (shared DTOs only), System.Reactive, Markdig, SignalR Client
- **Cannot import from**: `Infrastructure`, `Agent`

### WebChat (Parallel -- Static File Server)
- **Location**: `WebChat/`
- **Responsibility**: Serve Blazor WASM files, provide `/api/config` and `/api/spaces/{slug}` endpoints, dynamic PWA manifest
- **Can import from**: `Domain` (shared DTOs), `Infrastructure` (DDNS middleware only)
- **Cannot import from**: `Agent`

### MCP Servers (Satellite Processes)
- **Location**: `McpServer*/`
- **Responsibility**: Expose domain tools as MCP tool endpoints over HTTP, each running as an independent ASP.NET process
- **Can import from**: `Domain` (base tool classes), `Infrastructure` (client implementations)
- **Cannot import from**: `Agent`, `WebChat.Client`

## Key Abstractions

### IChatMessengerClient
- **Interface**: `Domain/Contracts/IChatMessengerClient.cs`
- **Implementations**: `Infrastructure/Clients/Messaging/Telegram/TelegramChatClient.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/Cli/CliChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/Cli/OneShotChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/ServiceBus/ServiceBusChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/CompositeChatMessengerClient.cs`
- **Purpose**: Abstracts the message transport layer so the `ChatMonitor` is unaware of whether messages arrive from Telegram, WebChat, CLI, or ServiceBus
- **Selection**: Configured at startup via `--chat` CLI argument in `Agent/Modules/InjectorModule.cs`

### IAgentFactory / IScheduleAgentFactory
- **Interface**: `Domain/Contracts/IAgentFactory.cs`, `Domain/Contracts/IScheduleAgentFactory.cs`
- **Implementation**: `Infrastructure/Agents/MultiAgentFactory.cs`
- **Purpose**: Creates `McpAgent` instances from `AgentDefinition` configuration, wiring up the OpenRouter chat client, tool approval, MCP endpoints, and domain tools

### IToolApprovalHandler
- **Interface**: `Domain/Contracts/IToolApprovalHandler.cs`
- **Implementations**: `Infrastructure/Clients/ToolApproval/AutoToolApprovalHandler.cs`, `Infrastructure/Clients/ToolApproval/CliToolApprovalHandler.cs`, `Infrastructure/Clients/ToolApproval/TelegramToolApprovalHandler.cs`, `Infrastructure/Clients/ToolApproval/WebToolApprovalHandler.cs`
- **Purpose**: Gate tool execution -- each transport has its own approval UX. The `ToolApprovalChatClient` (`Infrastructure/Agents/ChatClients/ToolApprovalChatClient.cs`) wraps the inner chat client and intercepts function calls to check whitelist patterns or request human approval

### IThreadStateStore
- **Interface**: `Domain/Contracts/IThreadStateStore.cs`
- **Implementation**: `Infrastructure/StateManagers/RedisThreadStateStore.cs`
- **Purpose**: Persist chat message history and topic metadata to Redis so conversations survive restarts

### IDomainToolFeature / IDomainToolRegistry
- **Interface**: `Domain/Contracts/IDomainToolFeature.cs`, `Domain/Contracts/IDomainToolRegistry.cs`
- **Implementation**: `Infrastructure/Agents/DomainToolRegistry.cs`
- **Purpose**: Feature-flag system for domain tools. Each `AgentDefinition.EnabledFeatures` array selects which `IDomainToolFeature` implementations contribute tools to that agent instance

### Store<TState> (WebChat.Client)
- **Interface**: `WebChat.Client/State/Store.cs`
- **Purpose**: Generic reactive store backed by `BehaviorSubject<TState>`. Each feature (Topics, Messages, Streaming, Connection, Approval, UserIdentity, Toast, Space) has its own `Store<T>` instance

## Data Flow

### Message Pipeline (Backend)

```
User Input
    |
    v
IChatMessengerClient.ReadPrompts()      <-- Telegram / WebChat / CLI / ServiceBus
    |
    v
ChatMonitor.Monitor()                   <-- Domain/Monitor/ChatMonitor.cs
    |  groups by AgentKey, processes per-thread
    v
IAgentFactory.Create(agentKey)          <-- Creates McpAgent with MCP + domain tools
    |
    v
McpAgent.RunStreamingAsync()            <-- Infrastructure/Agents/McpAgent.cs
    |  creates ThreadSession -> McpClientManager -> connects to MCP servers
    v
ToolApprovalChatClient                  <-- Intercepts tool calls for approval
    |
    v
OpenRouterChatClient                    <-- Infrastructure/Agents/ChatClients/OpenRouterChatClient.cs
    |  streams to OpenRouter LLM API
    v
IChatMessengerClient.ProcessResponseStreamAsync()
    |
    v
User sees response (Telegram / WebChat / CLI / ServiceBus)
```

### WebChat Real-Time Flow

```
Browser (Blazor WASM)
    |
    v  SignalR streaming call
ChatHub.SendMessage()                   <-- Agent/Hubs/ChatHub.cs
    |
    v
WebChatMessengerClient                  <-- Enqueues prompt, returns live stream
    |
    v
ChatMonitor picks up prompt             <-- Same pipeline as above
    |
    v
Response streams back via:
  1. SignalR streaming return (for the sender)
  2. HubNotifier broadcasts to space group (for other viewers)
```

### WebChat State Flow (Frontend)

```
User Action
    |
    v
Component dispatches IAction            <-- via IDispatcher
    |
    v
Dispatcher fans out to:
  - Store<T>.Dispatch(action, reducer)  <-- Synchronous state update
  - Effect handlers                     <-- Async side effects (API calls, streaming)
    |
    v
Store<T> emits new state via BehaviorSubject
    |
    v
StoreSubscriberComponent.Subscribe()   <-- DistinctUntilChanged + InvokeAsync + StateHasChanged
    |
    v
Blazor re-renders
```

### MCP Tool Execution Flow

```
LLM decides to call a tool
    |
    v
ToolApprovalChatClient.InvokeFunctionAsync()
    |  checks whitelist patterns / requests approval
    v
QualifiedMcpTool (MCP client-side proxy)
    |  HTTP call to MCP server
    v
McpServer*.McpTools.Mcp*Tool.McpRun()
    |  delegates to Domain tool base class
    v
Domain tool logic (Domain/Tools/*.cs)
    |  calls domain contracts (IDownloadClient, ISearchClient, etc.)
    v
Result returns through MCP protocol -> LLM
```

## Dependency Injection

**Pattern**: Module-based registration in the composition root

- **Agent DI**: `Agent/Modules/InjectorModule.cs` -- registers all backend services
- **Agent Config**: `Agent/Modules/ConfigModule.cs` -- binds `AgentSettings` from user secrets
- **Agent Scheduling**: `Agent/Modules/SchedulingModule.cs` -- registers schedule tools and hosted services
- **WebChat.Client DI**: `WebChat.Client/Extensions/ServiceCollectionExtensions.cs` -- registers stores, effects, services
- **MCP Servers DI**: Each `McpServer*/Modules/ConfigModule.cs` configures its own DI

**Registration conventions**:
- Singletons for stateful services (`ChatThreadResolver`, `WebChatSessionManager`, stores)
- Transient for stateless tools (`ScheduleCreateTool`, etc.)
- Scoped for WebChat.Client stores and effects (Blazor WASM scoped = singleton in practice, but follows convention)
- `IOptions<T>` / `IOptionsMonitor<T>` for configuration that may reload

## Error Handling

### Backend
- **MCP tools**: Global `AddCallToolFilter` in each server's `ConfigModule.cs` catches exceptions, logs them, and returns `ToolResponse.Create(ex)`. Individual tool methods must NOT add try/catch.
- **Chat pipeline**: `ChatMonitor` catches exceptions at the monitor level and logs them. Individual agent runs use `WithErrorHandling()` extension for graceful streaming error recovery.
- **Tool approval rejection**: Returns a descriptive string message instead of throwing, so the LLM can react.

### Frontend
- **SignalR disconnection**: `ReconnectionEffect` handles automatic reconnection with retry logic
- **Streaming errors**: `TransientErrorFilter` (`WebChat.Client/Services/Streaming/TransientErrorFilter.cs`) detects transient failures during stream resumption
- **Toast notifications**: `ToastStore` (`WebChat.Client/State/Toast/ToastStore.cs`) surfaces user-facing error messages

## Cross-Cutting Concerns

### Multi-Transport Messaging
- **Router**: `Domain/Routers/MessageSourceRouter.cs` -- routes responses to the correct transport when ServiceBus + WebChat run simultaneously
- **Composite client**: `Infrastructure/Clients/Messaging/CompositeChatMessengerClient.cs` -- multiplexes multiple `IChatMessengerClient` implementations
- **Pattern**: The `--chat` CLI flag selects the transport at startup. When `Web` mode is active and ServiceBus is configured, both run together via `CompositeChatMessengerClient`

### Tool Approval
- **Pipeline**: `ToolApprovalChatClient` wraps the inner `IChatClient` as a `FunctionInvokingChatClient`. Before each tool invocation it checks `ToolPatternMatcher` for whitelist match, then delegates to the transport-specific `IToolApprovalHandler`.
- **Dynamic approval**: `ApprovedAndRemember` result adds the tool name to a per-agent in-memory set, auto-approving future calls to the same tool within that session.

### Space Isolation (WebChat)
- **SignalR groups**: Users join a `space:{slug}` group via `ChatHub.JoinSpace()`. Notifications (topic changes, stream updates) are broadcast only to the relevant space group.
- **Frontend routing**: `SpaceEffect` (`WebChat.Client/State/Effects/SpaceEffect.cs`) manages space selection and reloads topics when the space changes.
- **Configuration**: `SpaceConfig` (`Domain/DTOs/WebChat/SpaceConfig.cs`) defines per-space name, slug, accent color.

### Scheduling
- **Dispatcher**: `Domain/Monitor/ScheduleDispatcher.cs` polls for due schedules and writes them to a `Channel<Schedule>`
- **Executor**: `Domain/Monitor/ScheduleExecutor.cs` reads from the channel and triggers agent runs
- **Storage**: `Infrastructure/StateManagers/RedisScheduleStore.cs` persists schedules to Redis
- **Hosted services**: `Agent/App/ScheduleMonitoring.cs` runs both dispatcher and executor as background services

### MCP Resource Subscriptions
- **Manager**: `Infrastructure/Agents/Mcp/McpResourceManager.cs` syncs MCP resources and subscribes to change notifications
- **Pattern**: Resource changes from MCP servers are merged into the agent's response stream via `System.Threading.Channels`, so the LLM sees resource updates alongside its own responses

### Chat Thread Management
- **Resolver**: `Domain/Agents/ChatThreadResolver.cs` maps `AgentKey` to `ChatThreadContext`, managing cancellation tokens and completion callbacks per conversation thread
- **Persistence**: Thread state (message history) is stored in Redis via `IThreadStateStore`, keyed by `AgentKey.ToString()` format `agent-key:{agentId}:{chatId}:{threadId}`
