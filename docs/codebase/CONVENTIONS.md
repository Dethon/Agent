# Coding Conventions

> Auto-generated by /codemap-creator. Prescriptive guide for code style and patterns.

## Language and Framework

- **Language**: C# 14 on .NET 10 LTS
- **Nullable reference types**: Always enabled (`<Nullable>enable</Nullable>`)
- **Implicit usings**: Always enabled (`<ImplicitUsings>enable</ImplicitUsings>`)

## Naming Conventions

### Classes and Types
- **Style**: PascalCase
- **Examples**: `ChatThreadResolver`, `McpAgent`, `WebChatStreamManager`
- **Interfaces**: Prefix with `I` -- `IChatMessengerClient`, `IScheduleStore`, `IToolApprovalHandler`
- **Records**: PascalCase, same as classes -- `ChatPrompt`, `AiResponse`, `SpaceState`

### Methods and Properties
- **Style**: PascalCase
- **Async suffix**: Append `Async` to all async methods -- `CreateAsync`, `SearchAsync`, `RunCoreStreamingAsync`
- **Examples**: `ValidateAndResolvePath`, `GetOrCreateSessionAsync`, `DisposeThreadSessionAsync`

### Fields
- **Private fields**: `_camelCase` with underscore prefix
- **Examples**: `_isDisposed`, `_syncLock`, `_threadSessions`, `_customInstructions`

```csharp
// CORRECT
private readonly SemaphoreSlim _syncLock = new(1, 1);
private int _isDisposed;

// INCORRECT
private readonly SemaphoreSlim syncLock = new(1, 1);
private int isDisposed;
```

### Constants
- **Style**: PascalCase (NOT UPPER_SNAKE_CASE)
- **Examples**: `SearchEndpoint`, `RedisPort`, `Name`, `Description`

```csharp
// CORRECT - PascalCase constants
private const string SearchEndpoint = "web/search";
private const int RedisPort = 6379;

// INCORRECT
private const string SEARCH_ENDPOINT = "web/search";
```

### Local Variables and Parameters
- **Style**: camelCase
- **Examples**: `filePath`, `cancellationToken`, `apiKey`, `validAgentIds`

### Files
- **Style**: PascalCase, matching the primary type name
- **Pattern**: `TypeName.cs` (e.g., `ChatThreadResolver.cs`, `BraveSearchClient.cs`)
- **Test files**: `{ClassUnderTest}Tests.cs` (e.g., `ToolPatternMatcherTests.cs`)

### Directories
- **Style**: PascalCase
- **Examples**: `Contracts/`, `DTOs/`, `Agents/`, `StateManagers/`, `McpTools/`

### Test Method Names
- **Pattern**: `{Method}_{Scenario}_{ExpectedResult}`
- **Examples**: `Run_TextNotFound_ThrowsWithSuggestion`, `CreateAsync_StoresSchedule`, `IsMatch_EmptyPatterns_MatchesNothing`

```csharp
// CORRECT
[Fact]
public void Run_MultipleOccurrences_ReplaceAllFalse_Throws()

// INCORRECT
[Fact]
public void TestRunMultipleOccurrences()
```

## Code Style

### Namespaces
- **File-scoped namespaces only** (enforced as warning in `.editorconfig`)

```csharp
// CORRECT
namespace Domain.DTOs;

// INCORRECT
namespace Domain.DTOs
{
    // ...
}
```

### Primary Constructors
- Use primary constructors for dependency injection and simple data classes

```csharp
// CORRECT - Primary constructor for DI
public class BraveSearchClient(HttpClient httpClient, string apiKey) : IWebSearchClient
{
    // ...
}

// CORRECT - Primary constructor for test helpers
private class TestableTextEditTool(string vaultPath, string[] allowedExtensions)
    : TextEditTool(vaultPath, allowedExtensions)
```

### Record Types
- Use `record` for DTOs, state objects, and immutable data
- Use `required` properties or `init`-only setters

```csharp
// DTO with required properties
public record ChatPrompt
{
    public required string Prompt { get; init; }
    public required long ChatId { get; init; }
    public required int? ThreadId { get; init; }
}

// Simple action records (one-line when possible)
public record SelectSpace(string Slug) : IAction;
public record SpaceValidated(string Slug, string Name, string AccentColor) : IAction;

// Internal data records
internal sealed record ThreadSessionData(
    McpClientManager ClientManager,
    McpResourceManager ResourceManager,
    IReadOnlyList<AITool> Tools);
```

### `var` Usage
- Prefer `var` everywhere (enforced as suggestion in `.editorconfig`)

```csharp
// CORRECT
var response = await httpClient.SendAsync(request, ct);
var braveResponse = await response.Content.ReadFromJsonAsync<BraveSearchResponse>(ct);

// INCORRECT
HttpResponseMessage response = await httpClient.SendAsync(request, ct);
```

### Imports
- System usings sorted first (enforced via `dotnet_sort_system_directives_first = true`)
- External packages next
- Internal project imports last

```csharp
// 1. System namespaces
using System.Net.Http.Json;
using System.Text.Json.Serialization;

// 2. External packages
using Domain.Contracts;
using JetBrains.Annotations;

// 3. Internal project imports
using Infrastructure.Utils;
```

### Exports / Visibility
- **Prefer `internal sealed`** for implementation classes that do not need to be public
- Use `[InternalsVisibleTo("Tests")]` in Infrastructure to enable test access (`Infrastructure.csproj:22`)
- Use `[PublicAPI]` from JetBrains.Annotations on public types consumed across project boundaries

```csharp
// Internal implementation detail
internal sealed class ThreadSession : IAsyncDisposable { }

// Public API type
[PublicAPI]
public record ChatPrompt { }
```

### Braces
- **Always required** for `if`, `else`, `for`, `foreach`, `while`, `using`, `lock`, `fixed` (enforced as warning)
- Open braces on new line (Allman style)

```csharp
// CORRECT
if (condition)
{
    DoSomething();
}

// INCORRECT
if (condition)
    DoSomething();

// INCORRECT
if (condition) {
    DoSomething();
}
```

### Expression-Bodied Members
- Use for simple properties and accessors
- Do NOT use for methods and constructors

```csharp
// CORRECT - Expression-bodied property
public TState State => _subject.Value;
public void Dispose() => _subject.Dispose();

// CORRECT - Block body for methods
public async Task<WebSearchResult> SearchAsync(WebSearchQuery query, CancellationToken ct = default)
{
    // ...
}
```

### Switch Expressions
- Prefer switch expressions for pattern matching

```csharp
// CORRECT
public static SpaceState Reduce(SpaceState state, IAction action) => action switch
{
    SelectSpace a => state with { CurrentSlug = a.Slug },
    SpaceValidated a => new SpaceState { CurrentSlug = a.Slug, SpaceName = a.Name },
    InvalidSpace => SpaceState.Initial,
    _ => state
};
```

## LINQ Over Loops

Strongly prefer LINQ over `for`/`foreach`/`while` loops. Only use loops when mutating external state, complex control flow requires it, or in performance-critical hot paths.

```csharp
// CORRECT
var items = results.Select(r => new WebSearchResultItem(
    Title: r.Title ?? string.Empty,
    Url: r.Url ?? string.Empty
)).ToList();

var toolNames = session.ClientManager.Tools.Select(t => t.Name).ToList();

// INCORRECT
var items = new List<WebSearchResultItem>();
foreach (var r in results)
{
    items.Add(new WebSearchResultItem(r.Title ?? string.Empty, r.Url ?? string.Empty));
}
```

## Async Patterns

### async/await Throughout
- Use `async`/`await` for all asynchronous operations
- Pass `CancellationToken` through all async call chains
- Use `ct` as the abbreviated parameter name in private methods, `cancellationToken` in public APIs

```csharp
// Public API - full parameter name
public async Task<WebSearchResult> SearchAsync(WebSearchQuery query, CancellationToken cancellationToken = default)

// Private/internal - abbreviated
private async Task<ThreadSession> GetOrCreateSessionAsync(AgentSession thread, CancellationToken ct)
```

### IAsyncEnumerable for Streaming
- Use `IAsyncEnumerable<T>` for streaming data
- Annotate with `[EnumeratorCancellation]` on the `CancellationToken` parameter

```csharp
protected override async IAsyncEnumerable<AgentResponseUpdate> RunCoreStreamingAsync(
    IEnumerable<ChatMessage> messages,
    AgentSession? thread = null,
    AgentRunOptions? options = null,
    [EnumeratorCancellation] CancellationToken cancellationToken = default)
{
    await foreach (var update in source.WithCancellation(cancellationToken))
    {
        yield return update;
    }
}
```

### Dispose Pattern
- Use `IAsyncDisposable` for async cleanup
- Guard against double disposal with `Interlocked.Exchange`

```csharp
public async ValueTask DisposeAsync()
{
    if (Interlocked.Exchange(ref _isDisposed, 1) == 1)
    {
        return;
    }

    await _data.ResourceManager.DisposeAsync();
    await _data.ClientManager.DisposeAsync();
}
```

## Error Handling

### Guard Clauses
- Use `ArgumentNullException.ThrowIfNull()` for null checks
- Use `ObjectDisposedException.ThrowIf()` for disposed object checks

```csharp
// CORRECT
ArgumentNullException.ThrowIfNull(initialState);
ObjectDisposedException.ThrowIf(_isDisposed == 1, this);

// INCORRECT
if (initialState == null) throw new ArgumentNullException(nameof(initialState));
```

### Domain Tool Errors
- Throw typed exceptions: `InvalidOperationException`, `UnauthorizedAccessException`, `FileNotFoundException`
- Never throw raw `Exception`

```csharp
// CORRECT - Typed exceptions in domain tools
throw new UnauthorizedAccessException("Access denied: path must be within vault directory");
throw new InvalidOperationException($"File type '{ext}' not allowed.");
throw new FileNotFoundException($"File not found: {filePath}");
```

### MCP Tool Error Handling
- Error handling is centralized via `AddCallToolFilter` in each server's `ConfigModule.cs`
- Individual MCP tool methods must NOT contain try/catch blocks
- Exceptions propagate to the global filter which logs and returns `ToolResponse.Create(ex)`

```csharp
// CORRECT - No try/catch in MCP tool
[McpServerTool(Name = Name)]
[Description(Description)]
public async Task<CallToolResult> McpRun(string pattern, GlobMode mode, CancellationToken cancellationToken)
{
    return ToolResponse.Create(await Run(pattern, mode, cancellationToken));
}

// INCORRECT - Do not add try/catch in individual tools
[McpServerTool(Name = Name)]
public async Task<CallToolResult> McpRun(string pattern)
{
    try { return ToolResponse.Create(await Run(pattern)); }
    catch (Exception ex) { return ToolResponse.Create(ex); } // NO - filter handles this
}
```

### Null Handling
- Use null-conditional (`?.`) and null-coalescing (`??`) operators
- Return `null` for "not found" scenarios, throw for unexpected states

```csharp
var braveResponse = await response.Content.ReadFromJsonAsync<BraveSearchResponse>(ct)
    ?? throw new InvalidOperationException("Failed to deserialize response");
```

## Layer Architecture Rules

### Domain Layer (`Domain/`)
- Pure business logic with no external dependencies
- Never import from `Infrastructure` or `Agent` namespaces
- Contains: Contracts (interfaces), DTOs (records), Tools (business logic), Agents, Prompts

### Infrastructure Layer (`Infrastructure/`)
- Implements Domain interfaces, handles external concerns
- Never import from `Agent` namespace
- Uses primary constructors for DI

### Agent Layer (`Agent/`)
- Composition root: DI registration, bootstrapping, Program.cs entry point

### MCP Server Projects (`McpServer*/`)
- Wrap Domain tools via MCP protocol
- Inherit from Domain tool, add `[McpServerToolType]` and `[McpServerTool]` attributes

## DI Registration

### Extension Method Pattern
- Use `extension` blocks (C# 14) or static extension methods for DI configuration
- Chain `.AddSingleton<>()` calls fluently

```csharp
// C# 14 extension block pattern (see Agent/Modules/InjectorModule.cs)
extension(IServiceCollection services)
{
    public IServiceCollection AddAgent(AgentSettings settings)
    {
        return services
            .AddSingleton<ChatThreadResolver>()
            .AddSingleton<IDomainToolRegistry, DomainToolRegistry>()
            .AddSingleton<IAgentFactory>(sp =>
                new MultiAgentFactory(sp, ...));
    }
}
```

## WebChat State Management (Redux-like)

### Pattern Components
- **State**: Immutable `sealed record` with `Initial` static property
- **Actions**: `record` types implementing `IAction`
- **Reducers**: Pure static functions using switch expressions
- **Store**: Generic `Store<TState>` wrapping `BehaviorSubject<TState>`
- **Effects**: Async side-effect handlers
- **Selectors**: Memoized projections via `Selector<TState, TResult>`

```csharp
// State
public sealed record SpaceState
{
    public string CurrentSlug { get; init; } = "default";
    public static SpaceState Initial => new();
}

// Actions
public record SelectSpace(string Slug) : IAction;
public record SpaceValidated(string Slug, string Name, string AccentColor) : IAction;

// Reducer
public static class SpaceReducers
{
    public static SpaceState Reduce(SpaceState state, IAction action) => action switch
    {
        SelectSpace a => state with { CurrentSlug = a.Slug },
        SpaceValidated a => new SpaceState { CurrentSlug = a.Slug, SpaceName = a.Name },
        _ => state
    };
}

// Store
public sealed class SpaceStore : IDisposable
{
    private readonly Store<SpaceState> _store;

    public SpaceStore(Dispatcher dispatcher)
    {
        _store = new Store<SpaceState>(SpaceState.Initial);
        dispatcher.RegisterHandler<SelectSpace>(action =>
            _store.Dispatch(action, SpaceReducers.Reduce));
    }
}
```

## Documentation

### Comments
- Prioritize readable code over comments
- No XML documentation comments (`///`)
- Only comment to explain "why", never "what"
- Use `[PublicAPI]` and `[UsedImplicitly]` from JetBrains.Annotations to suppress unused-code warnings instead of comments

```csharp
// CORRECT - Explains "why"
// Step 1: Create sampling handler with deferred tool access

// INCORRECT - Explains "what"
// Creates a new instance of the sampling handler
```

## Formatting

### Indentation
- 4 spaces for C# code files
- 2 spaces for XML project files (`.csproj`, `.props`)
- Line endings: CRLF
- Max line length: 120 characters
- No final newline required

### Collection Expressions
- Use collection expression syntax (`[]`) for empty collections

```csharp
// CORRECT
private readonly ConcurrentDictionary<AgentSession, ThreadSession> _threadSessions = [];
_domainTools = domainTools ?? [];

// INCORRECT
private readonly ConcurrentDictionary<AgentSession, ThreadSession> _threadSessions = new();
_domainTools = domainTools ?? Array.Empty<AIFunction>();
```

### Spread Operator
- Use `[.. collection]` for creating new collections from existing ones

```csharp
var options = new ChatOptions
{
    Tools = [.. session.Tools],
    Instructions = string.Join("\n\n", prompts)
};
```
