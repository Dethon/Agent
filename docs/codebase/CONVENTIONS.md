# Coding Conventions

> Auto-generated by /codemap-creator. Prescriptive guide for code style and patterns.

## Language and Framework

- **Language**: C# 14 on .NET 10 LTS
- **Nullable**: Enable nullable reference types in all projects
- **Implicit Usings**: Enabled across all projects
- **Namespace Style**: File-scoped namespaces (`namespace Foo;`)

## Naming Conventions

### Variables and Functions

- **Local variables / parameters**: camelCase
- **Private fields**: `_camelCase` (underscore-prefixed camelCase)
- **Public fields**: PascalCase
- **Methods / Properties**: PascalCase
- **Examples**: `_server`, `userId`, `SearchAsync`, `ConnectionString`

```csharp
// Private fields
private readonly WireMockServer _server;
private int _isDisposed;

// Parameters and locals
var userId = $"user_{Guid.NewGuid():N}";
var result = await store.SearchAsync(userId);
```

See `Infrastructure/Agents/McpAgent.cs:17-27` for canonical field naming.

### Classes and Types

- **Style**: PascalCase
- **Interfaces**: `I`-prefixed PascalCase (`ISearchClient`, `IChatMessengerClient`)
- **Abstract classes**: No prefix, descriptive name (`DisposableAgent`)
- **Examples**: `BraveSearchClient`, `McpAgent`, `ChatThreadResolver`

See `Domain/Contracts/IChatMessengerClient.cs` for interface naming.

### Constants

- **Style**: PascalCase (not UPPER_SNAKE_CASE)
- **Examples**: `SearchEndpoint`, `RedisPort`, `EmbeddingDimension`

```csharp
private const string SearchEndpoint = "web/search";
private const int RedisPort = 6379;
```

See `Infrastructure/Clients/BraveSearchClient.cs:11`.

### Files

- **Style**: PascalCase, matching the primary type name
- **Pattern**: `{TypeName}.cs` (one primary type per file)
- **Examples**: `BraveSearchClient.cs`, `ChatPrompt.cs`, `McpFileSearchTool.cs`

### Directories

- **Style**: PascalCase
- **Plural**: Use plural for collections (`Agents/`, `Clients/`, `DTOs/`, `Tools/`)
- **Singular**: Use singular for specific concerns (`Memory/`, `State/`)
- **Examples**: `Domain/Contracts/`, `Infrastructure/Clients/Messaging/`, `Domain/Tools/Files/`

## Code Style

### `var` Preferences

Use `var` everywhere. Do not spell out types when the compiler can infer them.

```csharp
// CORRECT
var response = await httpClient.SendAsync(request, ct);
var items = results.Select(r => new WebSearchResultItem(...)).ToList();

// INCORRECT
HttpResponseMessage response = await httpClient.SendAsync(request, ct);
List<WebSearchResultItem> items = results.Select(...).ToList();
```

### Braces

- **Always required** for `if`, `else`, `for`, `foreach`, `while`, `using`, `lock`, `fixed`
- **Allman style**: Opening brace on its own line

```csharp
// CORRECT
if (string.IsNullOrEmpty(text))
{
    return text;
}

// INCORRECT
if (string.IsNullOrEmpty(text)) return text;
```

See `.editorconfig:155` (`csharp_prefer_braces = true:warning`).

### Imports

Order imports as follows (enforced by `dotnet_sort_system_directives_first`):

```csharp
// 1. System namespaces
using System.Collections.Concurrent;
using System.Text.Json;

// 2. Third-party packages
using Azure.Messaging.ServiceBus;
using ModelContextProtocol.Server;

// 3. Internal project references (Domain first, then Infrastructure)
using Domain.Contracts;
using Domain.DTOs;
using Infrastructure.Agents;
using Infrastructure.Utils;
```

See `Infrastructure/Agents/McpAgent.cs:1-11` for a representative import block.

### Exports / Visibility

- **Prefer explicit access modifiers** (`public`, `private`, `internal`)
- **Default private modifier**: Always write `private` explicitly
- **`InternalsVisibleTo`**: Use for test access to internals (`Infrastructure.csproj` exposes internals to `Tests`)
- **`[PublicAPI]`**: Annotate public DTOs and contracts with `JetBrains.Annotations.PublicAPI` to suppress unused warnings

```csharp
[PublicAPI]
public record ChatPrompt
{
    public required string Prompt { get; init; }
    // ...
}
```

See `Domain/DTOs/ChatPrompt.cs:6`.

## Data Types

### DTOs: Use `record` Types

Define DTOs as `record` types. Use positional records for small, simple types and block-body records with `required` / `init` for larger ones.

```csharp
// Simple DTO - positional record
public record AgentInfo(string Id, string Name, string? Description);

// Complex DTO - block-body record with required properties
public record MemoryEntry
{
    public required string Id { get; init; }
    public required string UserId { get; init; }
    public required MemoryCategory Category { get; init; }
    public required string Content { get; init; }
    public IReadOnlyList<string> Tags { get; init; } = [];
}
```

See `Domain/DTOs/WebChat/AgentInfo.cs` and `Domain/DTOs/Memory.cs`.

### Value Objects: Use `readonly record struct`

Use `readonly record struct` for small, identity-less value types.

```csharp
public readonly record struct AgentKey(long ChatId, long ThreadId, string? AgentId = null);
```

See `Domain/Agents/AgentKey.cs`.

### Settings: Use `record` with `required`

```csharp
public record RedisConfiguration
{
    public required string ConnectionString { get; [UsedImplicitly] init; }
    public int? ExpirationDays { get; [UsedImplicitly] init; }
}
```

See `Agent/Settings/AgentSettings.cs`.

### Enums: PascalCase Members

```csharp
public enum MessageSource
{
    WebUi,
    ServiceBus,
    Telegram,
    Cli
}
```

See `Domain/DTOs/MessageSource.cs`.

## Functions and Methods

### Declaration Style

- Use regular method declarations for class methods
- Use expression-bodied members for simple properties and single-expression accessors
- Use arrow functions (lambdas) for inline delegates

```csharp
// Regular method
public async Task<WebSearchResult> SearchAsync(WebSearchQuery query, CancellationToken ct = default)
{
    // ...
}

// Expression-bodied property
public TState State => _subject.Value;

// Expression-bodied single-line method
public void Dispose() => _subject.Dispose();
```

### Primary Constructors for DI

Use primary constructors for dependency injection. Do not declare separate `private readonly` fields when primary constructor parameters suffice.

```csharp
// CORRECT - primary constructor
public class BraveSearchClient(HttpClient httpClient, string apiKey) : IWebSearchClient
{
    public async Task<WebSearchResult> SearchAsync(...)
    {
        // Use httpClient and apiKey directly
    }
}

// CORRECT - primary constructor with inheritance
[McpServerToolType]
public class McpFileSearchTool(
    ISearchClient client,
    ISearchResultsManager searchResultsManager) : FileSearchTool(client, searchResultsManager)
```

See `Infrastructure/Clients/BraveSearchClient.cs:9` and `McpServerLibrary/McpTools/McpFileSearchTool.cs:12-14`.

Use traditional constructors only when initialization logic is complex (e.g., `McpAgent` at `Infrastructure/Agents/McpAgent.cs:32-64`).

## Async Patterns

### Always Use `async`/`await`

Use `async`/`await` throughout. Never use `.Result` or `.Wait()`. Pass `CancellationToken` on all async operations.

```csharp
public async Task<WebSearchResult> SearchAsync(WebSearchQuery query, CancellationToken ct = default)
{
    var response = await httpClient.SendAsync(request, ct);
    response.EnsureSuccessStatusCode();
    return await response.Content.ReadFromJsonAsync<BraveSearchResponse>(ct);
}
```

### Use `IAsyncEnumerable<T>` for Streaming

Streaming operations return `IAsyncEnumerable<T>` with `[EnumeratorCancellation]` on the cancellation token.

```csharp
protected override async IAsyncEnumerable<AgentResponseUpdate> RunCoreStreamingAsync(
    IEnumerable<ChatMessage> messages,
    AgentSession? thread = null,
    AgentRunOptions? options = null,
    [EnumeratorCancellation] CancellationToken cancellationToken = default)
{
    await foreach (var update in source.WithCancellation(ct))
    {
        yield return update;
    }
}
```

See `Infrastructure/Agents/McpAgent.cs:143-169`.

### Parallel Operations

Use `Promise.all` equivalent patterns via `Task.WhenAll` or the custom `Merge` extension for async streams.

```csharp
// Merging async streams
await foreach (var update in mainResponses.Merge(notificationResponses, cancellationToken))
{
    yield return update;
}
```

See `Domain/Extensions/IAsyncEnumerableExtensions.cs:89`.

## LINQ Over Loops

**Strongly prefer LINQ** over `for`/`foreach`/`while` loops. Only use traditional loops when mutating external state, complex control flow, or performance-critical hot paths.

```csharp
// CORRECT
var items = results.Select(r => new WebSearchResultItem(
    Title: r.Title ?? string.Empty,
    Url: r.Url ?? string.Empty,
    Snippet: TruncateSnippet(r.Description ?? string.Empty, 200),
    Domain: ExtractDomain(r.Url ?? string.Empty),
    DatePublished: ParseDate(r.PageAge)
)).ToList();

// INCORRECT
var items = new List<WebSearchResultItem>();
foreach (var r in results)
{
    items.Add(new WebSearchResultItem(...));
}
```

See `Infrastructure/Clients/BraveSearchClient.cs:60-66`.

## Error Handling

### Guard Clauses

Use `ArgumentNullException.ThrowIfNull()` and `ObjectDisposedException.ThrowIf()` for guard clauses.

```csharp
ArgumentNullException.ThrowIfNull(initialState);
ObjectDisposedException.ThrowIf(_isDisposed == 1, this);
```

See `WebChat.Client/State/Store.cs:13` and `Infrastructure/Agents/McpAgent.cs:87`.

### Domain Exceptions

Throw typed exceptions with descriptive messages. Use `InvalidOperationException` for domain rule violations.

```csharp
throw new InvalidOperationException(
    $"{nameof(RemoveTool)} path must not contain '..' segments.");
```

See `Domain/Tools/Files/RemoveTool.cs:33-36`.

### MCP Tool Error Handling

Error handling for MCP tools is **centralized** via `AddCallToolFilter` in each server's `ConfigModule.cs`. Do NOT add try/catch in individual tool methods.

```csharp
// In ConfigModule.cs - global error filter
.AddCallToolFilter(next => async (context, cancellationToken) =>
{
    try
    {
        return await next(context, cancellationToken);
    }
    catch (Exception ex)
    {
        var logger = context.Services?.GetRequiredService<ILogger<Program>>();
        logger?.LogError(ex, "Error in {ToolName} tool", context.Params?.Name);
        return ToolResponse.Create(ex);
    }
})
```

See `McpServerLibrary/Modules/ConfigModule.cs:64-76`.

### HTTP Error Handling

Use `response.EnsureSuccessStatusCode()` for HTTP calls. Let `HttpRequestException` propagate.

```csharp
var response = await httpClient.SendAsync(request, ct);
response.EnsureSuccessStatusCode();
```

See `Infrastructure/Clients/BraveSearchClient.cs:21-22`.

### Null Handling

- Use nullable reference types (`?`) consistently
- Return `null` for "not found" cases from data stores
- Throw exceptions for invalid arguments and business rule violations
- Use null-coalescing operators (`??`, `??=`) and null-conditional operators (`?.`)

```csharp
var braveResponse = await response.Content.ReadFromJsonAsync<BraveSearchResponse>(ct)
                    ?? throw new InvalidOperationException("Failed to deserialize response");
```

## Pattern Matching

Use pattern matching over type checks and casts.

```csharp
// Switch expressions
queryParams["freshness"] = query.DateRange.Value switch
{
    DateRange.Day => "pd",
    DateRange.Week => "pw",
    DateRange.Month => "pm",
    DateRange.Year => "py",
    _ => throw new ArgumentOutOfRangeException(nameof(query.DateRange))
};

// Pattern matching with is/not
if (data.StartsWith(ApproveCallbackPrefix, StringComparison.Ordinal))
{
    approvalId = data[ApproveCallbackPrefix.Length..];
    result = ToolApprovalResult.Approved;
}
```

See `Infrastructure/Clients/BraveSearchClient.cs:42-49`.

## Dependency Injection

### Registration

Use extension methods on `IServiceCollection` in `Modules/` classes. Group registrations by concern.

```csharp
public static class InjectorModule
{
    extension(IServiceCollection services)
    {
        public IServiceCollection AddAgent(AgentSettings settings)
        {
            return services
                .AddRedis(settings.Redis)
                .AddSingleton<ChatThreadResolver>()
                .AddSingleton<IDomainToolRegistry, DomainToolRegistry>()
                .AddSingleton<IAgentFactory>(sp =>
                    new MultiAgentFactory(sp, ...));
        }
    }
}
```

See `Agent/Modules/InjectorModule.cs`.

### Layer Rules

- **Domain**: Pure business logic. No imports from `Infrastructure` or `Agent` namespaces. No framework-specific types.
- **Infrastructure**: Implements Domain interfaces. No imports from `Agent` namespace.
- **Agent**: Composition root. Handles DI registration and bootstrapping.
- **MCP Servers**: Thin wrappers. Inherit from Domain tools, expose via MCP attributes.

See `.claude/rules/domain-layer.md`, `.claude/rules/infrastructure-layer.md`, `.claude/rules/mcp-tools.md`.

## MCP Tool Pattern

MCP tools inherit from the corresponding Domain tool and expose the method via MCP attributes. Name and Description constants come from the base class.

```csharp
[McpServerToolType]
public class McpFileSearchTool(
    ISearchClient client,
    ISearchResultsManager searchResultsManager) : FileSearchTool(client, searchResultsManager)
{
    [McpServerTool(Name = Name)]
    [Description(Description)]
    public async Task<CallToolResult> Run(
        RequestContext<CallToolRequestParams> context,
        string[] searchStrings,
        CancellationToken cancellationToken)
    {
        var sessionId = context.Server.StateKey;
        return ToolResponse.Create(await Run(sessionId, searchStrings, cancellationToken));
    }
}
```

See `McpServerLibrary/McpTools/McpFileSearchTool.cs`.

## WebChat State Pattern

Use a Redux-like pattern with `Store<TState>`, `IAction`, `Dispatcher`, and `Selector` in `WebChat.Client/State/`.

```csharp
// Store
public sealed class Store<TState> : IDisposable where TState : class
{
    public TState State => _subject.Value;
    public IObservable<TState> StateObservable => _subject.AsObservable();

    public void Dispatch<TAction>(TAction action, Func<TState, TAction, TState> reducer)
        where TAction : IAction
    {
        var newState = reducer(State, action);
        _subject.OnNext(newState);
    }
}
```

See `WebChat.Client/State/Store.cs`.

## Raw String Literals

Use raw string literals (`"""..."""`) for multi-line strings, especially in tool descriptions.

```csharp
protected const string Description = """
                                     Removes a file or directory by moving it to a trash folder.
                                     The path can be absolute (under the library root) or relative
                                     (resolved against the library root).
                                     """;
```

See `Domain/Tools/Files/RemoveTool.cs:11-15`.

## Comments and Documentation

- **Prioritize readable code** over comments
- **No XML documentation comments** (no `///` summary tags)
- **Only comment to explain "why"**, never "what"
- Use `[UsedImplicitly]` from JetBrains.Annotations to suppress unused warnings on serialization properties

```csharp
// CORRECT - explains why
// OpenRouter expects a JSON object; using JsonObject avoids anonymous-type serialization quirks.
["reasoning"] = new JsonObject { ["effort"] = "low" },

// INCORRECT - explains what
// Set the reasoning effort to low
["reasoning"] = new JsonObject { ["effort"] = "low" },
```

See `Infrastructure/Agents/McpAgent.cs:55`.

## Collection Expressions

Use collection expressions (`[]`) for empty collections and initializers.

```csharp
// Empty collection
_domainTools = domainTools ?? [];
public IReadOnlyList<string> Tags { get; init; } = [];

// Collection initializer
var _threadSessions = new ConcurrentDictionary<AgentSession, ThreadSession>();
// Equivalent:
private readonly ConcurrentDictionary<AgentSession, ThreadSession> _threadSessions = [];
```

## Disposal Patterns

- Implement `IAsyncDisposable` for types holding async resources
- Use `Interlocked.Exchange` for thread-safe disposal flags
- Use `SemaphoreSlim` with extension methods for synchronized disposal

```csharp
public override async ValueTask DisposeAsync()
{
    if (Interlocked.Exchange(ref _isDisposed, 1) == 1)
    {
        return;
    }

    await _syncLock.WithLockAsync(async () =>
    {
        foreach (var session in _threadSessions.Values)
        {
            await session.DisposeAsync();
        }
        _threadSessions.Clear();
    });
    _syncLock.Dispose();
}
```

See `Infrastructure/Agents/McpAgent.cs:66-83`.

## Extension Methods

Place extension methods in the layer that owns the types being extended:

- **Domain extensions**: `Domain/Extensions/` (e.g., `IAsyncEnumerableExtensions`, `SemaphoreSlimExtensions`)
- **Infrastructure extensions**: `Infrastructure/Extensions/` (e.g., `McpServerExtensions`, `HttpClientBuilderExtensions`)

Use C# 14 `extension` blocks for cohesive sets of extensions.

```csharp
extension<TSource>(IAsyncEnumerable<TSource> source)
{
    public async IAsyncEnumerable<IAsyncGrouping<TKey, TSource>> GroupByStreaming<TKey>(...) { ... }
    public IAsyncEnumerable<TSource> Merge(IAsyncEnumerable<TSource> right, CancellationToken ct) { ... }
}
```

See `Domain/Extensions/IAsyncEnumerableExtensions.cs:56`.
