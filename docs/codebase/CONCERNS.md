# Technical Concerns

> Auto-generated by /codemap-creator. Prescriptive warnings about technical debt and risk areas.

## Risk Summary

| Severity | Count | Categories |
|----------|-------|------------|
| HIGH | 5 | Security, Reliability |
| MEDIUM | 10 | Security, Maintainability, Performance, Reliability |
| LOW | 5 | Maintainability, Performance |

---

## HIGH Risk Areas

### Command Injection in Shell Runners

**Location**: `Infrastructure/CommandRunners/ShRunner.cs:7`, `Infrastructure/CommandRunners/PowerShellRunner.cs:7`
**Category**: Security
**Risk**: Arbitrary command injection. The `command` parameter is interpolated directly into a shell invocation string with no sanitization or escaping. An attacker-controlled LLM tool call could execute arbitrary system commands.

**Evidence**:
```csharp
// ShRunner.cs:7
return await Run("sh", $"-c \"cd {workingDirectory} && {command}\"", ct);

// PowerShellRunner.cs:7
return await Run("pwsh", $"-WorkingDirectory \"{workingDirectory}\" -Command \"{command}\"", ct);
```

**Guidance**:
- Do NOT pass user/LLM-generated strings to these runners without strict validation
- The tool approval system (`ToolApprovalChatClient`) is the ONLY safeguard; if a command runner tool is whitelisted or auto-approved, any command can be executed
- If you must modify these runners: add input validation, command allowlisting, or sandboxing
- Related files: `Infrastructure/CommandRunners/BaseCliRunner.cs`, `Infrastructure/Clients/ToolApproval/AutoToolApprovalHandler.cs`

**Mitigation**:
- Consider running commands in a restricted container or namespace
- Add command allowlisting at the runner level, not just at the approval layer
- `BaseCliRunner.cs:22` does not capture `StandardError`; errors from shell commands are silently lost

---

### ChatHub Has No Authentication or Authorization

**Location**: `Agent/Hubs/ChatHub.cs:15-264`
**Category**: Security
**Risk**: The SignalR ChatHub exposes all operations (send messages, delete topics, manage sessions, join spaces, respond to tool approvals) with no `[Authorize]` attribute. The only guard is `RegisterUser` which accepts any arbitrary string as a userId with no verification. Any client that can connect to the hub can impersonate any user, read any agent's history, delete any topic, join any space, and approve tool executions.

**Evidence**:
```csharp
// ChatHub.cs:15 - No [Authorize] attribute
public sealed class ChatHub(...) : Hub
{
    // ChatHub.cs:35 - Self-registration with no validation
    public Task RegisterUser(string userId)
    {
        Context.Items["UserId"] = userId;
        return Task.CompletedTask;
    }

    // ChatHub.cs:89 - Any user can join any space (including private ones)
    public async Task JoinSpace(string spaceSlug) { ... }

    // ChatHub.cs:228 - Any user can delete any topic
    public async Task DeleteTopic(string agentId, string topicId, long chatId, long threadId) { ... }

    // ChatHub.cs:250 - Any user can approve tool executions
    public Task<bool> RespondToApprovalAsync(string approvalId, ToolApprovalResult result) { ... }
}
```

**Guidance**:
- Do NOT deploy the WebChat interface on a public network without adding authentication
- The new Spaces feature (`JoinSpace`) provides no authorization -- any user can join any space by slug, defeating the purpose of space isolation for privacy
- The DDNS IP allowlist middleware (`Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs`) provides network-level restriction but is not applied to SignalR connections by default
- If you must expose WebChat externally: add authentication, authorize users per-space and per-topic, and validate userId against an identity provider
- Related files: `Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs`

**Mitigation**:
- Add `[Authorize]` to the Hub class
- Replace `RegisterUser` with claims-based identity from an authentication middleware
- Add per-topic and per-space authorization checks (users should only access their own topics and spaces they are members of)

---

### XSS via Unsanitized Markdown Rendering

**Location**: `WebChat.Client/Components/ChatMessage.razor:160`
**Category**: Security
**Risk**: Agent responses are rendered as raw HTML via `(MarkupString)RenderMarkdown(Message.Content)`. Markdig converts markdown to HTML which is injected directly into the DOM without sanitization. If an LLM response contains malicious HTML/JavaScript (e.g., from a prompt injection attack or a poisoned web page the agent browsed), it will execute in the user's browser within the application context. This gives the attacker access to the SignalR connection, allowing them to approve tool executions, delete topics, or impersonate the user.

**Evidence**:
```csharp
// ChatMessage.razor:160
@((MarkupString)RenderMarkdown(Message.Content))
```

**Guidance**:
- Do NOT trust LLM output as safe HTML; LLMs can be manipulated to produce arbitrary content
- When modifying the rendering pipeline: add an HTML sanitizer (e.g., HtmlSanitizer NuGet package) between Markdig output and MarkupString rendering
- This is especially dangerous combined with the lack of authentication on ChatHub -- an XSS payload can silently call hub methods
- Related files: `WebChat.Client/Components/Chat/MessageList.razor`, `WebChat.Client/Components/Chat/ChatContainer.razor`

**Mitigation**:
- Add an HTML sanitizer (e.g., `HtmlSanitizer` package) to strip scripts, event handlers, and dangerous HTML elements from the rendered markdown
- Alternatively, use a Blazor-native markdown renderer that produces component tree output instead of raw HTML strings

---

### Redis Index Initialization Race Condition

**Location**: `Infrastructure/Memory/RedisStackMemoryStore.cs:240-257`
**Category**: Reliability
**Risk**: `EnsureIndexCreatedAsync` uses a plain boolean `_indexInitialized` without any locking. Under concurrent requests, multiple threads can simultaneously attempt to check and create the index. This can result in duplicate index creation attempts or one thread reading `_indexInitialized = true` before the index is actually ready.

**Evidence**:
```csharp
// RedisStackMemoryStore.cs:21
private bool _indexInitialized;

// RedisStackMemoryStore.cs:240-257
private async Task EnsureIndexCreatedAsync()
{
    if (_indexInitialized) { return; }       // No lock, no volatile
    try
    {
        await _ft.InfoAsync(IndexName);
        _indexInitialized = true;            // Written without synchronization
    }
    catch (RedisServerException)
    {
        await CreateIndexAsync();
        _indexInitialized = true;
    }
}
```

**Guidance**:
- Do NOT assume `_indexInitialized` is thread-safe as-is
- If multiple agents start simultaneously and both store memories before the index exists, this can throw or create redundant indexes
- When modifying `RedisStackMemoryStore`: consider adding `SemaphoreSlim` or `Lazy<Task>` pattern for initialization
- Related files: `Infrastructure/Memory/OpenRouterEmbeddingService.cs`

**Mitigation**:
- Wrap `EnsureIndexCreatedAsync` in a `SemaphoreSlim` or use `Lazy<Task>` for one-time async initialization
- Alternatively, mark `_indexInitialized` as `volatile` (partial fix; still has TOCTOU window)

---

### BaseCliRunner Does Not Capture StandardError

**Location**: `Infrastructure/CommandRunners/BaseCliRunner.cs:10-27`
**Category**: Reliability
**Risk**: `BaseCliRunner.Run` only reads `StandardOutput`. If a command writes errors to stderr, they are silently discarded. The caller receives an empty or partial result with no indication of failure. The process exit code is also not checked.

**Evidence**:
```csharp
// BaseCliRunner.cs:10-27
protected static async Task<string> Run(string fileName, string args, CancellationToken ct)
{
    var process = new Process
    {
        StartInfo = new ProcessStartInfo
        {
            FileName = fileName,
            Arguments = args,
            RedirectStandardOutput = true,  // Only stdout
            UseShellExecute = false,
            CreateNoWindow = true
            // RedirectStandardError is NOT set
        }
    };
    process.Start();
    var result = await process.StandardOutput.ReadToEndAsync(ct);
    await process.WaitForExitAsync(ct);
    return result;  // Exit code not checked
}
```

**Guidance**:
- Do NOT rely on the return value to determine success; a non-zero exit code will still return whatever stdout was captured
- If you modify command runners: add `RedirectStandardError = true`, read both streams, and check `process.ExitCode`
- Related files: `Infrastructure/CommandRunners/ShRunner.cs`, `Infrastructure/CommandRunners/PowerShellRunner.cs`, `Infrastructure/CommandRunners/CommandRunnerFactory.cs`

**Mitigation**:
- Add stderr capture and exit code checking
- Return a structured result (stdout, stderr, exit code) instead of a plain string

---

## MEDIUM Risk Areas

### Space Isolation is Presentation-Only, Not Enforced Server-Side

**Location**: `Agent/Hubs/ChatHub.cs:89-113`, `Infrastructure/Clients/Messaging/WebChat/HubNotifier.cs:44-55`
**Category**: Security
**Risk**: The new Spaces feature provides topic isolation through SignalR groups, but the server does not enforce space membership or access control. Any client can call `JoinSpace("secret-room")` to join any space and receive all notifications for that space. Topics are filtered by `SpaceSlug` in `GetAllTopics`, but since `JoinSpace` accepts any valid slug, a client can enumerate and access all spaces. The only validation is the slug format regex (lowercase alphanumeric with hyphens).

**Evidence**:
```csharp
// ChatHub.cs:89-97
public async Task JoinSpace(string spaceSlug)
{
    if (!SpaceConfig.IsValidSlug(spaceSlug))
    {
        throw new HubException("Invalid space slug");
    }

    await SwitchSpaceGroupAsync(spaceSlug);  // No authorization check
}

// HubNotifier.cs:44-55 - Fallback broadcasts to ALL when SpaceSlug is null
private async Task SendToSpaceOrAllAsync(
    string? spaceSlug, string methodName, object notification, CancellationToken cancellationToken)
{
    if (spaceSlug is not null)
    {
        await sender.SendToGroupAsync($"space:{spaceSlug}", methodName, notification, cancellationToken);
    }
    else
    {
        await sender.SendAsync(methodName, notification, cancellationToken);  // Broadcast to ALL
    }
}
```

**Guidance**:
- Do NOT rely on Spaces for access control or privacy; any connected client can join any space
- If Spaces are meant to provide topic segregation for different users/purposes: add an authorization check in `JoinSpace` that verifies the user has permission to access the requested space
- The `SendToSpaceOrAllAsync` fallback to broadcast-to-all means notifications for topics without a SpaceSlug reach ALL connected clients regardless of their current space
- Related files: `Domain/DTOs/WebChat/SpaceConfig.cs`, `WebChat.Client/State/Space/SpaceStore.cs`, `WebChat.Client/State/Effects/SpaceEffect.cs`

**Mitigation**:
- Add a server-side space membership check in `JoinSpace`
- Ensure all notifications always include a SpaceSlug to avoid the broadcast fallback
- Consider storing space membership in Redis and validating against it

---

### DdnsIpAllowlistMiddleware Swallows All DNS Errors

**Location**: `Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs:31-39`
**Category**: Security
**Risk**: The `IsIpAllowedAsync` method catches all exceptions and returns `false`. If DNS resolution fails (network issue, DNS outage), ALL requests are denied including legitimate ones. No logging means operators cannot diagnose why requests are being rejected.

**Evidence**:
```csharp
// DdnsIpAllowlistMiddleware.cs:31-39
private async Task<bool> IsIpAllowedAsync(string clientIp)
{
    try { ... }
    catch
    {
        return false;  // No logging, no differentiation between DNS failure and invalid IP
    }
}
```

**Guidance**:
- If you experience unexplained 403 errors: check DNS resolution for the DDNS hostname first
- When modifying this middleware: add logging for DNS resolution failures
- The middleware resolves DNS on every request with no caching, which adds latency and is susceptible to DNS throttling

**Mitigation**:
- Add logging in the catch block
- Cache DNS results for a configurable TTL (e.g., 5 minutes) to reduce per-request DNS lookups
- Differentiate between "DNS failed" (allow with warning or deny with log) and "IP not in list" (deny silently)

---

### BroadcastChannel Unbounded Subscriber Growth

**Location**: `Infrastructure/Clients/Messaging/WebChat/BroadcastChannel.cs:1-44`
**Category**: Reliability / Performance
**Risk**: `BroadcastChannel.Subscribe()` creates unbounded channels and adds them to a list. Subscribers are never removed (only cleared on `Complete()`). If a client disconnects without the stream completing, its channel remains in the list, and every `WriteAsync` call sends data to dead channels, wasting memory and CPU.

**Evidence**:
```csharp
// BroadcastChannel.cs:10-18
public ChannelReader<T> Subscribe()
{
    var channel = Channel.CreateUnbounded<T>();
    lock (_lock)
    {
        _subscribers.Add(channel);  // Never removed until Complete()
    }
    return channel.Reader;
}
```

**Guidance**:
- Do NOT assume subscriber count is bounded; in a scenario with many browser reconnections, this list grows unbounded
- When modifying `BroadcastChannel`: add a mechanism to detect and remove stale subscribers
- Related files: `Infrastructure/Clients/Messaging/WebChat/WebChatStreamManager.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs`

**Mitigation**:
- Track subscriber liveness (e.g., detect when `WriteAsync` fails for a subscriber and remove it)
- Add an `Unsubscribe` method or use `WeakReference` for subscriber tracking

---

### Browser Session Leak - No Automatic Cleanup

**Location**: `Infrastructure/Clients/Browser/BrowserSessionManager.cs:1-103`
**Category**: Performance / Reliability
**Risk**: Browser sessions (Playwright pages) are created on demand but never automatically cleaned up based on age or inactivity. The `LastAccessedAt` field is tracked but never used for eviction. Long-running agents accumulate open browser tabs that consume memory.

**Evidence**:
```csharp
// BrowserSessionManager.cs:18-19
_sessions[sessionId] = existing with { LastAccessedAt = DateTimeOffset.UtcNow };
return existing;
// LastAccessedAt is set but there is no background cleanup using it
```

**Guidance**:
- Do NOT rely on `DisposeAsync` being called promptly; browser sessions accumulate until the process shuts down
- If modifying browser infrastructure: add a periodic cleanup task that closes sessions idle beyond a threshold
- Related files: `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs`

**Mitigation**:
- Add a background timer that closes sessions older than a configurable TTL (e.g., 30 minutes)
- Limit the maximum number of concurrent sessions

---

### PlaywrightWebBrowser is a God Class (946 Lines)

**Location**: `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:1-946`
**Category**: Maintainability
**Risk**: This single class handles navigation, CAPTCHA solving, modal dismissal, stealth scripting, element clicking, content extraction, session management, DOM stability waiting, and more. It has 900+ lines including a ~180-line JavaScript stealth script embedded as a string constant. Any change risks unintended side effects.

**Evidence**:
```csharp
// PlaywrightWebBrowser.cs - 946 lines total
// - Lines 28-181: StealthScript constant (JavaScript)
// - Lines 183-347: NavigateAsync with CAPTCHA/timeout/modal handling
// - Lines 350-478: ClickAsync with multiple timeout/error catch blocks
// - Lines 480-620: InspectAsync, ScrollAsync, etc.
```

**Guidance**:
- Do NOT add new methods to this class; it already violates SRP significantly
- When modifying navigation or clicking: trace ALL catch blocks carefully; there are 10+ catch clauses with different behaviors
- The stealth script (lines 28-181) must stay synchronized with Chrome version constants (line 23: `ChromeMajorVersion = "145"` and line 148: brand version `'145'`)
- Related files: `Infrastructure/Clients/Browser/BrowserSessionManager.cs`, `Infrastructure/Clients/Browser/ModalDismisser.cs`, `Infrastructure/Clients/Browser/CapSolverClient.cs`

**Mitigation**:
- Extract stealth scripting into its own class
- Extract navigation, clicking, and inspection into separate strategy classes
- Extract CAPTCHA handling into a dedicated middleware/handler

---

### RedisThreadStateStore.GetTopicByChatIdAndThreadIdAsync is N+1

**Location**: `Infrastructure/StateManagers/RedisThreadStateStore.cs:77-82`
**Category**: Performance
**Risk**: `GetTopicByChatIdAndThreadIdAsync` calls `GetAllTopicsAsync(agentId)` which performs a SCAN over all topic keys, fetches every topic's JSON via individual `StringGetAsync` calls (N+1 pattern), deserializes them all, and then filters client-side with `.FirstOrDefault()`. For agents with many topics, this is extremely wasteful -- a lookup for one topic fetches and deserializes ALL topics.

**Evidence**:
```csharp
// RedisThreadStateStore.cs:77-82
public async Task<TopicMetadata?> GetTopicByChatIdAndThreadIdAsync(
    string agentId, long chatId, long threadId, CancellationToken ct = default)
{
    var topics = await GetAllTopicsAsync(agentId);  // Fetches ALL topics for this agent
    return topics.FirstOrDefault(t => t.ChatId == chatId && t.ThreadId == threadId);
}

// GetAllTopicsAsync performs SCAN + individual StringGetAsync for each key
await foreach (var key in _server.KeysAsync(pattern: $"topic:{agentId}:*"))
{
    var json = await _db.StringGetAsync(key);  // One round-trip per topic
    // ...
}
```

**Guidance**:
- This method is called from `WebChatMessengerClient.CreateTopicIfNeededAsync` and `DoesThreadExist`, which are invoked on every inbound message -- making this a hot path
- Do NOT add more callers to `GetTopicByChatIdAndThreadIdAsync` without addressing the performance issue
- Related files: `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:157,184`

**Mitigation**:
- Add a direct Redis key lookup by constructing a key from `agentId`, `chatId`, and `threadId` (requires a secondary index or key-naming scheme change)
- Alternatively, maintain an in-memory cache of topic metadata with Redis pub/sub invalidation
- At minimum, use `MGET` batch operations instead of individual `StringGetAsync` calls in `GetAllTopicsAsync`

---

### WebChatMessengerClient.GenerateChatId Uses Timestamp

**Location**: `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:240-243`
**Category**: Reliability
**Risk**: `GenerateChatId` generates IDs using `DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()`. If two topics are created within the same millisecond, they will receive the same chatId, causing session collision and data corruption.

**Evidence**:
```csharp
// WebChatMessengerClient.cs:240-243
private static long GenerateChatId()
{
    return DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
}
```

**Guidance**:
- Do NOT create topics in rapid succession via the WebChat interface without awareness of this limitation
- When modifying ID generation: switch to `Interlocked.Increment` or combine timestamp with a counter
- Related files: `Infrastructure/Utils/TopicIdHasher.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatSessionManager.cs`

**Mitigation**:
- Use an atomic counter (`Interlocked.Increment`) or GUID-based ID generation

---

### Preview Packages in Production Dependencies

**Location**: `Infrastructure/Infrastructure.csproj:26-30`, `Domain/Domain.csproj:13`
**Category**: Reliability
**Risk**: Multiple preview packages are used in production code. Preview packages may have breaking changes, missing features, or bugs that are not yet resolved.

**Evidence**:
```xml
<!-- Infrastructure.csproj -->
<PackageReference Include="Microsoft.Agents.AI" Version="1.0.0-preview.260205.1" />
<PackageReference Include="Microsoft.Extensions.AI.OpenAI" Version="10.2.0-preview.1.26063.2"/>
<PackageReference Include="ModelContextProtocol" Version="0.8.0-preview.1" />

<!-- Domain.csproj -->
<PackageReference Include="Microsoft.Agents.AI.Abstractions" Version="1.0.0-preview.260205.1" />
```

**Guidance**:
- Do NOT upgrade these packages without checking release notes for breaking changes
- `Microsoft.Agents.AI` and `ModelContextProtocol` are both early preview; API surface may change significantly between versions
- Pin exact versions in a central package management file to avoid accidental upgrades

**Mitigation**:
- Track stable release dates for these packages
- Add integration tests that exercise the critical paths through these APIs to catch breaking changes early

---

### OpenRouterHttpHelpers Silent Error Swallowing

**Location**: `Infrastructure/Agents/ChatClients/OpenRouterHttpHelpers.cs:193-197`
**Category**: Reliability
**Risk**: The `ProcessBytes` method in `ReasoningTeeStream` catches and silently discards all exceptions. If the SSE stream contains malformed data, reasoning content is silently lost with no logging or error reporting.

**Evidence**:
```csharp
// OpenRouterHttpHelpers.cs:193-197
private void ProcessBytes(ReadOnlySpan<byte> bytes)
{
    try { ... }
    catch
    {
        // best-effort
    }
}
```

**Guidance**:
- If reasoning content is unexpectedly missing from agent responses: this is a likely culprit
- When modifying the reasoning extraction pipeline: add logging for parse failures at minimum
- Related files: `Infrastructure/Agents/ChatClients/OpenRouterChatClient.cs`

---

### HtmlInspector is a Large Static Class (1090 Lines)

**Location**: `Infrastructure/HtmlProcessing/HtmlInspector.cs:1-1090`
**Category**: Maintainability
**Risk**: At 1090 lines, this is the largest file in the codebase. It handles content detection, repeating element detection, navigation detection, outline building, structured data extraction, table parsing, and selector generation -- all as static methods. Difficult to test individual behaviors in isolation.

**Evidence**:
```
1090 lines with responsibilities spanning:
- Main content detection (DetectMainContent)
- Repeating element detection (DetectRepeatingElements)
- Navigation detection (DetectNavigation)
- Outline building (BuildOutline)
- Suggestion generation (GenerateSuggestions)
- Structured data extraction (ExtractStructuredData)
- CSS selector generation (GenerateSelector)
- Table parsing
- Text search
```

**Guidance**:
- When modifying HTML inspection logic: be aware that changes to selector generation or element scoring can affect all downstream features
- The class is `partial`, so look for additional files before concluding you have the full picture
- Related files: `Infrastructure/HtmlProcessing/HtmlConverter.cs`, `Tests/Unit/Infrastructure/HtmlInspectorTests.cs` (1012 lines)

**Mitigation**:
- Split into focused classes: `ContentDetector`, `RepeatingElementDetector`, `NavigationDetector`, `SelectorGenerator`, `StructuredDataExtractor`

---

## LOW Risk Areas

### TerminalGuiAdapter is Large (617 Lines)

**Location**: `Infrastructure/CliGui/Ui/TerminalGuiAdapter.cs`
**Category**: Maintainability
**Note**: At 617 lines, this is on the boundary. It manages the entire Terminal.Gui lifecycle including layout, input handling, scrolling, thinking indicators, and Ctrl+C handling. Consider extracting layout setup and input handling into separate classes if this continues to grow.

---

### ModalDismisser is Complex (374 Lines)

**Location**: `Infrastructure/Clients/Browser/ModalDismisser.cs`
**Category**: Maintainability
**Note**: Contains heuristic-based logic for dismissing cookie banners, popups, and overlays on arbitrary websites. Fragile by nature since it relies on pattern matching against class names, button text, and DOM structure. Changes here may fix one site while breaking another.

---

### Telegram Authorization is Username-Based

**Location**: `Infrastructure/Clients/Messaging/Telegram/TelegramChatClient.cs:285-288`
**Category**: Security
**Note**: Authorization checks use `allowedUserNames.Contains(prompt.Sender)` where `Sender` is the Telegram username. Telegram usernames can be changed by users. If a user changes their username, they lose access. If someone obtains a previously-allowed username, they gain access. Low risk for a personal bot, but worth noting.

---

### IdealistaClient Token Expiry Uses DateTime.UtcNow

**Location**: `Infrastructure/Clients/IdealistaClient.cs:15-16`
**Category**: Reliability
**Note**: Uses `DateTime.UtcNow` directly rather than `TimeProvider` for token expiry checks. Not testable without real time progression. Low risk since OAuth tokens have multi-minute lifetimes, but inconsistent with the codebase convention of using `TimeProvider` for testable time-dependent code.

---

### StreamBuffer RemoveOldestMessage Has O(n) Index Adjustment

**Location**: `Infrastructure/Clients/Messaging/WebChat/StreamBuffer.cs:76-94`
**Category**: Performance
**Note**: When the buffer exceeds `MaxBufferSize` (100), `RemoveOldestMessage` performs `RemoveAt(0)` on a `List<T>` (O(n) shift) and then iterates all tracked indices to decrement them. With `MaxBufferSize = 100` this is negligible, but the pattern would not scale.

---

## Technical Debt Inventory

### TODO/FIXME/HACK Comments

| File | Line | Comment |
|------|------|---------|
| `McpServerLibrary/ResourceSubscriptions/SubscriptionMonitor.cs` | 129 | `TODO: Check all downloads in a single call` |

### Large Files (>500 lines)

| File | Lines | Concern |
|------|-------|---------|
| `Infrastructure/HtmlProcessing/HtmlInspector.cs` | 1090 | God class - multiple responsibilities, consider splitting |
| `Tests/Unit/Infrastructure/HtmlInspectorTests.cs` | 1012 | Large test file mirrors large implementation |
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs` | 946 | God class - navigation/clicking/CAPTCHA/stealth all in one |
| `Tests/Unit/WebChat/Client/StreamingServiceTests.cs` | 899 | Large test file |
| `Tests/Integration/WebChat/ChatHubIntegrationTests.cs` | 713 | Large integration test, grew with space isolation tests |
| `Tests/Integration/Clients/PlaywrightWebBrowserIntegrationTests.cs` | 641 | Large integration test |
| `Infrastructure/CliGui/Ui/TerminalGuiAdapter.cs` | 617 | UI lifecycle management, consider extracting components |

### Complex Functions (high cyclomatic complexity)

| File | Function | Concern |
|------|----------|---------|
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:183` | `NavigateAsync` | ~120 lines, 6+ catch blocks, CAPTCHA retry loop, modal dismissal, selector waiting, scroll-to-load, stability checking |
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:350` | `ClickAsync` | ~130 lines, 5+ catch blocks with different timeout/error handling paths |
| `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:162` | `CreateTopicIfNeededAsync` | Complex branching on threadId/chatId nullability with session creation side effects and space slug propagation |
| `Infrastructure/HtmlProcessing/HtmlInspector.cs:46` | `DetectMainContent` | Scoring algorithm with multiple candidate sources and magic numbers |

---

## Fragile Patterns

### Chrome Version Synchronization

**Locations**:
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:23` (`ChromeMajorVersion = "145"`)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:26` (UserAgent string)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:148-150` (navigator.userAgentData brands)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:164` (uaFullVersion)

**Why it's fragile**: The Chrome version appears in four separate places: the constant, the UserAgent string, the brands array in the stealth script, and the uaFullVersion. If you update one but not the others, anti-bot detection systems will flag the mismatched fingerprint.

**When modifying**:
1. Update `ChromeMajorVersion` constant (line 23)
2. Verify `UserAgent` string uses the constant (line 26) -- it does via interpolation
3. Update brand versions in the stealth script `navigator.userAgentData` section (lines 148, 150, 164) -- these are hardcoded string literals, NOT referencing the constant
4. Test against a site with anti-bot protection (e.g., Cloudflare, DataDome)

---

### WebChat Stream Lifecycle Coordination

**Locations**:
- `Infrastructure/Clients/Messaging/WebChat/WebChatStreamManager.cs`
- `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:43-123`
- `Infrastructure/Clients/Messaging/WebChat/BroadcastChannel.cs`
- `Agent/Hubs/ChatHub.cs:125-163`

**Why it's fragile**: Stream lifecycle involves coordinating pending prompt counts, broadcast channels, cancellation tokens, stream buffers, and hub notifications across four files. The pending count must be incremented before the agent processes and decremented exactly once per completion. A missed increment or decrement causes either premature stream completion (cutting off responses) or never-completing streams (zombie streams).

**When modifying**:
1. Trace the full lifecycle: `GetOrCreateStream` -> `TryIncrementPending` -> `WriteMessageAsync` -> `DecrementPendingAndCheckIfShouldComplete` -> `CompleteStream`
2. Ensure every path that creates a stream eventually completes it (even error paths)
3. Test with multiple concurrent prompts to the same topic
4. Test browser reconnection during an active stream

---

### Tool Approval Whitelist Pattern Matching

**Locations**:
- `Infrastructure/Utils/ToolPatternMatcher.cs`
- `Infrastructure/Agents/ChatClients/ToolApprovalChatClient.cs:41`

**Why it's fragile**: The whitelist uses glob-to-regex conversion (`*` becomes `.*`). A pattern like `*` auto-approves ALL tools including dangerous ones (command execution, file deletion). The `_dynamicallyApproved` set grows during a session and is never cleared, meaning "approve and remember" is permanent for the session lifetime.

**When modifying**:
1. Review all configured whitelist patterns before deploying
2. Verify `_dynamicallyApproved` does not persist across sessions (it does not - it is per `ToolApprovalChatClient` instance)
3. Test that dangerous tools (command runners, file operations) are NOT matched by overly broad patterns

---

### Space-Scoped Notification Routing

**Locations**:
- `Infrastructure/Clients/Messaging/WebChat/HubNotifier.cs:44-55`
- `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:57-58,317-318`
- `Infrastructure/Clients/Messaging/WebChat/WebChatApprovalManager.cs:80,110`
- `Agent/Hubs/ChatHub.cs:224-225,237-238,246-247`
- `Domain/DTOs/WebChat/HubNotification.cs`

**Why it's fragile**: Every notification type (TopicChanged, StreamChanged, ApprovalResolved, ToolCalls, UserMessage) must include a `SpaceSlug` parameter for proper space-scoped routing. The `SpaceSlug` is resolved from the session's `WebChatSession.SpaceSlug` or from the topic metadata, but these can be null. When `SpaceSlug` is null, `HubNotifier.SendToSpaceOrAllAsync` falls back to broadcasting to ALL connected clients, breaking space isolation. Every new notification type or code path that creates notifications must remember to propagate the space slug.

**When modifying**:
1. Always resolve `SpaceSlug` from the session or topic metadata before sending notifications
2. Test that notifications for a topic in space "A" do not reach clients in space "B"
3. If adding new notification types to `HubNotification.cs`: include `SpaceSlug` as a parameter
4. Verify the `ChatHub` methods that trigger notifications (`CancelTopic`, `DeleteTopic`, `SaveTopic`) always pass `CurrentSpaceSlug` or the topic's SpaceSlug

---

### Effect Handler Registration Leaks

**Locations**:
- `WebChat.Client/State/Effects/SendMessageEffect.cs:49-50`
- `WebChat.Client/State/Effects/TopicSelectionEffect.cs:36`
- `WebChat.Client/State/Effects/InitializationEffect.cs:58-59`
- `WebChat.Client/State/Effects/TopicDeleteEffect.cs:34`
- `WebChat.Client/State/Effects/UserIdentityEffect.cs:25-26`

**Why it's fragile**: Most effects register handlers with `dispatcher.RegisterHandler<T>()` in their constructor but do NOT store the returned `IDisposable` and do NOT unregister handlers in their `Dispose()` method. Only `SpaceEffect` and `AgentSelectionEffect` properly dispose their handler registrations. If effects are ever re-created (e.g., due to a Blazor circuit restart or component re-initialization), handlers will accumulate and fire multiple times per dispatch.

**When modifying**:
1. Store the `IDisposable` returned by `RegisterHandler` in a field
2. Dispose it in the effect's `Dispose()` method
3. Verify that adding a new effect follows the same pattern as `SpaceEffect.cs` (which properly disposes `_handlerRegistration`)

---

## Missing Safeguards

### No Rate Limiting on ChatHub

**Where**: `Agent/Hubs/ChatHub.cs`
**What's missing**: No rate limiting on `SendMessage`, `EnqueueMessage`, or any other hub method. A malicious or buggy client can flood the agent with prompts.
**Risk**: Resource exhaustion -- each prompt triggers LLM API calls (which cost money) and spawns concurrent processing tasks.
**Recommendation**: Add per-user rate limiting via SignalR filters or a middleware.

### No Maximum Session Count for Browser Sessions

**Where**: `Infrastructure/Clients/Browser/BrowserSessionManager.cs`
**What's missing**: No limit on the number of concurrent browser sessions. Each session creates a new Playwright page.
**Risk**: Memory exhaustion if the agent is asked to browse many sites simultaneously.
**Recommendation**: Add a configurable maximum session count with eviction of least-recently-used sessions.

### No Input Size Validation on WebChat Messages

**Where**: `Agent/Hubs/ChatHub.cs:165-203`
**What's missing**: The `message` parameter in `SendMessage` has no length validation. Arbitrarily large messages are forwarded to the LLM.
**Risk**: Excessive token usage/cost and potential LLM context window overflow.
**Recommendation**: Add maximum message length validation in the hub method.

### No Space Configuration Validation on Server Startup

**Where**: `WebChat/Program.cs:63-73`, `WebChat/appsettings.json`
**What's missing**: Space configuration is read from `appsettings.json` at runtime when requested. There is no startup validation that configured spaces have valid slugs, valid hex colors, or unique slugs. A misconfigured space slug would silently fail.
**Risk**: Invalid space configuration causes runtime 404s or unexpected behavior.
**Recommendation**: Add startup validation that all configured spaces pass `SpaceConfig.IsValidSlug` and `SpaceConfig.IsValidHexColor`.

---

## Known Limitations

### SubscriptionMonitor Only Supports Download Resources

**Area**: `McpServerLibrary/ResourceSubscriptions/SubscriptionMonitor.cs:46-53`
**Limitation**: `GetResourceCheck` throws `NotImplementedException` for any URI scheme other than `download://`. Only download-based resource subscriptions are supported.
**Workaround**: N/A -- only download monitoring is implemented.
**Future fix**: Implement handlers for other resource types as they are added to MCP servers.

### Single Redis Server Endpoint Assumption

**Area**: `Infrastructure/Memory/RedisStackMemoryStore.cs:27`
**Limitation**: `_server = redis.GetServer(redis.GetEndPoints()[0])` always uses the first endpoint. In a Redis cluster or sentinel setup, this may not target the correct node for SCAN operations.
**Workaround**: Deploy with a single Redis endpoint.
**Future fix**: Use `IServer` selection logic that accounts for cluster topology, or avoid `KeysAsync` (SCAN) in favor of index-based queries.

### WebChatMessengerClient _messageIdCounter is In-Memory

**Area**: `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:26`
**Limitation**: `_messageIdCounter` resets to 0 on every application restart. Message IDs are not globally unique; they are only locally incrementing integers.
**Workaround**: The `MessageId` field on `ChatStreamMessage` is a string that may combine this counter with other identifiers.
**Future fix**: Use a persistent counter (Redis INCR) or GUID-based message IDs for durability across restarts.

### Spaces Are Not Persisted on WebChat Sessions

**Area**: `Infrastructure/Clients/Messaging/WebChat/WebChatSessionManager.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatSession.cs`
**Limitation**: `WebChatSession` stores `SpaceSlug` in-memory only. If the server restarts, all session-to-space associations are lost. Sessions recreated via `StartSession` from the client will have a null SpaceSlug unless the client re-joins the space first. This can cause notifications to broadcast to all clients instead of the correct space group.
**Workaround**: The client calls `JoinSpace` on reconnection, which re-establishes the SignalR group membership. However, notifications triggered server-side (e.g., from scheduled tasks or external message sources) before the client reconnects will lack space scoping.
**Future fix**: Persist session-to-space associations in Redis, or derive the space slug from the topic metadata (which is already persisted).
