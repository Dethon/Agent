# Technical Concerns

> Auto-generated by /codemap-creator. Prescriptive warnings about technical debt and risk areas.

## Risk Summary

| Severity | Count | Categories |
|----------|-------|------------|
| HIGH | 4 | Security, Reliability, Performance |
| MEDIUM | 7 | Maintainability, Reliability, Performance, Security |
| LOW | 5 | Maintainability, Code Quality |

---

## HIGH Risk Areas

### Command Injection via Shell Runner

**Location**: `Infrastructure/CommandRunners/ShRunner.cs:5-8`
**Category**: Security
**Risk**: Arbitrary command execution. User-controlled input passed directly to `sh -c` with string interpolation enables shell injection. A malicious or LLM-hallucinated command containing `;`, `&&`, `|`, or backtick subshells can execute arbitrary system commands.

**Evidence**:
```csharp
public override async Task<string> Run(string command, CancellationToken ct)
{
    return await Run("sh", $"-c \"cd {workingDirectory} && {command}\"", ct);
}
```

**Guidance**:
- Do NOT pass unsanitized strings to this runner. The `command` parameter is interpolated directly into a shell invocation.
- If you must modify this: add input validation or argument escaping; consider using `Process.StartInfo.ArgumentList` instead of a single argument string.
- Related files: `Infrastructure/CommandRunners/BaseCliRunner.cs`, `Infrastructure/CommandRunners/PowerShellRunner.cs`, `McpServerCommandRunner/McpTools/McpRunCommandTool.cs`

**Mitigation**:
- Implement an allowlist of permitted commands or a strict input sanitization layer
- Use `Process.StartInfo.ArgumentList` to avoid shell interpretation
- Ensure the MCP command runner tool has approval gates before execution (currently uses tool approval flow, verify this is always active)

---

### Missing Standard Error Capture in Process Execution

**Location**: `Infrastructure/CommandRunners/BaseCliRunner.cs:10-27`
**Category**: Reliability
**Risk**: Process failures are silent. Only stdout is captured; stderr is completely ignored. Commands that fail will return empty strings with no error indication. Additionally, the `Process` object is never disposed, causing handle leaks.

**Evidence**:
```csharp
protected static async Task<string> Run(string fileName, string args, CancellationToken ct)
{
    var process = new Process
    {
        StartInfo = new ProcessStartInfo
        {
            FileName = fileName,
            Arguments = args,
            RedirectStandardOutput = true,  // stderr not redirected
            UseShellExecute = false,
            CreateNoWindow = true
        }
    };
    process.Start();
    var result = await process.StandardOutput.ReadToEndAsync(ct);
    await process.WaitForExitAsync(ct);
    return result;  // No exit code check, no stderr
}
```

**Guidance**:
- Do NOT assume an empty return value means "no output." It may mean the command failed and all output went to stderr.
- If you must modify this: add `RedirectStandardError = true`, capture stderr, check `process.ExitCode`, and wrap `Process` in a `using` statement.
- Related files: `Infrastructure/CommandRunners/ShRunner.cs`, `Infrastructure/CommandRunners/PowerShellRunner.cs`

**Mitigation**:
- Add `RedirectStandardError = true` and merge or return stderr
- Check `process.ExitCode` and throw or return error info on non-zero
- Dispose the `Process` via `using`

---

### Static Mutable State in TelegramToolApprovalHandler

**Location**: `Infrastructure/Clients/ToolApproval/TelegramToolApprovalHandler.cs:24`
**Category**: Reliability
**Risk**: `_pendingApprovals` is a `static ConcurrentDictionary` shared across ALL instances of `TelegramToolApprovalHandler`. Since each approval handler is created per-request via `TelegramToolApprovalHandlerFactory.Create()`, this static field is the only thing linking the callback query handler to the original requester. If the process restarts or the dictionary grows unboundedly (e.g., timeouts fail to clean up), approvals are orphaned. There is also a subtle leak: `cancellationToken.Register()` (line 287) creates a callback registration that is never disposed if the token is not cancelled.

**Evidence**:
```csharp
private static readonly ConcurrentDictionary<string, ApprovalContext> _pendingApprovals = new();
// ...
public Task<ToolApprovalResult> WaitForApprovalAsync(CancellationToken cancellationToken)
{
    cancellationToken.Register(() => _tcs.TrySetCanceled(cancellationToken));
    return _tcs.Task;
}
```

**Guidance**:
- Do NOT rely on this surviving process restarts; pending approvals are lost on restart.
- If you must modify this: ensure the cancellation registration is stored and disposed in the `finally` block of `RequestApprovalAsync`. Consider a bounded or expiring cache instead of an unbounded dictionary.

**Mitigation**:
- Dispose the `CancellationTokenRegistration` returned by `.Register()`
- Add a periodic cleanup of stale entries as a safeguard
- Consider persisting pending approvals to Redis for cross-restart resilience

---

### IP Allowlist Middleware Performs DNS Lookup Per Request

**Location**: `Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs:29-40`
**Category**: Performance / Security
**Risk**: Every incoming HTTP request triggers a DNS resolution (`Dns.GetHostAddressesAsync`). Under load, this causes excessive DNS queries, increased latency, and potential rate-limiting by the DNS provider. If DNS resolution fails (network blip, DNS outage), ALL requests are rejected (the `catch` block returns `false`). This creates a denial-of-service condition where a transient DNS failure locks out all legitimate users.

**Evidence**:
```csharp
private async Task<bool> IsIpAllowedAsync(string clientIp)
{
    try
    {
        var allowedIps = await Dns.GetHostAddressesAsync(ddnsHostname);
        var clientIpParsed = IPAddress.Parse(clientIp);
        return allowedIps.Any(ip => ip.Equals(clientIpParsed));
    }
    catch
    {
        return false;  // DNS failure = deny all traffic
    }
}
```

**Guidance**:
- Do NOT add more endpoints behind this middleware without adding DNS caching first.
- If you must modify this: implement a time-based cache (30-60 seconds) for resolved IPs, and consider a fallback behavior when DNS fails (e.g., use last known good IPs).
- Related files: `Infrastructure/Extensions/DdnsIpAllowlistExtensions.cs`

**Mitigation**:
- Cache DNS results with a configurable TTL (e.g., `MemoryCache` with 60-second expiry)
- On DNS failure, fall back to previously cached IPs rather than denying all traffic
- Log DNS failures for monitoring

---

## MEDIUM Risk Areas

### WebChatStreamManager Has Six Parallel ConcurrentDictionaries

**Location**: `Infrastructure/Clients/Messaging/WebChat/WebChatStreamManager.cs:9-14`
**Category**: Maintainability / Reliability
**Risk**: Six `ConcurrentDictionary` fields are managed in parallel, keyed by `topicId`. The `GetOrCreateStream` method (lines 18-63) accesses these dictionaries without holding the `_streamLock`, creating a window where dictionaries can become inconsistent (e.g., a channel exists but its CTS does not). The `_streamLock` is only used in `CompleteStream`, `CancelStream`, `TryIncrementPending`, and `DecrementPendingAndCheckIfShouldComplete`, leaving a race between `GetOrCreateStream` and these locked methods.

**Evidence**:
```csharp
private readonly ConcurrentDictionary<string, BroadcastChannel<ChatStreamMessage>> _responseChannels = new();
private readonly ConcurrentDictionary<string, CancellationTokenSource> _cancellationTokens = new();
private readonly ConcurrentDictionary<string, StreamBuffer> _streamBuffers = new();
private readonly ConcurrentDictionary<string, string> _currentPrompts = new();
private readonly ConcurrentDictionary<string, string> _currentSenderIds = new();
private readonly ConcurrentDictionary<string, int> _pendingPromptCounts = new();
```

**Guidance**:
- When modifying stream lifecycle logic: trace ALL six dictionaries to ensure they are updated atomically.
- If adding new per-topic state: consider consolidating into a single `ConcurrentDictionary<string, StreamState>` to avoid multi-dictionary synchronization bugs.
- Related files: `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs`, `Infrastructure/Clients/Messaging/WebChat/StreamBuffer.cs`

---

### Fire-and-Forget Patterns in WebChatMessengerClient

**Location**: `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:370-377`
**Category**: Reliability
**Risk**: Multiple fire-and-forget operations (`_ = ...SafeAwaitAsync(...)`) in `EnqueuePrompt` mean that user messages could fail to be buffered or notifications could fail to be sent, with only a log warning as indication. If `WriteMessageAsync` fails, the user message is lost from the buffer and won't appear for other browsers joining the stream.

**Evidence**:
```csharp
// Fire and forget - don't block the enqueue
_ = streamManager.WriteMessageAsync(topicId, userMessage, CancellationToken.None)
    .SafeAwaitAsync(logger, "Failed to buffer user message for topic {TopicId}", topicId);

// Notify other browsers about the user message
_ = hubNotifier.NotifyUserMessageAsync(...)
    .SafeAwaitAsync(logger, "Failed to notify user message for topic {TopicId}", topicId);
```

**Guidance**:
- Do NOT add more fire-and-forget operations without considering the failure impact.
- If the buffer write fails, consider returning `false` from `EnqueuePrompt` or retrying.
- Related files: `Infrastructure/Extensions/TaskExtensions.cs`, `WebChat.Client/State/Effects/AgentSelectionEffect.cs`, `WebChat.Client/State/Effects/InitializationEffect.cs`

---

### ChatHub Lacks Authorization on Sensitive Operations

**Location**: `Agent/Hubs/ChatHub.cs:57-61, 228-239`
**Category**: Security
**Risk**: `StartSession`, `DeleteTopic`, `SaveTopic`, `CancelTopic`, `EnqueueMessage`, and `RespondToApprovalAsync` only check `IsRegistered` (i.e., that a user ID was set via `RegisterUser`). There is no verification that the calling user owns or has access to the topic they are operating on. Any registered user can delete, modify, or cancel any other user's topic by knowing (or guessing) the topicId. The `RegisterUser` method itself accepts any string as a userId with no authentication.

**Evidence**:
```csharp
public Task RegisterUser(string userId)
{
    if (string.IsNullOrWhiteSpace(userId))
    {
        throw new HubException("User ID cannot be empty");
    }
    Context.Items["UserId"] = userId;
    return Task.CompletedTask;
}
// ...
public async Task DeleteTopic(string agentId, string topicId, long chatId, long threadId)
{
    messengerClient.EndSession(topicId);
    // No ownership check
    await threadStateStore.DeleteAsync(agentKey);
    // ...
}
```

**Guidance**:
- Do NOT expose this hub to untrusted networks without adding authentication and authorization.
- If this is intended for trusted internal use only: document this assumption prominently and ensure the DDNS IP allowlist middleware is applied.
- If you must add multi-user support: add topic ownership validation before mutations.

---

### Stealth Script and User-Agent Require Manual Version Bumps

**Location**: `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:23-181`
**Category**: Maintainability
**Risk**: The Chrome version (`145`), user agent string, stealth script brand arrays, and `userAgentData` values are all hardcoded. When the bundled Chromium in Playwright updates, these values become stale and may trigger bot detection. The version appears in at least 4 separate places within the stealth script, making it easy to miss one during updates.

**Evidence**:
```csharp
private const string ChromeMajorVersion = "145";
// ...in StealthScript:
{ brand: 'Google Chrome', version: '145' },
{ brand: 'Chromium', version: '145' }
// ...
values.uaFullVersion = '145.0.0.0';
```

**Guidance**:
- When updating Playwright: also update `ChromeMajorVersion` and verify ALL occurrences in `StealthScript` match.
- Consider extracting the version into a single constant and using string interpolation throughout the stealth script.
- Related files: `Infrastructure/Infrastructure.csproj` (Playwright version)

---

### SubscriptionMonitor N+1 Download Queries

**Location**: `McpServerLibrary/ResourceSubscriptions/SubscriptionMonitor.cs:129-135`
**Category**: Performance
**Risk**: `MonitorAllDownloads` issues one HTTP call per tracked download ID via `downloadClient.GetDownloadItem()`. With many active downloads, this creates an N+1 query pattern on every 5-second polling cycle. The TODO comment acknowledges this issue.

**Evidence**:
```csharp
//TODO: Check all downloads in a single call
var downloadTasks = downloadIds
    .Select(async x => (
        DownloadId: x,
        DownloadItem: await downloadClient.GetDownloadItem(x, cancellationToken)
    ));
var downloads = await Task.WhenAll(downloadTasks);
```

**Guidance**:
- If you add more download features: prioritize implementing a batch download status API.
- The `Task.WhenAll` parallelizes the calls but still generates N requests per poll cycle.

---

### OpenRouterChatClient Reasoning Queue Is Instance-Scoped but Accessed Across Threads

**Location**: `Infrastructure/Agents/ChatClients/OpenRouterChatClient.cs:18, 88-111`
**Category**: Reliability
**Risk**: The `_reasoningQueue` is a `ConcurrentQueue<string>` used to pass reasoning content from the HTTP handler (which intercepts SSE streams on the HTTP thread) to `AppendReasoningContent` (called during async enumeration of streaming responses). If two concurrent streaming calls share the same `OpenRouterChatClient` instance, reasoning chunks from one call could leak into the other call's response. The `DrainReasoningQueue` method empties the entire queue indiscriminately.

**Evidence**:
```csharp
private readonly ConcurrentQueue<string> _reasoningQueue = new();
// ...
private string DrainReasoningQueue()
{
    if (_reasoningQueue.IsEmpty) return string.Empty;
    var sb = new StringBuilder();
    while (_reasoningQueue.TryDequeue(out var chunk))
    {
        sb.Append(chunk);
    }
    return sb.ToString();
}
```

**Guidance**:
- Do NOT use the same `OpenRouterChatClient` instance for concurrent conversations. If the client is registered as a singleton or shared, reasoning will cross-contaminate.
- If you must support concurrent calls: key the reasoning queue per request/correlation ID.

---

### Preview Packages in Production Dependencies

**Location**: `Infrastructure/Infrastructure.csproj:26,28,30`
**Category**: Reliability
**Risk**: Three packages are preview/pre-release versions. These may have breaking API changes, bugs, or missing features. Upgrading to stable releases may require code changes.

**Evidence**:
```xml
<PackageReference Include="Microsoft.Agents.AI" Version="1.0.0-preview.260205.1" />
<PackageReference Include="Microsoft.Extensions.AI.OpenAI" Version="10.2.0-preview.1.26063.2"/>
<PackageReference Include="ModelContextProtocol" Version="0.8.0-preview.1" />
```

**Guidance**:
- Track release milestones for these packages and plan migration when stable versions ship.
- Pin exact versions and test thoroughly before upgrading.
- `Microsoft.Agents.AI` is particularly risky as a `1.0.0-preview`; its API surface may change significantly.

---

## LOW Risk Areas

### PlaywrightWebBrowser Is the Largest Source File (946 lines)

**Location**: `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs`
**Category**: Maintainability
**Note**: At 946 lines, this file combines navigation, clicking, inspection, CAPTCHA solving, session management, stealth scripting, and DOM stability checking. The 181-line `StealthScript` constant alone accounts for ~19% of the file. Consider extracting the stealth script into a resource file and splitting navigation/click/inspect into separate strategy classes.

---

### HtmlInspector Is 1090 Lines of Static Methods

**Location**: `Infrastructure/HtmlProcessing/HtmlInspector.cs`
**Category**: Maintainability
**Note**: All methods are static, making it a utility class rather than a cohesive object. The file handles structure detection, search, form extraction, button extraction, link extraction, table extraction, selector generation, and structured data parsing. While each method is reasonably sized, the file as a whole is difficult to navigate.

---

### TerminalGuiAdapter Uses Background Thread with Thread.Sleep

**Location**: `Infrastructure/CliGui/Ui/TerminalGuiAdapter.cs:54-56`
**Category**: Maintainability
**Note**: `new Thread(RunTerminalGui) { IsBackground = true }.Start()` followed by `Thread.Sleep(500)` is a brittle initialization pattern. The 500ms sleep is a timing assumption that the Terminal.Gui framework has initialized. A `TaskCompletionSource` or `ManualResetEventSlim` would be more reliable.

---

### StreamBuffer Uses List.RemoveAt(0) for Eviction

**Location**: `Infrastructure/Clients/Messaging/WebChat/StreamBuffer.cs:78-95`
**Category**: Performance
**Note**: `RemoveOldestMessage()` calls `_messages.RemoveAt(0)` which is O(n) for a `List<T>`. It then iterates all `_messageIndexByMessageId` keys to decrement indices. With `MaxBufferSize = 100` this is acceptable, but if the buffer size increases significantly, consider using a `LinkedList` or circular buffer.

---

### Bare `catch` Blocks in HtmlInspector Navigation Detection

**Location**: `Infrastructure/HtmlProcessing/HtmlInspector.cs:248-251, 266-269`
**Category**: Code Quality
**Note**: Empty `catch` blocks swallow all exceptions during selector queries. While the comment says "Some patterns may not be supported," this hides genuine bugs. Consider catching only the specific exception types that AngleSharp throws for unsupported selectors.

---

## Technical Debt Inventory

### TODO/FIXME/HACK Comments

| File | Line | Comment |
|------|------|---------|
| `McpServerLibrary/ResourceSubscriptions/SubscriptionMonitor.cs` | 129 | `//TODO: Check all downloads in a single call` |

### Large Files (>500 lines)

| File | Lines | Concern |
|------|-------|---------|
| `Infrastructure/HtmlProcessing/HtmlInspector.cs` | 1090 | Static utility god-class; handles 8+ distinct responsibilities |
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs` | 946 | Navigation, clicking, inspection, CAPTCHA, stealth - too many concerns |
| `Tests/Unit/Infrastructure/HtmlInspectorTests.cs` | 1012 | Large test file, acceptable for test coverage |
| `Tests/Unit/WebChat/Client/StreamingServiceTests.cs` | 899 | Large test file, acceptable for test coverage |
| `Tests/Integration/WebChat/ChatHubIntegrationTests.cs` | 713 | Large integration test file |
| `Tests/Integration/Clients/PlaywrightWebBrowserIntegrationTests.cs` | 641 | Large integration test file |
| `Infrastructure/CliGui/Ui/TerminalGuiAdapter.cs` | 617 | UI adapter with mixed layout, event wiring, and input handling |

### Complex Functions

| File | Function | Concern |
|------|----------|---------|
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:183` | `NavigateAsync` | ~165 lines, multiple try/catch layers, CAPTCHA retry loop, modal dismissal, stability check |
| `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:162` | `CreateTopicIfNeededAsync` | ~76 lines, multiple branches for existing/new topics with side effects |
| `Infrastructure/HtmlProcessing/HtmlInspector.cs:103` | `DetectRepeatingElements` | Iterates all elements, groups by class, validates level - could be split |
| `Domain/Monitor/ChatMonitor.cs:46` | `ProcessChatThread` | Deeply nested LINQ pipeline with async lambdas and streaming merge |

---

## Fragile Patterns

### Chrome Version Synchronization

**Locations**:
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:23` (`ChromeMajorVersion`)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:148-149` (brands in StealthScript)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:164` (uaFullVersion in StealthScript)
- `Infrastructure/Infrastructure.csproj:34` (Playwright package version)

**Why it's fragile**: The Playwright package bundles a specific Chromium version. The stealth script spoofs a Chrome version number in multiple places. If these drift apart, anti-bot detection increases dramatically.

**When modifying**:
1. Update `Microsoft.Playwright` package version
2. Update `ChromeMajorVersion` constant
3. Search the entire `StealthScript` for the old version number
4. Verify by running integration tests against a bot-detection service

### Six-Dictionary Stream State in WebChatStreamManager

**Locations**:
- `Infrastructure/Clients/Messaging/WebChat/WebChatStreamManager.cs:9-14`
- `Infrastructure/Clients/Messaging/WebChat/WebChatStreamManager.cs:173-183` (cleanup)

**Why it's fragile**: Adding or removing per-stream state requires updating six dictionaries and the `CleanupStreamState` method. Missing one dictionary causes state leaks or null reference errors.

**When modifying**:
1. Check all six dictionaries in `GetOrCreateStream`, `CompleteStream`, `CancelStream`, and `CleanupStreamState`
2. Ensure any new state is also cleaned up in `Dispose`
3. Verify the `_streamLock` is held for operations that must be atomic

---

## Missing Safeguards

### No Rate Limiting on ChatHub SignalR Methods

**Where**: `Agent/Hubs/ChatHub.cs`
**What's missing**: No rate limiting on `SendMessage`, `EnqueueMessage`, or any hub methods.
**Risk**: A misbehaving or malicious client can flood the system with messages, triggering expensive LLM calls with no throttle.
**Recommendation**: Add per-connection rate limiting via a custom `IHubFilter` or middleware.

### No Input Length Validation on Chat Messages

**Where**: `Agent/Hubs/ChatHub.cs:165-203`, `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:288-349`
**What's missing**: The `message` parameter in `SendMessage` and `EnqueuePromptAndGetResponses` has no maximum length check.
**Risk**: Extremely long messages are forwarded to the LLM, potentially exceeding token limits and incurring high costs.
**Recommendation**: Add a maximum message length constant and reject messages that exceed it.

### No Process Timeout in BaseCliRunner

**Where**: `Infrastructure/CommandRunners/BaseCliRunner.cs:10-27`
**What's missing**: No timeout on the spawned process. If a command hangs, the thread blocks indefinitely.
**Risk**: Hung processes consume resources and block the caller.
**Recommendation**: Use `process.WaitForExitAsync()` with a `CancellationTokenSource` that has a timeout, and kill the process on timeout.

---

## Known Limitations

### MCP SDK Is Pre-Release (0.8.0-preview.1)

**Area**: `Infrastructure/Agents/Mcp/`, all `McpServer*` projects
**Limitation**: The ModelContextProtocol package is at version 0.8.0-preview.1. The API surface is not stable and may change with each release.
**Workaround**: Pin the exact version and test before upgrading.
**Future fix**: Migrate to stable 1.0 release when available.

### Idealista Token Cache Is In-Memory Only

**Area**: `Infrastructure/Clients/IdealistaClient.cs:14-15`
**Limitation**: OAuth tokens are cached in instance fields (`_accessToken`, `_tokenExpiry`). In a multi-instance deployment, each instance refreshes tokens independently, potentially hitting rate limits.
**Workaround**: Currently single-instance deployment.
**Future fix**: Store tokens in Redis with shared expiry.

### WebChat Has No Persistent Session Recovery Across Restarts

**Area**: `Infrastructure/Clients/Messaging/WebChat/WebChatSessionManager.cs`, `WebChatStreamManager.cs`
**Limitation**: All active sessions and streaming state are in-memory `ConcurrentDictionary` instances. A process restart loses all active chat sessions and streaming state.
**Workaround**: Topics and message history are persisted in Redis; only active stream state is lost.
**Future fix**: Persist active stream metadata to Redis and implement session recovery on startup.
