# Technical Concerns

> Auto-generated by /codemap-creator. Prescriptive warnings about technical debt and risk areas.

## Risk Summary

| Severity | Count | Categories |
|----------|-------|------------|
| HIGH | 4 | Security, Reliability |
| MEDIUM | 8 | Security, Maintainability, Performance, Reliability |
| LOW | 5 | Maintainability, Performance |

---

## HIGH Risk Areas

### Command Injection in Shell Runners

**Location**: `Infrastructure/CommandRunners/ShRunner.cs:7`, `Infrastructure/CommandRunners/PowerShellRunner.cs:7`
**Category**: Security
**Risk**: Arbitrary command injection. The `command` parameter is interpolated directly into a shell invocation string with no sanitization or escaping. An attacker-controlled LLM tool call could execute arbitrary system commands.

**Evidence**:
```csharp
// ShRunner.cs:7
return await Run("sh", $"-c \"cd {workingDirectory} && {command}\"", ct);

// PowerShellRunner.cs:7
return await Run("pwsh", $"-WorkingDirectory \"{workingDirectory}\" -Command \"{command}\"", ct);
```

**Guidance**:
- Do NOT pass user/LLM-generated strings to these runners without strict validation
- The tool approval system (`ToolApprovalChatClient`) is the ONLY safeguard; if a command runner tool is whitelisted or auto-approved, any command can be executed
- If you must modify these runners: add input validation, command allowlisting, or sandboxing
- Related files: `Infrastructure/CommandRunners/BaseCliRunner.cs`, `Infrastructure/Clients/ToolApproval/AutoToolApprovalHandler.cs`

**Mitigation**:
- Consider running commands in a restricted container or namespace
- Add command allowlisting at the runner level, not just at the approval layer
- `BaseCliRunner.cs:22` does not capture `StandardError`; errors from shell commands are silently lost

---

### ChatHub Has No Authentication or Authorization

**Location**: `Agent/Hubs/ChatHub.cs:15-235`
**Category**: Security
**Risk**: The SignalR ChatHub exposes all operations (send messages, delete topics, manage sessions, respond to tool approvals) with no `[Authorize]` attribute. The only guard is `RegisterUser` which accepts any arbitrary string as a userId with no verification. Any client that can connect to the hub can impersonate any user, read any agent's history, delete any topic, and approve tool executions.

**Evidence**:
```csharp
// ChatHub.cs:15 - No [Authorize] attribute
public sealed class ChatHub(...) : Hub
{
    // ChatHub.cs:32 - Self-registration with no validation
    public Task RegisterUser(string userId)
    {
        Context.Items["UserId"] = userId;
        return Task.CompletedTask;
    }

    // ChatHub.cs:199 - Any user can delete any topic
    public async Task DeleteTopic(string agentId, string topicId, long chatId, long threadId) { ... }

    // ChatHub.cs:221 - Any user can approve tool executions
    public Task<bool> RespondToApprovalAsync(string approvalId, ToolApprovalResult result) { ... }
}
```

**Guidance**:
- Do NOT deploy the WebChat interface on a public network without adding authentication
- The DDNS IP allowlist middleware (`Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs`) provides network-level restriction but is not applied to SignalR connections by default
- If you must expose WebChat externally: add authentication, authorize users per-topic, and validate userId against an identity provider
- Related files: `Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs`

**Mitigation**:
- Add `[Authorize]` to the Hub class
- Replace `RegisterUser` with claims-based identity from an authentication middleware
- Add per-topic authorization checks (users should only access their own topics)

---

### Redis Index Initialization Race Condition

**Location**: `Infrastructure/Memory/RedisStackMemoryStore.cs:240-257`
**Category**: Reliability
**Risk**: `EnsureIndexCreatedAsync` uses a plain boolean `_indexInitialized` without any locking. Under concurrent requests, multiple threads can simultaneously attempt to check and create the index. This can result in duplicate index creation attempts or one thread reading `_indexInitialized = true` before the index is actually ready.

**Evidence**:
```csharp
// RedisStackMemoryStore.cs:21
private bool _indexInitialized;

// RedisStackMemoryStore.cs:240-257
private async Task EnsureIndexCreatedAsync()
{
    if (_indexInitialized) { return; }       // No lock, no volatile
    try
    {
        await _ft.InfoAsync(IndexName);
        _indexInitialized = true;            // Written without synchronization
    }
    catch (RedisServerException)
    {
        await CreateIndexAsync();
        _indexInitialized = true;
    }
}
```

**Guidance**:
- Do NOT assume `_indexInitialized` is thread-safe as-is
- If multiple agents start simultaneously and both store memories before the index exists, this can throw or create redundant indexes
- When modifying `RedisStackMemoryStore`: consider adding `SemaphoreSlim` or `Lazy<Task>` pattern for initialization
- Related files: `Infrastructure/Memory/OpenRouterEmbeddingService.cs`

**Mitigation**:
- Wrap `EnsureIndexCreatedAsync` in a `SemaphoreSlim` or use `Lazy<Task>` for one-time async initialization
- Alternatively, mark `_indexInitialized` as `volatile` (partial fix; still has TOCTOU window)

---

### BaseCliRunner Does Not Capture StandardError

**Location**: `Infrastructure/CommandRunners/BaseCliRunner.cs:10-27`
**Category**: Reliability
**Risk**: `BaseCliRunner.Run` only reads `StandardOutput`. If a command writes errors to stderr, they are silently discarded. The caller receives an empty or partial result with no indication of failure. The process exit code is also not checked.

**Evidence**:
```csharp
// BaseCliRunner.cs:10-27
protected static async Task<string> Run(string fileName, string args, CancellationToken ct)
{
    var process = new Process
    {
        StartInfo = new ProcessStartInfo
        {
            FileName = fileName,
            Arguments = args,
            RedirectStandardOutput = true,  // Only stdout
            UseShellExecute = false,
            CreateNoWindow = true
            // RedirectStandardError is NOT set
        }
    };
    process.Start();
    var result = await process.StandardOutput.ReadToEndAsync(ct);
    await process.WaitForExitAsync(ct);
    return result;  // Exit code not checked
}
```

**Guidance**:
- Do NOT rely on the return value to determine success; a non-zero exit code will still return whatever stdout was captured
- If you modify command runners: add `RedirectStandardError = true`, read both streams, and check `process.ExitCode`
- Related files: `Infrastructure/CommandRunners/ShRunner.cs`, `Infrastructure/CommandRunners/PowerShellRunner.cs`, `Infrastructure/CommandRunners/CommandRunnerFactory.cs`

**Mitigation**:
- Add stderr capture and exit code checking
- Return a structured result (stdout, stderr, exit code) instead of a plain string

---

## MEDIUM Risk Areas

### DdnsIpAllowlistMiddleware Swallows All DNS Errors

**Location**: `Infrastructure/Middleware/DdnsIpAllowlistMiddleware.cs:31-39`
**Category**: Security
**Risk**: The `IsIpAllowedAsync` method catches all exceptions and returns `false`. If DNS resolution fails (network issue, DNS outage), ALL requests are denied including legitimate ones. No logging means operators cannot diagnose why requests are being rejected.

**Evidence**:
```csharp
// DdnsIpAllowlistMiddleware.cs:31-39
private async Task<bool> IsIpAllowedAsync(string clientIp)
{
    try { ... }
    catch
    {
        return false;  // No logging, no differentiation between DNS failure and invalid IP
    }
}
```

**Guidance**:
- If you experience unexplained 403 errors: check DNS resolution for the DDNS hostname first
- When modifying this middleware: add logging for DNS resolution failures
- The middleware resolves DNS on every request with no caching, which adds latency and is susceptible to DNS throttling

**Mitigation**:
- Add logging in the catch block
- Cache DNS results for a configurable TTL (e.g., 5 minutes) to reduce per-request DNS lookups
- Differentiate between "DNS failed" (allow with warning or deny with log) and "IP not in list" (deny silently)

---

### BroadcastChannel Unbounded Subscriber Growth

**Location**: `Infrastructure/Clients/Messaging/WebChat/BroadcastChannel.cs:1-44`
**Category**: Reliability / Performance
**Risk**: `BroadcastChannel.Subscribe()` creates unbounded channels and adds them to a list. Subscribers are never removed (only cleared on `Complete()`). If a client disconnects without the stream completing, its channel remains in the list, and every `WriteAsync` call sends data to dead channels, wasting memory and CPU.

**Evidence**:
```csharp
// BroadcastChannel.cs:10-18
public ChannelReader<T> Subscribe()
{
    var channel = Channel.CreateUnbounded<T>();
    lock (_lock)
    {
        _subscribers.Add(channel);  // Never removed until Complete()
    }
    return channel.Reader;
}
```

**Guidance**:
- Do NOT assume subscriber count is bounded; in a scenario with many browser reconnections, this list grows unbounded
- When modifying `BroadcastChannel`: add a mechanism to detect and remove stale subscribers
- Related files: `Infrastructure/Clients/Messaging/WebChat/WebChatStreamManager.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs`

**Mitigation**:
- Track subscriber liveness (e.g., detect when `WriteAsync` fails for a subscriber and remove it)
- Add an `Unsubscribe` method or use `WeakReference` for subscriber tracking

---

### Browser Session Leak - No Automatic Cleanup

**Location**: `Infrastructure/Clients/Browser/BrowserSessionManager.cs:1-103`
**Category**: Performance / Reliability
**Risk**: Browser sessions (Playwright pages) are created on demand but never automatically cleaned up based on age or inactivity. The `LastAccessedAt` field is tracked but never used for eviction. Long-running agents accumulate open browser tabs that consume memory.

**Evidence**:
```csharp
// BrowserSessionManager.cs:18-19
_sessions[sessionId] = existing with { LastAccessedAt = DateTimeOffset.UtcNow };
return existing;
// LastAccessedAt is set but there is no background cleanup using it
```

**Guidance**:
- Do NOT rely on `DisposeAsync` being called promptly; browser sessions accumulate until the process shuts down
- If modifying browser infrastructure: add a periodic cleanup task that closes sessions idle beyond a threshold
- Related files: `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs`

**Mitigation**:
- Add a background timer that closes sessions older than a configurable TTL (e.g., 30 minutes)
- Limit the maximum number of concurrent sessions

---

### PlaywrightWebBrowser is a God Class (946 Lines)

**Location**: `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:1-946`
**Category**: Maintainability
**Risk**: This single class handles navigation, CAPTCHA solving, modal dismissal, stealth scripting, element clicking, content extraction, session management, DOM stability waiting, and more. It has 900+ lines including a ~180-line JavaScript stealth script embedded as a string constant. Any change risks unintended side effects.

**Evidence**:
```csharp
// PlaywrightWebBrowser.cs - 946 lines total
// - Lines 28-181: StealthScript constant (JavaScript)
// - Lines 183-347: NavigateAsync with CAPTCHA/timeout/modal handling
// - Lines 350-478: ClickAsync with multiple timeout/error catch blocks
// - Lines 480-620: InspectAsync, ScrollAsync, etc.
```

**Guidance**:
- Do NOT add new methods to this class; it already violates SRP significantly
- When modifying navigation or clicking: trace ALL catch blocks carefully; there are 10+ catch clauses with different behaviors
- The stealth script (lines 28-181) must stay synchronized with Chrome version constants (line 23: `ChromeMajorVersion = "145"` and line 148: brand version `'145'`)
- Related files: `Infrastructure/Clients/Browser/BrowserSessionManager.cs`, `Infrastructure/Clients/Browser/ModalDismisser.cs`, `Infrastructure/Clients/Browser/CapSolverClient.cs`

**Mitigation**:
- Extract stealth scripting into its own class
- Extract navigation, clicking, and inspection into separate strategy classes
- Extract CAPTCHA handling into a dedicated middleware/handler

---

### HtmlInspector is a Large Static Class (1090 Lines)

**Location**: `Infrastructure/HtmlProcessing/HtmlInspector.cs:1-1090`
**Category**: Maintainability
**Risk**: At 1090 lines, this is the largest file in the codebase. It handles content detection, repeating element detection, navigation detection, outline building, structured data extraction, table parsing, and selector generation - all as static methods. Difficult to test individual behaviors in isolation.

**Evidence**:
```
1090 lines with responsibilities spanning:
- Main content detection (DetectMainContent)
- Repeating element detection (DetectRepeatingElements)
- Navigation detection (DetectNavigation)
- Outline building (BuildOutline)
- Suggestion generation (GenerateSuggestions)
- Structured data extraction (ExtractStructuredData)
- CSS selector generation (GenerateSelector)
- Table parsing
- Text search
```

**Guidance**:
- When modifying HTML inspection logic: be aware that changes to selector generation or element scoring can affect all downstream features
- The class is `partial`, so look for additional files before concluding you have the full picture
- Related files: `Infrastructure/HtmlProcessing/HtmlConverter.cs`, `Tests/Unit/Infrastructure/HtmlInspectorTests.cs` (1012 lines)

**Mitigation**:
- Split into focused classes: `ContentDetector`, `RepeatingElementDetector`, `NavigationDetector`, `SelectorGenerator`, `StructuredDataExtractor`

---

### WebChatMessengerClient.GenerateChatId Uses Timestamp

**Location**: `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:234-237`
**Category**: Reliability
**Risk**: `GenerateChatId` generates IDs using `DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()`. If two topics are created within the same millisecond, they will receive the same chatId, causing session collision and data corruption.

**Evidence**:
```csharp
// WebChatMessengerClient.cs:234-237
private static long GenerateChatId()
{
    return DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
}
```

**Guidance**:
- Do NOT create topics in rapid succession via the WebChat interface without awareness of this limitation
- When modifying ID generation: switch to `Interlocked.Increment` or combine timestamp with a counter
- Related files: `Infrastructure/Utils/TopicIdHasher.cs`, `Infrastructure/Clients/Messaging/WebChat/WebChatSessionManager.cs`

**Mitigation**:
- Use an atomic counter (`Interlocked.Increment`) or GUID-based ID generation

---

### Preview Packages in Production Dependencies

**Location**: `Infrastructure/Infrastructure.csproj:26-30`, `Domain/Domain.csproj:13`
**Category**: Reliability
**Risk**: Multiple preview packages are used in production code. Preview packages may have breaking changes, missing features, or bugs that are not yet resolved.

**Evidence**:
```xml
<!-- Infrastructure.csproj -->
<PackageReference Include="Microsoft.Agents.AI" Version="1.0.0-preview.260205.1" />
<PackageReference Include="Microsoft.Extensions.AI.OpenAI" Version="10.2.0-preview.1.26063.2"/>
<PackageReference Include="ModelContextProtocol" Version="0.8.0-preview.1" />

<!-- Domain.csproj -->
<PackageReference Include="Microsoft.Agents.AI.Abstractions" Version="1.0.0-preview.260205.1" />
```

**Guidance**:
- Do NOT upgrade these packages without checking release notes for breaking changes
- `Microsoft.Agents.AI` and `ModelContextProtocol` are both early preview; API surface may change significantly between versions
- Pin exact versions in a central package management file to avoid accidental upgrades

**Mitigation**:
- Track stable release dates for these packages
- Add integration tests that exercise the critical paths through these APIs to catch breaking changes early

---

### OpenRouterHttpHelpers Silent Error Swallowing

**Location**: `Infrastructure/Agents/ChatClients/OpenRouterHttpHelpers.cs:193-197`
**Category**: Reliability
**Risk**: The `ProcessBytes` method in `ReasoningTeeStream` catches and silently discards all exceptions. If the SSE stream contains malformed data, reasoning content is silently lost with no logging or error reporting.

**Evidence**:
```csharp
// OpenRouterHttpHelpers.cs:193-197
private void ProcessBytes(ReadOnlySpan<byte> bytes)
{
    try { ... }
    catch
    {
        // best-effort
    }
}
```

**Guidance**:
- If reasoning content is unexpectedly missing from agent responses: this is a likely culprit
- When modifying the reasoning extraction pipeline: add logging for parse failures at minimum
- Related files: `Infrastructure/Agents/ChatClients/OpenRouterChatClient.cs`

---

## LOW Risk Areas

### TerminalGuiAdapter is Large (617 Lines)

**Location**: `Infrastructure/CliGui/Ui/TerminalGuiAdapter.cs`
**Category**: Maintainability
**Note**: At 617 lines, this is on the boundary. It manages the entire Terminal.Gui lifecycle including layout, input handling, scrolling, thinking indicators, and Ctrl+C handling. Consider extracting layout setup and input handling into separate classes if this continues to grow.

---

### ModalDismisser is Complex (374 Lines)

**Location**: `Infrastructure/Clients/Browser/ModalDismisser.cs`
**Category**: Maintainability
**Note**: Contains heuristic-based logic for dismissing cookie banners, popups, and overlays on arbitrary websites. Fragile by nature since it relies on pattern matching against class names, button text, and DOM structure. Changes here may fix one site while breaking another.

---

### Telegram Authorization is Username-Based

**Location**: `Infrastructure/Clients/Messaging/Telegram/TelegramChatClient.cs:285-288`
**Category**: Security
**Note**: Authorization checks use `allowedUserNames.Contains(prompt.Sender)` where `Sender` is the Telegram username. Telegram usernames can be changed by users. If a user changes their username, they lose access. If someone obtains a previously-allowed username, they gain access. Low risk for a personal bot, but worth noting.

---

### IdealistaClient Token Expiry Uses DateTime.UtcNow

**Location**: `Infrastructure/Clients/IdealistaClient.cs:15-16`
**Category**: Reliability
**Note**: Uses `DateTime.UtcNow` directly rather than `TimeProvider` for token expiry checks. Not testable without real time progression. Low risk since OAuth tokens have multi-minute lifetimes, but inconsistent with the codebase convention of using `TimeProvider` for testable time-dependent code.

---

### StreamBuffer RemoveOldestMessage Has O(n) Index Adjustment

**Location**: `Infrastructure/Clients/Messaging/WebChat/StreamBuffer.cs:76-94`
**Category**: Performance
**Note**: When the buffer exceeds `MaxBufferSize` (100), `RemoveOldestMessage` performs `RemoveAt(0)` on a `List<T>` (O(n) shift) and then iterates all tracked indices to decrement them. With `MaxBufferSize = 100` this is negligible, but the pattern would not scale.

---

## Technical Debt Inventory

### TODO/FIXME/HACK Comments

| File | Line | Comment |
|------|------|---------|
| `McpServerLibrary/ResourceSubscriptions/SubscriptionMonitor.cs` | 129 | `TODO: Check all downloads in a single call` |

### Large Files (>500 lines)

| File | Lines | Concern |
|------|-------|---------|
| `Infrastructure/HtmlProcessing/HtmlInspector.cs` | 1090 | God class - multiple responsibilities, consider splitting |
| `Tests/Unit/Infrastructure/HtmlInspectorTests.cs` | 1012 | Large test file mirrors large implementation |
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs` | 946 | God class - navigation/clicking/CAPTCHA/stealth all in one |
| `Tests/Unit/WebChat/Client/StreamingServiceTests.cs` | 899 | Large test file |
| `Tests/Integration/Clients/PlaywrightWebBrowserIntegrationTests.cs` | 641 | Large integration test |
| `Infrastructure/CliGui/Ui/TerminalGuiAdapter.cs` | 617 | UI lifecycle management, consider extracting components |
| `Tests/Integration/WebChat/ChatHubIntegrationTests.cs` | 537 | Large integration test |

### Complex Functions (high cyclomatic complexity)

| File | Function | Concern |
|------|----------|---------|
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:183` | `NavigateAsync` | ~120 lines, 6+ catch blocks, CAPTCHA retry loop, modal dismissal, selector waiting, scroll-to-load, stability checking |
| `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:350` | `ClickAsync` | ~130 lines, 5+ catch blocks with different timeout/error handling paths |
| `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:159` | `CreateTopicIfNeededAsync` | Complex branching on threadId/chatId nullability with session creation side effects |
| `Infrastructure/HtmlProcessing/HtmlInspector.cs:46` | `DetectMainContent` | Scoring algorithm with multiple candidate sources and magic numbers |

---

## Fragile Patterns

### Chrome Version Synchronization

**Locations**:
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:23` (`ChromeMajorVersion = "145"`)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:26` (UserAgent string)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:148-150` (navigator.userAgentData brands)
- `Infrastructure/Clients/Browser/PlaywrightWebBrowser.cs:164` (uaFullVersion)

**Why it's fragile**: The Chrome version appears in four separate places: the constant, the UserAgent string, the brands array in the stealth script, and the uaFullVersion. If you update one but not the others, anti-bot detection systems will flag the mismatched fingerprint.

**When modifying**:
1. Update `ChromeMajorVersion` constant (line 23)
2. Verify `UserAgent` string uses the constant (line 26) -- it does via interpolation
3. Update brand versions in the stealth script `navigator.userAgentData` section (lines 148, 150, 164) -- these are hardcoded string literals, NOT referencing the constant
4. Test against a site with anti-bot protection (e.g., Cloudflare, DataDome)

---

### WebChat Stream Lifecycle Coordination

**Locations**:
- `Infrastructure/Clients/Messaging/WebChat/WebChatStreamManager.cs`
- `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:43-119`
- `Infrastructure/Clients/Messaging/WebChat/BroadcastChannel.cs`
- `Agent/Hubs/ChatHub.cs:96-173`

**Why it's fragile**: Stream lifecycle involves coordinating pending prompt counts, broadcast channels, cancellation tokens, stream buffers, and hub notifications across four files. The pending count must be incremented before the agent processes and decremented exactly once per completion. A missed increment or decrement causes either premature stream completion (cutting off responses) or never-completing streams (zombie streams).

**When modifying**:
1. Trace the full lifecycle: `GetOrCreateStream` -> `TryIncrementPending` -> `WriteMessageAsync` -> `DecrementPendingAndCheckIfShouldComplete` -> `CompleteStream`
2. Ensure every path that creates a stream eventually completes it (even error paths)
3. Test with multiple concurrent prompts to the same topic
4. Test browser reconnection during an active stream

---

### Tool Approval Whitelist Pattern Matching

**Locations**:
- `Infrastructure/Utils/ToolPatternMatcher.cs`
- `Infrastructure/Agents/ChatClients/ToolApprovalChatClient.cs:41`

**Why it's fragile**: The whitelist uses glob-to-regex conversion (`*` becomes `.*`). A pattern like `*` auto-approves ALL tools including dangerous ones (command execution, file deletion). The `_dynamicallyApproved` set grows during a session and is never cleared, meaning "approve and remember" is permanent for the session lifetime.

**When modifying**:
1. Review all configured whitelist patterns before deploying
2. Verify `_dynamicallyApproved` does not persist across sessions (it does not - it is per `ToolApprovalChatClient` instance)
3. Test that dangerous tools (command runners, file operations) are NOT matched by overly broad patterns

---

## Missing Safeguards

### No Rate Limiting on ChatHub

**Where**: `Agent/Hubs/ChatHub.cs`
**What's missing**: No rate limiting on `SendMessage`, `EnqueueMessage`, or any other hub method. A malicious or buggy client can flood the agent with prompts.
**Risk**: Resource exhaustion - each prompt triggers LLM API calls (which cost money) and spawns concurrent processing tasks.
**Recommendation**: Add per-user rate limiting via SignalR filters or a middleware.

### No Maximum Session Count for Browser Sessions

**Where**: `Infrastructure/Clients/Browser/BrowserSessionManager.cs`
**What's missing**: No limit on the number of concurrent browser sessions. Each session creates a new Playwright page.
**Risk**: Memory exhaustion if the agent is asked to browse many sites simultaneously.
**Recommendation**: Add a configurable maximum session count with eviction of least-recently-used sessions.

### No Input Size Validation on WebChat Messages

**Where**: `Agent/Hubs/ChatHub.cs:136-174`
**What's missing**: The `message` parameter in `SendMessage` has no length validation. Arbitrarily large messages are forwarded to the LLM.
**Risk**: Excessive token usage/cost and potential LLM context window overflow.
**Recommendation**: Add maximum message length validation in the hub method.

---

## Known Limitations

### SubscriptionMonitor Only Supports Download Resources

**Area**: `McpServerLibrary/ResourceSubscriptions/SubscriptionMonitor.cs:46-53`
**Limitation**: `GetResourceCheck` throws `NotImplementedException` for any URI scheme other than `download://`. Only download-based resource subscriptions are supported.
**Workaround**: N/A - only download monitoring is implemented.
**Future fix**: Implement handlers for other resource types as they are added to MCP servers.

### Single Redis Server Endpoint Assumption

**Area**: `Infrastructure/Memory/RedisStackMemoryStore.cs:27`
**Limitation**: `_server = redis.GetServer(redis.GetEndPoints()[0])` always uses the first endpoint. In a Redis cluster or sentinel setup, this may not target the correct node for SCAN operations.
**Workaround**: Deploy with a single Redis endpoint.
**Future fix**: Use `IServer` selection logic that accounts for cluster topology, or avoid `KeysAsync` (SCAN) in favor of index-based queries.

### WebChatMessengerClient _messageIdCounter is In-Memory

**Area**: `Infrastructure/Clients/Messaging/WebChat/WebChatMessengerClient.cs:26`
**Limitation**: `_messageIdCounter` resets to 0 on every application restart. Message IDs are not globally unique; they are only locally incrementing integers.
**Workaround**: The `MessageId` field on `ChatStreamMessage` is a string that may combine this counter with other identifiers.
**Future fix**: Use a persistent counter (Redis INCR) or GUID-based message IDs for durability across restarts.
