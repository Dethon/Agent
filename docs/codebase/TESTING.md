# Testing Conventions

> Auto-generated by /codemap-creator. Prescriptive guide for testing practices.

## Test Framework

- **Framework**: xUnit 2.9.3
- **Assertions**: Shouldly 4.3.0
- **Mocking**: Moq 4.20.72
- **Containers**: Testcontainers 4.10.0 (Redis, ServiceBus)
- **HTTP mocking**: WireMock.Net 1.25.0
- **Skippable tests**: Xunit.SkippableFact 1.5.61
- **Coverage**: coverlet.collector 6.0.4

## Running Tests

```bash
# All tests
dotnet test Tests/Tests.csproj

# Unit tests only (by namespace filter)
dotnet test Tests/Tests.csproj --filter "FullyQualifiedName~Tests.Unit"

# Integration tests only
dotnet test Tests/Tests.csproj --filter "FullyQualifiedName~Tests.Integration"

# Single test class
dotnet test Tests/Tests.csproj --filter "FullyQualifiedName~Tests.Unit.Domain.ChatThreadResolverTests"

# With coverage
dotnet test Tests/Tests.csproj --collect:"XPlat Code Coverage"
```

## Test Organization

### Directory Structure

```
Tests/
├── Unit/                          # Fast, isolated unit tests
│   ├── Domain/                    # Domain logic tests
│   │   ├── Text/                  # Text tool tests
│   │   ├── Scheduling/            # Scheduling tool tests
│   │   └── DTOs/                  # DTO serialization tests
│   ├── Infrastructure/            # Infrastructure layer tests
│   │   ├── Messaging/             # Message routing tests
│   │   ├── Memory/                # Memory/embedding tests
│   │   └── Cli/                   # CLI component tests
│   ├── WebChat.Client/            # WebChat state management tests
│   │   ├── State/                 # Store/reducer/selector tests
│   │   │   └── Pipeline/          # Message pipeline tests
│   │   └── Services/              # Service tests
│   ├── WebChat/Client/            # Legacy WebChat tests
│   ├── McpServerLibrary/          # MCP server-specific tests
│   └── Tools/                     # Standalone tool tests
├── Integration/                   # Tests requiring external resources
│   ├── Agents/                    # Agent integration tests
│   ├── Clients/                   # Client integration tests
│   ├── Domain/                    # Domain integration tests
│   ├── Infrastructure/            # Infrastructure integration tests
│   ├── McpServerTests/            # MCP server integration tests
│   ├── McpTools/                  # MCP tool integration tests
│   ├── Messaging/                 # ServiceBus integration tests
│   ├── Memory/                    # Redis memory store tests
│   ├── StateManagers/             # Redis state store tests
│   ├── WebChat/                   # WebChat hub integration tests
│   ├── Fixtures/                  # Shared test fixtures
│   └── Jack/                      # DI container tests
└── xunit.runner.json              # Test parallelization config
```

### File Naming
- **Pattern**: `{ClassUnderTest}Tests.cs`
- **Location**: Mirror the source project structure under `Tests/Unit/` or `Tests/Integration/`
- **Examples**: `ChatThreadResolverTests.cs`, `ToolPatternMatcherTests.cs`, `RedisScheduleStoreTests.cs`

### Test Method Naming
- **Pattern**: `{Method}_{Scenario}_{ExpectedResult}`
- Three segments separated by underscores

```csharp
// CORRECT
[Fact]
public void Run_TextNotFound_ThrowsWithSuggestion()

[Fact]
public async Task CreateAsync_StoresSchedule()

[Fact]
public void IsMatch_EmptyPatterns_MatchesNothing()

// INCORRECT
[Fact]
public void TestTextNotFound()  // No method/scenario/result segments
```

## Test Parallelization

Tests run in parallel by default, configured in `Tests/xunit.runner.json`:

```json
{
  "parallelizeAssembly": true,
  "parallelizeTestCollections": true,
  "maxParallelThreads": 0
}
```

Use `IClassFixture<T>` to share expensive resources (containers, servers) across tests in a class. Use `ICollectionFixture<T>` for sharing across multiple test classes.

## Test Types

### Unit Tests

- **Location**: `Tests/Unit/`
- **Dependencies**: All mocked or faked
- **Database**: Never real, always mocked
- **Speed**: Fast, no external resources

```csharp
// Example: Tests/Unit/Domain/ChatThreadResolverTests.cs
public class ChatThreadResolverTests
{
    [Fact]
    public void Resolve_WithNewKey_ReturnsNewContext()
    {
        // Arrange
        var resolver = new ChatThreadResolver();
        var key = new AgentKey(1, 1);

        // Act
        var context = resolver.Resolve(key);

        // Assert
        context.ShouldNotBeNull();
    }
}
```

### Integration Tests

- **Location**: `Tests/Integration/`
- **Dependencies**: Real (Redis via Testcontainers, SignalR, MCP servers)
- **Cleanup**: Each test cleans up via `IAsyncLifetime` or `IDisposable`
- **Skippable**: Use `[SkippableFact]` for tests requiring API keys or external services

```csharp
// Example: Tests/Integration/StateManagers/RedisScheduleStoreTests.cs
public class RedisScheduleStoreTests(RedisFixture fixture)
    : IClassFixture<RedisFixture>, IAsyncLifetime
{
    private readonly RedisScheduleStore _store = new(fixture.Connection);
    private readonly List<string> _createdIds = [];

    public Task InitializeAsync() => Task.CompletedTask;

    public async Task DisposeAsync()
    {
        foreach (var id in _createdIds)
        {
            await _store.DeleteAsync(id);
        }
    }

    [Fact]
    public async Task CreateAsync_StoresSchedule()
    {
        // Arrange
        var schedule = CreateTestSchedule();
        _createdIds.Add(schedule.Id);

        // Act
        var result = await _store.CreateAsync(schedule);

        // Assert
        result.Id.ShouldBe(schedule.Id);
        var stored = await _store.GetAsync(schedule.Id);
        stored.ShouldNotBeNull();
        stored.Prompt.ShouldBe(schedule.Prompt);
    }
}
```

## Test Patterns

### Arrange-Act-Assert

All tests follow AAA pattern with explicit comment markers:

```csharp
[Fact]
public void Run_SingleOccurrence_ReplacesText()
{
    // Arrange
    var filePath = CreateTestFile("test.txt", "Hello World");

    // Act
    var result = _tool.TestRun(filePath, "World", "Universe");

    // Assert
    result["status"]!.ToString().ShouldBe("success");
    File.ReadAllText(filePath).ShouldBe("Hello Universe");
}
```

For tests where Act and Assert are combined (e.g., exception tests), use `// Act & Assert`:

```csharp
[Fact]
public async Task CleanAsync_WithNonExistentKey_DoesNotThrow()
{
    // Arrange
    var resolver = new ChatThreadResolver();
    var key = new AgentKey(999, 999);

    // Act & Assert
    await Should.NotThrowAsync(() => resolver.ClearAsync(key));
}
```

### Testable Wrappers

For classes with `protected` methods, create private testable wrapper classes inside the test class:

```csharp
// Tests/Unit/Domain/Text/TextEditToolTests.cs
public class TextEditToolTests : IDisposable
{
    private readonly TestableTextEditTool _tool;

    // Wrapper exposes protected methods for testing
    private class TestableTextEditTool(string vaultPath, string[] allowedExtensions)
        : TextEditTool(vaultPath, allowedExtensions)
    {
        public JsonNode TestRun(string filePath, string oldString, string newString, bool replaceAll = false)
        {
            return Run(filePath, oldString, newString, replaceAll);
        }
    }
}
```

### Temp Directory Cleanup

When tests create filesystem artifacts, use `IDisposable` for cleanup:

```csharp
public class TextEditToolTests : IDisposable
{
    private readonly string _testDir;

    public TextEditToolTests()
    {
        _testDir = Path.Combine(Path.GetTempPath(), $"text-edit-tests-{Guid.NewGuid()}");
        Directory.CreateDirectory(_testDir);
    }

    public void Dispose()
    {
        if (Directory.Exists(_testDir))
        {
            Directory.Delete(_testDir, true);
        }
    }
}
```

### Theory / InlineData for Parameterized Tests

Use `[Theory]` with `[InlineData]` for testing multiple input scenarios:

```csharp
// Tests/Unit/Infrastructure/ToolPatternMatcherTests.cs
[Theory]
[InlineData("mcp:server:Tool", "mcp:server:Tool", true)]
[InlineData("mcp:server:Tool", "mcp:server:tool", true)]   // case insensitive
[InlineData("mcp:server:Tool", "mcp:server:OtherTool", false)]
public void IsMatch_ExactPattern_MatchesCorrectly(string toolName, string pattern, bool expected)
{
    var matcher = new ToolPatternMatcher([pattern]);
    matcher.IsMatch(toolName).ShouldBe(expected);
}
```

## Assertions with Shouldly

Use Shouldly for all assertions. Never use `Assert.*` from xUnit directly.

```csharp
// Basic assertions
result.ShouldNotBeNull();
result.ShouldBe("expected");
result.ShouldBeTrue();
result.ShouldBeFalse();

// Collection assertions
agents.ShouldNotBeEmpty();
agents.Count.ShouldBe(2);
agents.ShouldContain(a => a.Id == "test-agent");
keys.ShouldNotContain(key);
handler.AutoApprovedNotifications.ShouldHaveSingleItem();

// Reference equality
secondContext.ShouldBeSameAs(firstContext);
context1.ShouldNotBeSameAs(context2);

// Comparison
laterIndex.ShouldBeLessThan(earlierIndex);
clientCount.ShouldBeGreaterThan(0);

// String contains
ex.Message.ShouldContain("3 occurrences");

// Exception assertions
Should.Throw<ObjectDisposedException>(() => resolver.Resolve(key));
Should.Throw<InvalidOperationException>(() => _tool.TestRun(filePath, "foo", "FOO"));
await Should.NotThrowAsync(() => resolver.ClearAsync(key));

// Tolerance for dates/floats
updated.LastRunAt.Value.ShouldBe(lastRun, TimeSpan.FromSeconds(1));

// Custom string message on assertion
invoked.ShouldBeTrue("Tool should have been invoked after approval");

// All elements match
results.ShouldAllBe(r => ReferenceEquals(r, firstContext));
```

## Mocking with Moq

Use Moq for unit tests when real dependencies are impractical.

```csharp
// Setup mocks in constructor
private readonly Mock<IScheduleStore> _store = new();
private readonly Mock<ICronValidator> _cronValidator = new();

// Configure mock behavior
_cronValidator.Setup(v => v.IsValid("invalid")).Returns(false);
_store.Setup(s => s.CreateAsync(It.IsAny<Schedule>(), It.IsAny<CancellationToken>()))
    .ReturnsAsync((Schedule s, CancellationToken _) => s);

// Verify mock interactions
_store.Verify(s => s.CreateAsync(It.Is<Schedule>(sch =>
    sch.Agent.Id == "jack" &&
    sch.Prompt == "test prompt"), It.IsAny<CancellationToken>()), Times.Once);
```

### Prefer Fakes Over Mocks

For interfaces with complex interaction patterns, create private fake implementations inside the test class instead of using Moq:

```csharp
// Tests/Unit/Infrastructure/ToolApprovalChatClientTests.cs
private sealed class TestApprovalHandler(ToolApprovalResult result) : IToolApprovalHandler
{
    public List<IReadOnlyList<ToolApprovalRequest>> RequestedApprovals { get; } = [];

    public Task<ToolApprovalResult> RequestApprovalAsync(
        IReadOnlyList<ToolApprovalRequest> requests,
        CancellationToken cancellationToken)
    {
        RequestedApprovals.Add(requests);
        return Task.FromResult(result);
    }
}

private sealed class FakeChatClient : IChatClient
{
    private readonly Queue<ChatResponse> _responses = new();
    public void SetNextResponse(ChatResponse response) => _responses.Enqueue(response);
    // ...
}
```

## Test Fixtures

### Testcontainers for External Dependencies

Use Testcontainers to spin up real infrastructure in integration tests:

```csharp
// Tests/Integration/Fixtures/RedisFixture.cs
public class RedisFixture : IAsyncLifetime
{
    private IContainer _container = null!;
    public IConnectionMultiplexer Connection { get; private set; } = null!;
    public string ConnectionString { get; private set; } = null!;

    public async Task InitializeAsync()
    {
        _container = new ContainerBuilder("redis/redis-stack:latest")
            .WithPortBinding(RedisPort, true)
            .WithWaitStrategy(Wait.ForUnixContainer()
                .UntilMessageIsLogged("Ready to accept connections"))
            .Build();
        await _container.StartAsync();

        var host = _container.Hostname;
        var port = _container.GetMappedPublicPort(RedisPort);
        ConnectionString = $"{host}:{port}";
        Connection = await ConnectionMultiplexer.ConnectAsync(ConnectionString);
    }

    public async Task DisposeAsync()
    {
        await Connection.DisposeAsync();
        await _container.DisposeAsync();
    }
}
```

### WebChat Server Fixture

Integration tests for SignalR/WebChat spin up a full in-process ASP.NET host:

```csharp
// Tests/Integration/Fixtures/WebChatServerFixture.cs
public sealed class WebChatServerFixture : IAsyncLifetime
{
    private IHost _host = null!;

    public async Task InitializeAsync()
    {
        // Starts Redis testcontainer
        // Builds WebApplication with Kestrel on random port
        // Registers all required services with fakes
        // Starts ChatMonitor on background task
    }

    public HubConnection CreateHubConnection() =>
        new HubConnectionBuilder().WithUrl(HubUrl).WithAutomaticReconnect().Build();
}
```

### Skippable Tests for API-Dependent Integration Tests

Use `[SkippableFact]` with `SkipException` for tests requiring external API keys:

```csharp
// Tests/Integration/Agents/ThreadSessionIntegrationTests.cs
[SkippableFact]
public async Task CreateAsync_CreatesSessionWithToolsPromptsAndResourceManager()
{
    var apiKey = _configuration["openRouter:apiKey"]
        ?? throw new SkipException("openRouter:apiKey not set in user secrets");
    // Test continues only if API key is available...
}
```

## WebChat State Tests

Test stores by creating a real `Dispatcher`, dispatching actions, and asserting state:

```csharp
// Tests/Unit/WebChat.Client/State/SpaceStoreTests.cs
public class SpaceStoreTests : IDisposable
{
    private readonly Dispatcher _dispatcher;
    private readonly SpaceStore _store;

    public SpaceStoreTests()
    {
        _dispatcher = new Dispatcher();
        _store = new SpaceStore(_dispatcher);
    }

    public void Dispose() => _store.Dispose();

    [Fact]
    public void SpaceValidated_UpdatesSlugAndAccentColor()
    {
        _dispatcher.Dispatch(new SpaceValidated("secret-room", "Secret Room", "#6366f1"));

        _store.State.CurrentSlug.ShouldBe("secret-room");
        _store.State.AccentColor.ShouldBe("#6366f1");
    }
}
```

## Test Data Factories

Create static helper methods within test classes for constructing test data:

```csharp
// Within RedisScheduleStoreTests
private static Schedule CreateTestSchedule()
{
    return new Schedule
    {
        Id = $"test_{Guid.NewGuid():N}",
        Agent = new AgentDefinition
        {
            Id = "test",
            Name = "Test Agent",
            Model = "test-model",
            McpServerEndpoints = []
        },
        Prompt = "Test prompt",
        CronExpression = "0 9 * * *",
        UserId = "testuser",
        CreatedAt = DateTime.UtcNow,
        NextRunAt = DateTime.UtcNow.AddHours(1)
    };
}
```

## TDD Workflow

Follow Red-Green-Refactor for all features and bug fixes:

1. **Red** -- Write a failing test first that defines the expected behavior
2. **Green** -- Write the minimum implementation code to make the test pass
3. **Refactor** -- Clean up the code while keeping all tests green

### Rules
- Never write implementation code without a failing test first
- Write one test at a time, then make it pass before writing the next
- Run the test suite after each change to confirm the cycle
- Tests must actually fail before implementation (verify the "red" step)

### Exceptions
- Pure configuration changes (appsettings, DI registration) do not require TDD
- Trivial one-line changes where the risk is negligible

## What to Test

### Always Test
- Domain tool logic (validation, business rules, edge cases)
- State reducers and store behavior (WebChat)
- Infrastructure service behavior (message routing, pattern matching)
- Error conditions and exception types
- Concurrent access scenarios

### Skip Testing
- DI registration wiring (covered by integration tests indirectly)
- MCP tool thin wrappers (they just delegate to Domain tools)
- Framework-provided behavior (ASP.NET middleware, SignalR)
- Simple record property access
