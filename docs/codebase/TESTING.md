# Testing Conventions

> Auto-generated by /codemap-creator. Prescriptive guide for testing practices.

## Test Framework

- **Framework**: xUnit 2.9 with `xunit.runner.visualstudio` 3.1
- **Assertion Library**: Shouldly 4.3 (use `.ShouldBe()`, `.ShouldNotBeNull()`, `Should.ThrowAsync<>()`)
- **Mocking**: Moq 4.20 (use sparingly; prefer integration tests with real dependencies)
- **HTTP Mocking**: WireMock.Net 1.25 for HTTP service stubs
- **Containers**: Testcontainers 4.10 for Redis, ServiceBus, and other external dependencies
- **Skippable Tests**: Xunit.SkippableFact 1.5 for tests requiring external secrets
- **Coverage**: Coverlet 6.0

## TDD Workflow

Follow Red-Green-Refactor for all features and bug fixes:

1. **Red** -- Write a failing test first that defines the expected behavior
2. **Green** -- Write the minimum implementation code to make the test pass
3. **Refactor** -- Clean up the code while keeping all tests green

Rules:
- Never write implementation code without a failing test first
- Write one test at a time, then make it pass before writing the next
- Run the test suite after each change to confirm the cycle
- Tests must actually fail before implementation (verify the "red" step)

Exceptions: Pure configuration changes and trivial one-line changes.

## Running Tests

```bash
# All tests
dotnet test Tests/Tests.csproj

# Unit tests only (by namespace filter)
dotnet test Tests/Tests.csproj --filter "FullyQualifiedName~Tests.Unit"

# Integration tests only
dotnet test Tests/Tests.csproj --filter "FullyQualifiedName~Tests.Integration"

# Specific test class
dotnet test Tests/Tests.csproj --filter "FullyQualifiedName~BraveSearchClientTests"

# With coverage
dotnet test Tests/Tests.csproj --collect:"XPlat Code Coverage"
```

## Test Runner Configuration

Parallelization is enabled in `Tests/xunit.runner.json`:

```json
{
  "parallelizeAssembly": true,
  "parallelizeTestCollections": true,
  "maxParallelThreads": 0
}
```

## Test Organization

### Directory Structure

```
Tests/
├── Unit/                              # Fast, isolated unit tests
│   ├── Domain/                        # Domain logic tests
│   │   ├── Text/                      # Text tool tests
│   │   ├── Scheduling/               # Schedule tool tests
│   │   └── DTOs/                      # DTO behavior tests
│   ├── Infrastructure/                # Infrastructure tests
│   │   ├── Messaging/                 # Messaging subsystem tests
│   │   ├── Memory/                    # Memory subsystem tests
│   │   └── Cli/                       # CLI tests
│   ├── WebChat.Client/                # Blazor client state tests
│   │   ├── State/                     # Store and effect tests
│   │   │   └── Pipeline/             # Message pipeline tests
│   │   └── Services/                  # Client service tests
│   ├── WebChat/Client/                # Additional WebChat tests
│   └── McpServerLibrary/             # MCP server unit tests
├── Integration/                       # Tests requiring external resources
│   ├── Agents/                        # Agent integration tests
│   ├── Clients/                       # Client integration tests
│   ├── Memory/                        # Redis memory store tests
│   ├── Messaging/                     # ServiceBus integration tests
│   ├── McpServerTests/               # MCP server integration tests
│   ├── McpTools/                      # MCP tool integration tests
│   ├── StateManagers/                 # Redis state store tests
│   ├── WebChat/                       # WebChat hub integration tests
│   │   └── Client/                    # WebChat client integration tests
│   ├── Infrastructure/                # Infrastructure integration tests
│   ├── Jack/                          # DI container tests
│   └── Fixtures/                      # Shared test fixtures
│       ├── RedisFixture.cs
│       ├── ServiceBusFixture.cs
│       ├── WebChatServerFixture.cs
│       ├── McpLibraryServerFixture.cs
│       ├── TelegramBotFixture.cs
│       └── FakeAgentFactory.cs
└── xunit.runner.json
```

### File Naming

- **Pattern**: `{ClassUnderTest}Tests.cs`
- **Location**: Mirror the source project structure under `Tests/Unit/` or `Tests/Integration/`
- **Examples**: `BraveSearchClientTests.cs`, `RemoveToolTests.cs`, `MessagesStoreTests.cs`

### Namespace Convention

Test namespaces mirror the test directory structure:

```csharp
namespace Tests.Unit.Infrastructure;           // Tests/Unit/Infrastructure/
namespace Tests.Unit.Domain.Scheduling;        // Tests/Unit/Domain/Scheduling/
namespace Tests.Integration.Memory;            // Tests/Integration/Memory/
namespace Tests.Unit.WebChat.Client.State;     // Tests/Unit/WebChat.Client/State/
```

## Test Method Naming

Use the pattern: `{Method}_{Scenario}_{ExpectedResult}`

```csharp
[Fact]
public async Task SearchAsync_WithValidQuery_ReturnsResults()

[Fact]
public async Task SearchAsync_OnHttpError_ThrowsException()

[Fact]
public async Task Run_WithPathContainingDoubleDot_ThrowsInvalidOperationException()

[Fact]
public async Task StoreAsync_AndGetById_ReturnsStoredMemory()

[Fact]
public void MessagesLoaded_PopulatesMessagesByTopic()
```

See `Tests/Unit/Infrastructure/BraveSearchClientTests.cs` and `Tests/Unit/Domain/RemoveToolTests.cs`.

## Test Types

### Unit Tests

- **Location**: `Tests/Unit/`
- **Dependencies**: Mocked or faked
- **Database/Network**: Never real; always mocked
- **Speed**: Fast, run in parallel

```csharp
public class ServiceBusMessageParserTests
{
    private readonly ServiceBusMessageParser _parser = new(["agent-456", "default-agent", "test-agent"]);

    [Fact]
    public void Parse_ValidMessage_ReturnsParseSuccess()
    {
        // Arrange
        var message = CreateMessage(
            correlationId: "correlation-123",
            agentId: "agent-456",
            prompt: "Hello",
            sender: "user1");

        // Act
        var result = _parser.Parse(message);

        // Assert
        result.ShouldBeOfType<ParseSuccess>();
        var success = (ParseSuccess)result;
        success.Message.Prompt.ShouldBe("Hello");
    }
}
```

See `Tests/Unit/Infrastructure/Messaging/ServiceBusMessageParserTests.cs`.

### Integration Tests

- **Location**: `Tests/Integration/`
- **Dependencies**: Real (Redis via Testcontainers, actual HTTP servers via WireMock, MCP servers)
- **Isolation**: Each test uses unique IDs (`Guid.NewGuid()`) to avoid collisions
- **Fixtures**: Shared via `IClassFixture<T>` with `IAsyncLifetime` for setup/teardown
- **Skippable**: Tests requiring external API keys use `[SkippableFact]` with `SkipException`

```csharp
public class RedisMemoryStoreTests(RedisFixture redisFixture) : IClassFixture<RedisFixture>
{
    private RedisStackMemoryStore CreateStore()
    {
        return new RedisStackMemoryStore(redisFixture.Connection);
    }

    [Fact]
    public async Task StoreAsync_AndGetById_ReturnsStoredMemory()
    {
        // Arrange
        var store = CreateStore();
        var userId = $"user_{Guid.NewGuid():N}";
        var memory = CreateMemory(userId, "User prefers TypeScript");

        // Act
        await store.StoreAsync(memory);
        var retrieved = await store.GetByIdAsync(userId, memory.Id);

        // Assert
        retrieved.ShouldNotBeNull();
        retrieved.Content.ShouldBe("User prefers TypeScript");
    }
}
```

See `Tests/Integration/Memory/RedisMemoryStoreTests.cs`.

### Skippable Integration Tests

Tests requiring external secrets (API keys) use `[SkippableFact]` and throw `SkipException` when credentials are missing.

```csharp
[SkippableFact]
public async Task Agent_WithGlobFilesTool_CanFindFiles()
{
    var llmClient = CreateLlmClient(); // Throws SkipException if API key missing

    // ... test body
}

private static OpenRouterChatClient CreateLlmClient()
{
    var apiKey = _configuration["openRouter:apiKey"]
                 ?? throw new SkipException("openRouter:apiKey not set in user secrets");
    // ...
}
```

See `Tests/Integration/Agents/McpAgentIntegrationTests.cs:21-27`.

## Test Patterns

### Arrange-Act-Assert

All tests follow the AAA pattern with explicit comment markers:

```csharp
[Fact]
public async Task SearchAsync_WithValidQuery_ReturnsResults()
{
    // Arrange
    var response = new { query = new { response_time = 0.42 }, web = new { ... } };
    _server.Given(Request.Create().WithPath("/web/search").UsingGet())
        .RespondWith(Response.Create().WithStatusCode(200).WithBody(JsonSerializer.Serialize(response)));

    // Act
    var query = new WebSearchQuery("test query");
    var result = await _client.SearchAsync(query);

    // Assert
    result.ShouldNotBeNull();
    result.Query.ShouldBe("test query");
    result.TotalResults.ShouldBe(100);
}
```

See `Tests/Unit/Infrastructure/BraveSearchClientTests.cs:28-72`.

### Testable Wrappers

For classes with `protected` methods, create a private `Testable*` wrapper inside the test class that exposes the method.

```csharp
public class RemoveToolTests
{
    // ... test methods calling tool.TestRun(...)

    private class TestableRemoveTool(
        IFileSystemClient client,
        LibraryPathConfig libraryPath)
        : RemoveTool(client, libraryPath)
    {
        public Task<JsonNode> TestRun(string path, CancellationToken ct)
        {
            return Run(path, ct);
        }
    }
}
```

See `Tests/Unit/Domain/RemoveToolTests.cs:143-152`.

### Factory Methods for Test Data

Create private helper methods in the test class to build test data. Use descriptive names and optional override parameters.

```csharp
private static MemoryEntry CreateMemory(
    string userId,
    string content,
    MemoryCategory category = MemoryCategory.Fact,
    double importance = 0.5,
    float[]? embedding = null,
    IReadOnlyList<string>? tags = null)
{
    return new MemoryEntry
    {
        Id = $"mem_{Guid.NewGuid():N}",
        UserId = userId,
        Category = category,
        Content = content,
        Importance = importance,
        // ...
    };
}
```

See `Tests/Integration/Memory/RedisMemoryStoreTests.cs:27-48`.

### Inline Fakes Over Mocking

For collaborators, prefer purpose-built fake classes over Moq when the fake is reusable or the interface is complex. Define them as `private sealed class` inside the test class.

```csharp
private sealed class TestApprovalHandler(ToolApprovalResult result) : IToolApprovalHandler
{
    public List<IReadOnlyList<ToolApprovalRequest>> RequestedApprovals { get; } = [];
    public List<IReadOnlyList<ToolApprovalRequest>> AutoApprovedNotifications { get; } = [];

    public Task<ToolApprovalResult> RequestApprovalAsync(
        IReadOnlyList<ToolApprovalRequest> requests,
        CancellationToken cancellationToken)
    {
        RequestedApprovals.Add(requests);
        return Task.FromResult(result);
    }
}

private sealed class FakeChatClient : IChatClient
{
    private readonly Queue<ChatResponse> _responses = new();
    public void SetNextResponse(ChatResponse response) => _responses.Enqueue(response);
    // ...
}
```

See `Tests/Unit/Infrastructure/ToolApprovalChatClientTests.cs:211-272`.

### Moq for Simple Mocks

Use Moq when the mock is simple (1-2 methods) and not reused across test classes.

```csharp
private readonly Mock<IFileSystemClient> _fileSystemClientMock = new();

[Fact]
public async Task Run_WithValidPath_MovesToTrash()
{
    var tool = CreateTool();
    var filePath = Path.Combine(_libraryPath, "movies", "test.mkv");

    _fileSystemClientMock
        .Setup(m => m.MoveToTrash(filePath, It.IsAny<CancellationToken>()))
        .ReturnsAsync(trashPath);

    var result = await tool.TestRun(filePath, CancellationToken.None);

    result["status"]!.ToString().ShouldBe("success");
    _fileSystemClientMock.Verify(m => m.MoveToTrash(filePath, It.IsAny<CancellationToken>()), Times.Once);
}
```

See `Tests/Unit/Domain/RemoveToolTests.cs:13-49`.

## Assertions

### Use Shouldly Exclusively

Use Shouldly for all assertions. Do not use xUnit's built-in `Assert.*`.

```csharp
// Value equality
result.Query.ShouldBe("test query");
result.TotalResults.ShouldBe(100);

// Null checks
retrieved.ShouldNotBeNull();
result.ShouldBeNull();

// Collections
result.Results.ShouldNotBeEmpty();
result.Results.ShouldBeEmpty();
result.Results.Count.ShouldBe(1);
results.ShouldHaveSingleItem();

// Type checks
result.ShouldBeOfType<ParseSuccess>();

// Boolean
invoked.ShouldBeTrue("Tool should have been invoked after approval");
deleted.ShouldBeFalse();

// Exceptions
await Should.ThrowAsync<HttpRequestException>(() => _client.SearchAsync(query));
var exception = await Should.ThrowAsync<InvalidOperationException>(async () =>
    await tool.TestRun(maliciousPath, CancellationToken.None));
exception.Message.ShouldContain("must not contain '..'");

// String
result.Results[0].Snippet.ShouldEndWith("...");
result.Results[0].Snippet.Length.ShouldBeLessThanOrEqualTo(203);

// Comparisons
retrieved.LastAccessedAt.ShouldBeGreaterThan(originalAccessTime);
```

## Fixtures

### Redis Fixture (Testcontainers)

Use `RedisFixture` for any test needing Redis. It starts a Redis container via Testcontainers and provides a `ConnectionMultiplexer`.

```csharp
public class RedisMemoryStoreTests(RedisFixture redisFixture) : IClassFixture<RedisFixture>
{
    // Use redisFixture.Connection to create stores
}
```

See `Tests/Integration/Fixtures/RedisFixture.cs`.

### WebChat Server Fixture

Use `WebChatServerFixture` for SignalR hub integration tests. It boots a full ASP.NET Core host with Redis, SignalR, and a `FakeAgentFactory`.

```csharp
public class ChatHubIntegrationTests(WebChatServerFixture fixture)
    : IClassFixture<WebChatServerFixture>
{
    // Use fixture.CreateHubConnection() for SignalR client
}
```

See `Tests/Integration/Fixtures/WebChatServerFixture.cs`.

### Fixture Lifecycle

Fixtures implement `IAsyncLifetime` for async setup/teardown:

```csharp
public class RedisFixture : IAsyncLifetime
{
    public async Task InitializeAsync()
    {
        _container = new ContainerBuilder("redis/redis-stack:latest")
            .WithPortBinding(RedisPort, true)
            .WithWaitStrategy(Wait.ForUnixContainer()
                .UntilMessageIsLogged("Ready to accept connections"))
            .Build();
        await _container.StartAsync();
        Connection = await ConnectionMultiplexer.ConnectAsync(ConnectionString);
    }

    public async Task DisposeAsync()
    {
        await Connection.DisposeAsync();
        await _container.DisposeAsync();
    }
}
```

## Cleanup and Disposal

### Temp Files

Use `IDisposable` for tests that create temporary files or directories.

```csharp
public class ExampleToolTests : IDisposable
{
    private readonly string _testDir;

    public ExampleToolTests()
    {
        _testDir = Path.Combine(Path.GetTempPath(), $"test-{Guid.NewGuid()}");
        Directory.CreateDirectory(_testDir);
    }

    public void Dispose()
    {
        if (Directory.Exists(_testDir))
            Directory.Delete(_testDir, true);
    }
}
```

### WireMock Servers

Dispose WireMock servers via `IDisposable` on the test class.

```csharp
public class BraveSearchClientTests : IDisposable
{
    private readonly WireMockServer _server;

    public BraveSearchClientTests()
    {
        _server = WireMockServer.Start();
    }

    public void Dispose()
    {
        _server.Dispose();
    }
}
```

See `Tests/Unit/Infrastructure/BraveSearchClientTests.cs:12-250`.

## Test Isolation

### Unique IDs

Integration tests use unique IDs per test to avoid collisions when running in parallel:

```csharp
var userId = $"user_{Guid.NewGuid():N}";
```

### No Shared Mutable State

Each test creates its own instance of the system under test. Do not share mutable state between tests.

```csharp
// Each test creates a fresh store instance
private RedisStackMemoryStore CreateStore()
{
    return new RedisStackMemoryStore(redisFixture.Connection);
}
```

## What to Test

### Always Test

- Public API methods and their edge cases
- Business logic in Domain tools and services
- Error conditions and validation (path traversal, missing fields, invalid input)
- Null/empty/boundary conditions
- State transitions in stores and reducers

### Skip Testing

- Private implementation details (test through public API)
- Pure DI registration (covered by DI container tests in `Tests/Integration/Jack/DependencyInjectionTests.cs`)
- MCP tool methods directly (test the underlying Domain tool; MCP wrapper is trivial)
- Third-party library behavior

## Preference: Integration Over Mocks

Prefer integration tests with real dependencies over unit tests with mocks. Use Testcontainers to spin up Redis, ServiceBus, or other infrastructure. Only use mocks when:

- The external dependency is expensive or slow (external APIs behind keys)
- The test is specifically verifying interaction patterns (verify calls were made)
- The component under test has complex conditional logic to isolate
