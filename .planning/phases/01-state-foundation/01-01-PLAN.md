---
phase: 01-state-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/WebChat.Client.csproj
  - WebChat.Client/State/IAction.cs
  - WebChat.Client/State/Store.cs
autonomous: true

must_haves:
  truths:
    - "Developer can define typed actions as record types implementing IAction"
    - "Developer can create a Store<TState> with an initial state record"
    - "Developer can read current state via Store.State property"
    - "Developer can subscribe to state changes via Store.StateObservable"
    - "Developer can dispatch actions with reducers that produce new state"
  artifacts:
    - path: "WebChat.Client/State/IAction.cs"
      provides: "Marker interface for typed actions"
      exports: ["IAction"]
    - path: "WebChat.Client/State/Store.cs"
      provides: "Generic store with BehaviorSubject"
      exports: ["Store<TState>"]
    - path: "WebChat.Client/WebChat.Client.csproj"
      provides: "System.Reactive package reference"
      contains: "System.Reactive"
  key_links:
    - from: "WebChat.Client/State/Store.cs"
      to: "System.Reactive"
      via: "BehaviorSubject<TState>"
      pattern: "BehaviorSubject"
    - from: "WebChat.Client/State/Store.cs"
      to: "WebChat.Client/State/IAction.cs"
      via: "Dispatch method constraint"
      pattern: "where TAction : IAction"
---

<objective>
Create core state infrastructure: generic Store class using BehaviorSubject for reactive state, and IAction marker interface for typed actions.

Purpose: Establishes the foundation for unidirectional data flow - immutable state held in stores, observable by components, updated via typed actions.

Output: `Store.cs` and `IAction.cs` in `WebChat.Client/State/` folder, System.Reactive package installed.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-state-foundation/01-RESEARCH.md
@WebChat.Client/WebChat.Client.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install System.Reactive package</name>
  <files>WebChat.Client/WebChat.Client.csproj</files>
  <action>
Add System.Reactive 6.1.0 package to WebChat.Client project:

```bash
dotnet add WebChat.Client package System.Reactive --version 6.1.0
```

This provides BehaviorSubject, CompositeDisposable, and IObservable extensions needed for reactive state management.
  </action>
  <verify>`dotnet restore WebChat.Client` succeeds. Check WebChat.Client.csproj contains `<PackageReference Include="System.Reactive" Version="6.1.0"/>`</verify>
  <done>System.Reactive 6.1.0 is referenced in WebChat.Client.csproj</done>
</task>

<task type="auto">
  <name>Task 2: Create IAction marker interface</name>
  <files>WebChat.Client/State/IAction.cs</files>
  <action>
Create `WebChat.Client/State/IAction.cs`:

```csharp
namespace WebChat.Client.State;

/// <summary>
/// Marker interface for all state actions.
/// Actions are defined as record types implementing this interface.
/// Example: public record TopicsLoaded(IReadOnlyList<Topic> Topics) : IAction;
/// </summary>
public interface IAction;
```

This marker interface enables type-safe dispatch and reducer pattern matching. Actions will be records implementing IAction with past-tense naming (TopicsLoaded, MessageReceived, etc.).
  </action>
  <verify>File exists at `WebChat.Client/State/IAction.cs`. `dotnet build WebChat.Client` compiles without errors.</verify>
  <done>IAction marker interface exists for typed actions</done>
</task>

<task type="auto">
  <name>Task 3: Create generic Store class</name>
  <files>WebChat.Client/State/Store.cs</files>
  <action>
Create `WebChat.Client/State/Store.cs`:

```csharp
using System.Reactive.Linq;
using System.Reactive.Subjects;

namespace WebChat.Client.State;

public sealed class Store<TState> : IDisposable where TState : class
{
    private readonly BehaviorSubject<TState> _subject;

    public Store(TState initialState)
    {
        ArgumentNullException.ThrowIfNull(initialState);
        _subject = new BehaviorSubject<TState>(initialState);
    }

    /// <summary>
    /// Current state value. Use for synchronous reads.
    /// </summary>
    public TState State => _subject.Value;

    /// <summary>
    /// Observable state stream. Subscribe to receive state updates.
    /// New subscribers immediately receive current state (BehaviorSubject semantics).
    /// </summary>
    public IObservable<TState> StateObservable => _subject.AsObservable();

    /// <summary>
    /// Dispatch an action through a reducer to produce new state.
    /// </summary>
    public void Dispatch<TAction>(TAction action, Func<TState, TAction, TState> reducer)
        where TAction : IAction
    {
        var newState = reducer(State, action);
        _subject.OnNext(newState);
    }

    public void Dispose() => _subject.Dispose();
}
```

Key design decisions:
- `BehaviorSubject` replays latest value to new subscribers (essential for late-subscribing components)
- `AsObservable()` prevents external code from calling OnNext directly
- Generic constraint `where TState : class` ensures reference type state (records are reference types)
- Reducer passed to Dispatch allows store to be generic - specific reducers defined per feature in Phase 2
  </action>
  <verify>`dotnet build WebChat.Client` compiles without errors. Store class is usable: can construct `new Store<RecordType>(initialState)`, access `.State`, subscribe to `.StateObservable`.</verify>
  <done>Generic Store<TState> exists with BehaviorSubject-based reactive state, dispatch method accepting reducers</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build WebChat.Client` succeeds
2. `WebChat.Client/State/` folder contains `IAction.cs` and `Store.cs`
3. System.Reactive 6.1.0 is in project dependencies
4. No changes to existing functionality (stores are additive infrastructure)
</verification>

<success_criteria>
- System.Reactive package installed and restorable
- IAction interface exists for action typing
- Store<TState> class exists with State property, StateObservable, and Dispatch method
- All code compiles without warnings
- Existing ChatStateManager unchanged and functional
</success_criteria>

<output>
After completion, create `.planning/phases/01-state-foundation/01-01-SUMMARY.md`
</output>
