---
phase: 01-state-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - WebChat.Client/State/Selector.cs
autonomous: true

must_haves:
  truths:
    - "Developer can create memoized selectors that cache derived state"
    - "Selector returns cached value when input state reference unchanged"
    - "Selector recomputes value only when input state changes"
    - "Selectors can be composed (selector from selector)"
  artifacts:
    - path: "WebChat.Client/State/Selector.cs"
      provides: "Memoized selector infrastructure"
      exports: ["Selector", "Selector<TState, TResult>"]
  key_links:
    - from: "WebChat.Client/State/Selector.cs"
      to: "WebChat.Client/State/Store.cs"
      via: "Operates on Store<TState>.State"
      pattern: "Func<TState, TResult>"
---

<objective>
Create memoized selector infrastructure for deriving state with automatic caching.

Purpose: Selectors compute derived state (e.g., filtered lists, computed properties) and cache results until underlying state changes. This prevents redundant computation and enables efficient state projections.

Output: `Selector.cs` in `WebChat.Client/State/` with generic `Selector<TState, TResult>` class.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-state-foundation/01-RESEARCH.md
@WebChat.Client/State/Store.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memoized Selector class</name>
  <files>WebChat.Client/State/Selector.cs</files>
  <action>
Create `WebChat.Client/State/Selector.cs`:

```csharp
namespace WebChat.Client.State;

/// <summary>
/// Memoized selector for deriving state.
/// Caches the computed result and only recomputes when input state reference changes.
/// </summary>
/// <typeparam name="TState">The input state type</typeparam>
/// <typeparam name="TResult">The derived result type</typeparam>
public sealed class Selector<TState, TResult> where TState : class
{
    private readonly Func<TState, TResult> _projector;
    private TState? _lastState;
    private TResult? _cachedResult;
    private bool _hasValue;

    public Selector(Func<TState, TResult> projector)
    {
        ArgumentNullException.ThrowIfNull(projector);
        _projector = projector;
    }

    /// <summary>
    /// Get the derived value for the given state.
    /// Returns cached result if state reference is unchanged.
    /// </summary>
    public TResult Select(TState state)
    {
        ArgumentNullException.ThrowIfNull(state);

        // Reference equality check - records create new instances on mutation
        if (_hasValue && ReferenceEquals(_lastState, state))
        {
            return _cachedResult!;
        }

        _lastState = state;
        _cachedResult = _projector(state);
        _hasValue = true;
        return _cachedResult;
    }

    /// <summary>
    /// Invalidate the cached value, forcing recomputation on next Select.
    /// </summary>
    public void Invalidate()
    {
        _lastState = null;
        _cachedResult = default;
        _hasValue = false;
    }
}

/// <summary>
/// Factory methods for creating selectors.
/// </summary>
public static class Selector
{
    /// <summary>
    /// Create a memoized selector from a projection function.
    /// </summary>
    /// <example>
    /// var topicCountSelector = Selector.Create((TopicsState s) => s.Topics.Count);
    /// int count = topicCountSelector.Select(store.State);
    /// </example>
    public static Selector<TState, TResult> Create<TState, TResult>(
        Func<TState, TResult> projector) where TState : class
        => new(projector);

    /// <summary>
    /// Create a composed selector that derives from another selector's output.
    /// </summary>
    /// <example>
    /// var topicsSelector = Selector.Create((TopicsState s) => s.Topics);
    /// var activeTopicsSelector = Selector.Compose(
    ///     topicsSelector,
    ///     topics => topics.Where(t => t.IsActive).ToList()
    /// );
    /// </example>
    public static Selector<TState, TFinal> Compose<TState, TIntermediate, TFinal>(
        Selector<TState, TIntermediate> first,
        Func<TIntermediate, TFinal> second) where TState : class
    {
        // Compose into a single selector - memoization happens at the final level
        return new Selector<TState, TFinal>(state =>
        {
            var intermediate = first.Select(state);
            return second(intermediate);
        });
    }
}
```

Design decisions:
- Reference equality (`ReferenceEquals`) is used because C# records create new instances on `with` mutations
- When state hasn't changed (same reference), cached value is returned without invoking the projector
- Static `Selector` class provides factory methods for cleaner syntax
- `Compose` enables building selector chains without exposing intermediate values
- `Invalidate()` allows forced cache refresh if needed (rare, but useful for testing)

Usage pattern (for Phase 2 feature stores):
```csharp
// Define selector once
private static readonly Selector<TopicsState, int> _topicCountSelector =
    Selector.Create((TopicsState s) => s.Topics.Count);

// Use in component
var count = _topicCountSelector.Select(_topicsStore.State);
```
  </action>
  <verify>
1. `dotnet build WebChat.Client` compiles without errors
2. Write a quick inline test in a scratch file:
   ```csharp
   // Test memoization
   record TestState(int Value);
   var selector = Selector.Create((TestState s) => s.Value * 2);
   var state = new TestState(5);
   var result1 = selector.Select(state);  // Computes: 10
   var result2 = selector.Select(state);  // Returns cached: 10 (same reference)
   var newState = state with { Value = 6 };
   var result3 = selector.Select(newState);  // Recomputes: 12 (different reference)
   ```
3. Verify the three scenarios work as expected
  </verify>
  <done>Selector<TState, TResult> exists with memoization via reference equality, factory methods, and composition support</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for Selector memoization</name>
  <files>Tests/Unit/WebChat.Client/State/SelectorTests.cs</files>
  <action>
Create `Tests/Unit/WebChat.Client/State/SelectorTests.cs`:

```csharp
using WebChat.Client.State;

namespace Tests.Unit.WebChat.Client.State;

public class SelectorTests
{
    private sealed record TestState(int Value, string Name);

    [Fact]
    public void Select_ReturnsCachedValue_WhenStateUnchanged()
    {
        // Arrange
        var computeCount = 0;
        var selector = Selector.Create((TestState s) =>
        {
            computeCount++;
            return s.Value * 2;
        });
        var state = new TestState(5, "test");

        // Act
        var result1 = selector.Select(state);
        var result2 = selector.Select(state);

        // Assert
        Assert.Equal(10, result1);
        Assert.Equal(10, result2);
        Assert.Equal(1, computeCount); // Only computed once
    }

    [Fact]
    public void Select_RecomputesValue_WhenStateChanges()
    {
        // Arrange
        var computeCount = 0;
        var selector = Selector.Create((TestState s) =>
        {
            computeCount++;
            return s.Value * 2;
        });
        var state1 = new TestState(5, "test");
        var state2 = state1 with { Value = 10 };

        // Act
        var result1 = selector.Select(state1);
        var result2 = selector.Select(state2);

        // Assert
        Assert.Equal(10, result1);
        Assert.Equal(20, result2);
        Assert.Equal(2, computeCount); // Computed twice
    }

    [Fact]
    public void Invalidate_ForcesRecomputation()
    {
        // Arrange
        var computeCount = 0;
        var selector = Selector.Create((TestState s) =>
        {
            computeCount++;
            return s.Value;
        });
        var state = new TestState(5, "test");

        // Act
        selector.Select(state);
        selector.Invalidate();
        selector.Select(state);

        // Assert
        Assert.Equal(2, computeCount);
    }

    [Fact]
    public void Compose_CombinesSelectors()
    {
        // Arrange
        var firstSelector = Selector.Create((TestState s) => s.Value);
        var composedSelector = Selector.Compose(firstSelector, v => v * 3);
        var state = new TestState(4, "test");

        // Act
        var result = composedSelector.Select(state);

        // Assert
        Assert.Equal(12, result);
    }
}
```

This verifies:
1. Memoization works (same state reference = cached value)
2. Recomputation on state change (different reference)
3. Invalidate forces recomputation
4. Composition works correctly
  </action>
  <verify>`dotnet test --filter "FullyQualifiedName~SelectorTests"` passes all 4 tests</verify>
  <done>Unit tests verify Selector memoization behavior</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build WebChat.Client` succeeds
2. `WebChat.Client/State/Selector.cs` exists with memoization logic
3. `dotnet test --filter "FullyQualifiedName~SelectorTests"` passes
4. Selectors cache values correctly (verified by tests)
</verification>

<success_criteria>
- Selector<TState, TResult> class exists with memoization
- Factory methods Selector.Create and Selector.Compose exist
- Memoization uses reference equality (correct for C# records)
- Unit tests pass verifying memoization behavior
- All code compiles without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-state-foundation/01-03-SUMMARY.md`
</output>
