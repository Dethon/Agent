---
phase: 01-state-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/State/IDispatcher.cs
  - WebChat.Client/State/Dispatcher.cs
  - WebChat.Client/State/StoreSubscriberComponent.cs
  - WebChat.Client/Program.cs
autonomous: true

must_haves:
  truths:
    - "Components can dispatch actions via IDispatcher without knowing specific stores"
    - "StoreSubscriberComponent automatically manages subscription lifecycle"
    - "Subscriptions are disposed when component is disposed"
    - "StateHasChanged is marshaled to Blazor sync context via InvokeAsync"
  artifacts:
    - path: "WebChat.Client/State/IDispatcher.cs"
      provides: "Dispatcher contract"
      exports: ["IDispatcher"]
    - path: "WebChat.Client/State/Dispatcher.cs"
      provides: "Action dispatch implementation"
      exports: ["Dispatcher"]
    - path: "WebChat.Client/State/StoreSubscriberComponent.cs"
      provides: "Base component with auto-subscription"
      exports: ["StoreSubscriberComponent"]
    - path: "WebChat.Client/Program.cs"
      provides: "DI registration for dispatcher"
      contains: "AddScoped<IDispatcher"
  key_links:
    - from: "WebChat.Client/State/StoreSubscriberComponent.cs"
      to: "System.Reactive"
      via: "CompositeDisposable"
      pattern: "CompositeDisposable"
    - from: "WebChat.Client/State/StoreSubscriberComponent.cs"
      to: "Microsoft.AspNetCore.Components"
      via: "ComponentBase inheritance"
      pattern: "ComponentBase"
    - from: "WebChat.Client/Program.cs"
      to: "WebChat.Client/State/Dispatcher.cs"
      via: "DI registration"
      pattern: "AddScoped.*Dispatcher"
---

<objective>
Create dispatch and subscription infrastructure: IDispatcher service for decoupled action dispatch, and StoreSubscriberComponent base class for automatic subscription lifecycle management.

Purpose: Components need a way to dispatch actions without coupling to specific stores, and a base class that handles the common pattern of subscribing to state and cleaning up on disposal.

Output: `IDispatcher.cs`, `Dispatcher.cs`, `StoreSubscriberComponent.cs` in `WebChat.Client/State/`, updated DI registration in `Program.cs`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-state-foundation/01-RESEARCH.md
@WebChat.Client/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IDispatcher interface and Dispatcher implementation</name>
  <files>WebChat.Client/State/IDispatcher.cs, WebChat.Client/State/Dispatcher.cs</files>
  <action>
Create `WebChat.Client/State/IDispatcher.cs`:

```csharp
namespace WebChat.Client.State;

/// <summary>
/// Dispatches actions to registered handlers.
/// Components inject this to dispatch actions without knowing specific stores.
/// </summary>
public interface IDispatcher
{
    void Dispatch<TAction>(TAction action) where TAction : IAction;
}
```

Create `WebChat.Client/State/Dispatcher.cs`:

```csharp
namespace WebChat.Client.State;

/// <summary>
/// Routes actions to registered handlers.
/// In Phase 1, this is a simple implementation. Middleware support can be added later.
/// </summary>
public sealed class Dispatcher : IDispatcher
{
    private readonly Dictionary<Type, Action<IAction>> _handlers = new();

    /// <summary>
    /// Register a handler for a specific action type.
    /// Called during store initialization to wire up reducers.
    /// </summary>
    public void RegisterHandler<TAction>(Action<TAction> handler) where TAction : IAction
    {
        _handlers[typeof(TAction)] = action => handler((TAction)action);
    }

    /// <summary>
    /// Dispatch an action to its registered handler.
    /// No-op if no handler registered (fail-safe for optional handlers).
    /// </summary>
    public void Dispatch<TAction>(TAction action) where TAction : IAction
    {
        ArgumentNullException.ThrowIfNull(action);

        if (_handlers.TryGetValue(typeof(TAction), out var handler))
        {
            handler(action);
        }
    }
}
```

Design notes:
- IDispatcher is the injection interface; Dispatcher is concrete for registration
- RegisterHandler is on concrete Dispatcher (not interface) - only store setup code needs it
- Dispatch is safe to call even if no handler registered (Phase 2 adds feature stores)
- Type-based routing enables multiple stores handling different action types
  </action>
  <verify>`dotnet build WebChat.Client` compiles. Can construct Dispatcher, register handler, dispatch action.</verify>
  <done>IDispatcher and Dispatcher exist for decoupled action dispatch</done>
</task>

<task type="auto">
  <name>Task 2: Create StoreSubscriberComponent base class</name>
  <files>WebChat.Client/State/StoreSubscriberComponent.cs</files>
  <action>
Create `WebChat.Client/State/StoreSubscriberComponent.cs`:

```csharp
using System.Reactive.Disposables;
using System.Reactive.Linq;
using Microsoft.AspNetCore.Components;

namespace WebChat.Client.State;

/// <summary>
/// Base component that manages IObservable subscriptions with automatic disposal.
/// Components inherit this to subscribe to store state with proper lifecycle management.
/// </summary>
public abstract class StoreSubscriberComponent : ComponentBase, IDisposable
{
    private readonly CompositeDisposable _subscriptions = new();
    private bool _disposed;

    /// <summary>
    /// Subscribe to an observable and re-render on each emission.
    /// Subscription is automatically disposed when component is disposed.
    /// </summary>
    protected void Subscribe<T>(IObservable<T> observable, Action<T> onNext)
    {
        var subscription = observable.Subscribe(value =>
        {
            InvokeAsync(() =>
            {
                if (_disposed) return;
                onNext(value);
                StateHasChanged();
            });
        });
        _subscriptions.Add(subscription);
    }

    /// <summary>
    /// Subscribe with a selector - only re-render when selected value changes.
    /// Uses DistinctUntilChanged to prevent unnecessary re-renders.
    /// </summary>
    protected void Subscribe<TState, TSelected>(
        IObservable<TState> stateObservable,
        Func<TState, TSelected> selector,
        Action<TSelected> onNext)
    {
        var subscription = stateObservable
            .Select(selector)
            .DistinctUntilChanged()
            .Subscribe(value =>
            {
                InvokeAsync(() =>
                {
                    if (_disposed) return;
                    onNext(value);
                    StateHasChanged();
                });
            });
        _subscriptions.Add(subscription);
    }

    /// <summary>
    /// Subscribe with a selector and custom equality comparer.
    /// Use when default equality is insufficient (e.g., comparing collections).
    /// </summary>
    protected void Subscribe<TState, TSelected>(
        IObservable<TState> stateObservable,
        Func<TState, TSelected> selector,
        IEqualityComparer<TSelected> comparer,
        Action<TSelected> onNext)
    {
        var subscription = stateObservable
            .Select(selector)
            .DistinctUntilChanged(comparer)
            .Subscribe(value =>
            {
                InvokeAsync(() =>
                {
                    if (_disposed) return;
                    onNext(value);
                    StateHasChanged();
                });
            });
        _subscriptions.Add(subscription);
    }

    public virtual void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        _subscriptions.Dispose();
        GC.SuppressFinalize(this);
    }
}
```

Critical patterns:
- `InvokeAsync` wraps ALL callbacks - required because IObservable may fire from any thread
- `_disposed` check prevents StateHasChanged after disposal (common source of exceptions)
- `CompositeDisposable` collects all subscriptions for single Dispose call
- `DistinctUntilChanged` in selector overload prevents re-renders when selected slice unchanged
- `virtual Dispose()` allows derived components to add cleanup while preserving base behavior
  </action>
  <verify>`dotnet build WebChat.Client` compiles. StoreSubscriberComponent is inheritable by Razor components.</verify>
  <done>StoreSubscriberComponent base class exists with Subscribe overloads and automatic disposal</done>
</task>

<task type="auto">
  <name>Task 3: Register Dispatcher in DI container</name>
  <files>WebChat.Client/Program.cs</files>
  <action>
Update `WebChat.Client/Program.cs` to register the Dispatcher:

Add using statement at top:
```csharp
using WebChat.Client.State;
```

Add registration in the services section (after existing state management registrations):
```csharp
// State infrastructure (Phase 1)
builder.Services.AddScoped<Dispatcher>();
builder.Services.AddScoped<IDispatcher>(sp => sp.GetRequiredService<Dispatcher>());
```

Note: Register Dispatcher as concrete type AND as IDispatcher interface. This allows:
- Components inject IDispatcher (decoupled)
- Store setup code can inject Dispatcher directly to call RegisterHandler

Place this registration near the existing "// State management" comment block for logical grouping.
  </action>
  <verify>`dotnet build WebChat.Client` compiles. `dotnet run --project WebChat` starts without DI errors (Dispatcher is resolvable).</verify>
  <done>Dispatcher registered in DI container as both concrete type and IDispatcher interface</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build WebChat.Client` succeeds
2. `WebChat.Client/State/` folder contains `IDispatcher.cs`, `Dispatcher.cs`, `StoreSubscriberComponent.cs`
3. Program.cs registers Dispatcher in DI
4. Application starts without DI resolution errors
5. Existing functionality unchanged (ChatStateManager still works)
</verification>

<success_criteria>
- IDispatcher interface and Dispatcher implementation exist
- StoreSubscriberComponent base class exists with Subscribe methods and auto-disposal
- Dispatcher is registered in DI (both concrete and interface)
- All code compiles without warnings
- Existing ChatStateManager and components unchanged and functional
</success_criteria>

<output>
After completion, create `.planning/phases/01-state-foundation/01-02-SUMMARY.md`
</output>
