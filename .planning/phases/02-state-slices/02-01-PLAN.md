---
phase: 02-state-slices
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/State/Topics/TopicsState.cs
  - WebChat.Client/State/Topics/TopicsActions.cs
  - WebChat.Client/State/Topics/TopicsReducers.cs
  - WebChat.Client/State/Topics/TopicsStore.cs
  - WebChat.Client/State/Topics/TopicsSelectors.cs
  - WebChat.Client/State/Messages/MessagesState.cs
  - WebChat.Client/State/Messages/MessagesActions.cs
  - WebChat.Client/State/Messages/MessagesReducers.cs
  - WebChat.Client/State/Messages/MessagesStore.cs
  - WebChat.Client/State/Messages/MessagesSelectors.cs
autonomous: true

must_haves:
  truths:
    - "Developer can dispatch TopicsLoaded and observe topics list change"
    - "Developer can dispatch SelectTopic and observe selectedTopicId change"
    - "Developer can dispatch MessagesLoaded and observe messages for a topic"
    - "Developer can dispatch AddMessage and observe message appended to topic"
    - "TopicsState subscribers not triggered by MessagesState changes"
    - "MessagesState subscribers not triggered by TopicsState changes"
  artifacts:
    - path: "WebChat.Client/State/Topics/TopicsState.cs"
      provides: "Immutable record for topic list and selection"
      contains: "sealed record TopicsState"
    - path: "WebChat.Client/State/Topics/TopicsActions.cs"
      provides: "Action records for topics"
      contains: "record TopicsLoaded"
    - path: "WebChat.Client/State/Topics/TopicsReducers.cs"
      provides: "Pure reducer functions"
      contains: "static class TopicsReducers"
    - path: "WebChat.Client/State/Topics/TopicsStore.cs"
      provides: "Store wrapper with handler registration"
      contains: "sealed class TopicsStore"
    - path: "WebChat.Client/State/Messages/MessagesState.cs"
      provides: "Immutable record for messages by topic"
      contains: "sealed record MessagesState"
    - path: "WebChat.Client/State/Messages/MessagesActions.cs"
      provides: "Action records for messages"
      contains: "record MessagesLoaded"
    - path: "WebChat.Client/State/Messages/MessagesReducers.cs"
      provides: "Pure reducer functions"
      contains: "static class MessagesReducers"
    - path: "WebChat.Client/State/Messages/MessagesStore.cs"
      provides: "Store wrapper with handler registration"
      contains: "sealed class MessagesStore"
  key_links:
    - from: "TopicsStore"
      to: "Dispatcher"
      via: "RegisterHandler in constructor"
      pattern: "dispatcher\\.RegisterHandler"
    - from: "MessagesStore"
      to: "Dispatcher"
      via: "RegisterHandler in constructor"
      pattern: "dispatcher\\.RegisterHandler"
    - from: "TopicsReducers"
      to: "TopicsState"
      via: "Pattern matching on actions"
      pattern: "action switch"
---

<objective>
Create TopicsState and MessagesState slices with their stores, actions, reducers, and selectors.

Purpose: Enable topic management (list, selection, agents) and message storage (per-topic history) as independent state slices that don't cross-trigger notifications.

Output: Two complete state slices ready for component consumption in `WebChat.Client/State/Topics/` and `WebChat.Client/State/Messages/`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-slices/02-CONTEXT.md
@.planning/phases/02-state-slices/02-RESEARCH.md

# Phase 1 infrastructure (available)
@WebChat.Client/State/Store.cs
@WebChat.Client/State/Dispatcher.cs
@WebChat.Client/State/IDispatcher.cs
@WebChat.Client/State/IAction.cs
@WebChat.Client/State/Selector.cs

# Existing models to reference
@WebChat.Client/Models/StoredTopic.cs
@WebChat.Client/Models/ChatMessageModel.cs
@Domain/DTOs/WebChat/AgentInfo.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TopicsState slice</name>
  <files>
    WebChat.Client/State/Topics/TopicsState.cs
    WebChat.Client/State/Topics/TopicsActions.cs
    WebChat.Client/State/Topics/TopicsReducers.cs
    WebChat.Client/State/Topics/TopicsStore.cs
    WebChat.Client/State/Topics/TopicsSelectors.cs
  </files>
  <action>
Create the Topics state slice following the pattern from 02-RESEARCH.md:

**TopicsState.cs:**
- Sealed record with: `Topics` (IReadOnlyList<StoredTopic>), `SelectedTopicId` (string?), `Agents` (IReadOnlyList<AgentInfo>), `SelectedAgentId` (string?), `IsLoading` (bool), `Error` (string?)
- Static `Initial` property returning default state with empty collections
- Store only `SelectedTopicId`, not full `StoredTopic` (per CONTEXT.md decision)

**TopicsActions.cs:**
- All actions implement `IAction` marker interface
- Actions: `LoadTopics`, `TopicsLoaded(IReadOnlyList<StoredTopic>)`, `SelectTopic(string?)`, `AddTopic(StoredTopic)`, `UpdateTopic(StoredTopic)`, `RemoveTopic(string)`, `SetAgents(IReadOnlyList<AgentInfo>)`, `SelectAgent(string)`, `TopicsError(string)`
- Use Verb+Noun naming convention (per CONTEXT.md)

**TopicsReducers.cs:**
- Static class with `Reduce(TopicsState state, IAction action)` method
- Pattern match on action types using switch expression
- Create new collections on mutation (never mutate existing)
- Error auto-clears on successful actions (per CONTEXT.md)
- Return `state` unchanged for unhandled actions

**TopicsStore.cs:**
- Sealed class wrapping `Store<TopicsState>`
- Constructor takes `Dispatcher` (not IDispatcher - stores need RegisterHandler)
- Register handler for each action type, calling `_store.Dispatch(action, TopicsReducers.Reduce)`
- Expose `State` and `StateObservable` properties
- Implement `IDisposable` to dispose inner store

**TopicsSelectors.cs:**
- Static class with selector factories
- `SelectedTopic` - derives full StoredTopic from SelectedTopicId
- `TopicsForAgent` - filters topics by SelectedAgentId
- Use `Selector.Create<TopicsState, TResult>` factory
  </action>
  <verify>
Files compile: `dotnet build WebChat.Client`
  </verify>
  <done>
TopicsState slice exists with state record, 9 action types, reducer with pattern matching, store with handler registration, and selectors for derived state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MessagesState slice</name>
  <files>
    WebChat.Client/State/Messages/MessagesState.cs
    WebChat.Client/State/Messages/MessagesActions.cs
    WebChat.Client/State/Messages/MessagesReducers.cs
    WebChat.Client/State/Messages/MessagesStore.cs
    WebChat.Client/State/Messages/MessagesSelectors.cs
  </files>
  <action>
Create the Messages state slice following the pattern from 02-RESEARCH.md:

**MessagesState.cs:**
- Sealed record with: `MessagesByTopic` (IReadOnlyDictionary<string, IReadOnlyList<ChatMessageModel>>), `LoadedTopics` (IReadOnlySet<string>)
- Static `Initial` property returning default state with empty dictionary and set
- Messages normalized by TopicId for O(1) topic switching (per CONTEXT.md)

**MessagesActions.cs:**
- Fine-grained actions per CONTEXT.md decision
- Actions: `LoadMessages(string TopicId)`, `MessagesLoaded(string TopicId, IReadOnlyList<ChatMessageModel>)`, `AddMessage(string TopicId, ChatMessageModel)`, `UpdateMessage(string TopicId, string MessageId, ChatMessageModel)`, `RemoveLastMessage(string TopicId)`, `ClearMessages(string TopicId)`
- All implement `IAction`

**MessagesReducers.cs:**
- Static class with `Reduce(MessagesState state, IAction action)` method
- Pattern match on action types
- For dictionary mutations, create new Dictionary from existing: `new Dictionary<...>(state.MessagesByTopic) { [topicId] = newMessages }`
- For set mutations, create new HashSet from existing: `new HashSet<string>(state.LoadedTopics) { topicId }`
- Return `state` unchanged for unhandled actions

**MessagesStore.cs:**
- Sealed class wrapping `Store<MessagesState>`
- Constructor takes `Dispatcher`
- Register handler for each action type
- Expose `State` and `StateObservable` properties
- Implement `IDisposable`

**MessagesSelectors.cs:**
- Static class with selector factories
- `MessagesForTopic(string topicId)` - factory returning selector for specific topic's messages
- `HasMessagesForTopic(string topicId)` - factory returning selector for loaded check
- `MessageCount(string topicId)` - factory returning selector for message count
  </action>
  <verify>
Files compile: `dotnet build WebChat.Client`
  </verify>
  <done>
MessagesState slice exists with state record, 6 action types, reducer with immutable dictionary/set mutations, store with handler registration, and selectors for per-topic queries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for TopicsStore and MessagesStore</name>
  <files>
    Tests/Unit/WebChat.Client/State/TopicsStoreTests.cs
    Tests/Unit/WebChat.Client/State/MessagesStoreTests.cs
  </files>
  <action>
Create unit tests verifying store behavior:

**TopicsStoreTests.cs:**
- Test `TopicsLoaded` action updates Topics list
- Test `SelectTopic` action updates SelectedTopicId
- Test `AddTopic` action appends to Topics list
- Test `RemoveTopic` action removes from Topics list
- Test `TopicsError` action sets Error and clears IsLoading
- Test error auto-clears on successful `TopicsLoaded`
- Test unhandled action returns state unchanged
- Test `StateObservable` emits on dispatch

**MessagesStoreTests.cs:**
- Test `MessagesLoaded` action populates MessagesByTopic for specific topic
- Test `AddMessage` action appends to existing topic's messages
- Test `AddMessage` action creates list for new topic
- Test `ClearMessages` action removes topic's messages
- Test `LoadedTopics` tracks loaded topic IDs
- Test different topics have independent message lists
- Test `StateObservable` emits on dispatch

Use xUnit, create `Dispatcher` and store in each test setup. Verify state after dispatch.
  </action>
  <verify>
Tests pass: `dotnet test --filter "TopicsStoreTests|MessagesStoreTests"`
  </verify>
  <done>
Unit tests verify TopicsStore handles 9 action types correctly and MessagesStore handles 6 action types with proper dictionary/set immutability.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build WebChat.Client` - compiles without errors
2. `dotnet test --filter "TopicsStoreTests|MessagesStoreTests"` - all tests pass
3. Verify no cross-store dependencies (TopicsStore doesn't reference MessagesStore and vice versa)
4. Verify all reducers create new collections (grep for `new Dictionary`, `new HashSet`, `.ToList()`)
</verification>

<success_criteria>
- TopicsState slice: 5 files, store registers 9 action handlers
- MessagesState slice: 5 files, store registers 6 action handlers
- All reducers use immutable patterns (new collections, not mutations)
- Stores are independent (no cross-references)
- Unit tests pass for both stores
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-slices/02-01-SUMMARY.md`
</output>
