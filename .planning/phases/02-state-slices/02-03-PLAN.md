---
phase: 02-state-slices
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/State/Approval/ApprovalState.cs
  - WebChat.Client/State/Approval/ApprovalActions.cs
  - WebChat.Client/State/Approval/ApprovalReducers.cs
  - WebChat.Client/State/Approval/ApprovalStore.cs
  - WebChat.Client/Program.cs
autonomous: true

must_haves:
  truths:
    - "Developer can dispatch ShowApproval and observe pending approval request"
    - "Developer can dispatch ApprovalResolved and observe approval cleared"
    - "ApprovalState tracks which topic the approval belongs to"
    - "All 5 stores registered in DI container"
    - "All 5 stores can be injected into components"
  artifacts:
    - path: "WebChat.Client/State/Approval/ApprovalState.cs"
      provides: "Immutable record for approval modal state"
      contains: "sealed record ApprovalState"
    - path: "WebChat.Client/State/Approval/ApprovalActions.cs"
      provides: "Action records for approval flow"
      contains: "record ShowApproval"
    - path: "WebChat.Client/State/Approval/ApprovalReducers.cs"
      provides: "Pure reducer functions"
      contains: "static class ApprovalReducers"
    - path: "WebChat.Client/State/Approval/ApprovalStore.cs"
      provides: "Store wrapper with handler registration"
      contains: "sealed class ApprovalStore"
    - path: "WebChat.Client/Program.cs"
      provides: "DI registration for all 5 stores"
      contains: "AddScoped<TopicsStore>"
  key_links:
    - from: "ApprovalStore"
      to: "Dispatcher"
      via: "RegisterHandler in constructor"
      pattern: "dispatcher\\.RegisterHandler"
    - from: "Program.cs"
      to: "All stores"
      via: "AddScoped registration"
      pattern: "AddScoped<.*Store>"
---

<objective>
Create ApprovalState slice and register all 5 feature stores in DI.

Purpose: Enable tool approval modal state management and complete the Phase 2 infrastructure by making all stores injectable into components.

Output: ApprovalState slice in `WebChat.Client/State/Approval/` and updated `Program.cs` with all store registrations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-slices/02-CONTEXT.md
@.planning/phases/02-state-slices/02-RESEARCH.md

# Phase 1 infrastructure (available)
@WebChat.Client/State/Store.cs
@WebChat.Client/State/Dispatcher.cs
@WebChat.Client/State/IDispatcher.cs
@WebChat.Client/State/IAction.cs

# Existing approval types to reference
@Domain/DTOs/ToolApprovalRequestMessage.cs
@Domain/DTOs/ToolApprovalRequest.cs
@WebChat.Client/Services/ApprovalService.cs

# Program.cs for DI registration
@WebChat.Client/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ApprovalState slice</name>
  <files>
    WebChat.Client/State/Approval/ApprovalState.cs
    WebChat.Client/State/Approval/ApprovalActions.cs
    WebChat.Client/State/Approval/ApprovalReducers.cs
    WebChat.Client/State/Approval/ApprovalStore.cs
  </files>
  <action>
Create the Approval state slice following the pattern from 02-RESEARCH.md:

**ApprovalState.cs:**
```csharp
public sealed record ApprovalState
{
    public ToolApprovalRequestMessage? CurrentRequest { get; init; }
    public string? TopicId { get; init; }
    public bool IsResponding { get; init; }

    public static ApprovalState Initial => new();
}
```

- Simple state: request present or not
- TopicId tracks which topic the approval belongs to
- IsResponding for UI feedback during async response
- Reference `Domain.DTOs.ToolApprovalRequestMessage` (do not duplicate the type)

**ApprovalActions.cs:**
- `ShowApproval(string TopicId, ToolApprovalRequestMessage Request)` - show modal with approval request
- `ApprovalResponding` - user clicked approve/reject, waiting for server
- `ApprovalResolved(string ApprovalId, string? ToolCalls)` - approval complete, clear modal
- `ClearApproval` - dismiss modal without response (cancel)
- All implement `IAction`

**ApprovalReducers.cs:**
- Static class with `Reduce(ApprovalState state, IAction action)` method
- `ShowApproval`: Set CurrentRequest, TopicId, IsResponding=false
- `ApprovalResponding`: Set IsResponding=true
- `ApprovalResolved`: Clear all (return Initial state)
- `ClearApproval`: Clear all (return Initial state)

**ApprovalStore.cs:**
- Sealed class wrapping `Store<ApprovalState>`
- Constructor takes `Dispatcher`, registers handlers for all 4 action types
- Expose `State` and `StateObservable` properties
- Implement `IDisposable`
  </action>
  <verify>
Files compile: `dotnet build WebChat.Client`
  </verify>
  <done>
ApprovalState slice exists with state record, 4 action types, simple reducer, and store with handler registration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register all stores in DI and add unit tests</name>
  <files>
    WebChat.Client/Program.cs
    Tests/Unit/WebChat.Client/State/ApprovalStoreTests.cs
  </files>
  <action>
**Program.cs:**
Add DI registrations for all 5 feature stores. Find the existing `AddScoped<Dispatcher>` and `AddScoped<IDispatcher>` registrations (from Phase 1) and add after them:

```csharp
// State stores (Phase 2)
builder.Services.AddScoped<TopicsStore>();
builder.Services.AddScoped<MessagesStore>();
builder.Services.AddScoped<StreamingStore>();
builder.Services.AddScoped<ConnectionStore>();
builder.Services.AddScoped<ApprovalStore>();
```

Add necessary using statements:
```csharp
using WebChat.Client.State.Topics;
using WebChat.Client.State.Messages;
using WebChat.Client.State.Streaming;
using WebChat.Client.State.Connection;
using WebChat.Client.State.Approval;
```

**ApprovalStoreTests.cs:**
- Test `ShowApproval` sets CurrentRequest and TopicId
- Test `ShowApproval` sets IsResponding=false
- Test `ApprovalResponding` sets IsResponding=true
- Test `ApprovalResolved` clears all state (returns to Initial)
- Test `ClearApproval` clears all state (returns to Initial)
- Test `StateObservable` emits on dispatch

Use xUnit, create `Dispatcher` and store in each test setup.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
Tests pass: `dotnet test --filter "ApprovalStoreTests"`
  </verify>
  <done>
All 5 feature stores registered in DI container. ApprovalStore unit tests verify modal show/respond/resolve/clear cycle.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify complete Phase 2 infrastructure</name>
  <files>
    (verification only, no file changes)
  </files>
  <action>
Run comprehensive verification of Phase 2 deliverables:

1. **Build verification:**
   ```bash
   dotnet build WebChat.Client
   ```

2. **Test verification:**
   ```bash
   dotnet test --filter "TopicsStoreTests|MessagesStoreTests|StreamingStoreTests|ConnectionStoreTests|ApprovalStoreTests"
   ```

3. **Structure verification:**
   Confirm all expected files exist:
   - `WebChat.Client/State/Topics/` - 5 files (State, Actions, Reducers, Store, Selectors)
   - `WebChat.Client/State/Messages/` - 5 files (State, Actions, Reducers, Store, Selectors)
   - `WebChat.Client/State/Streaming/` - 4 files (State, Actions, Reducers, Store)
   - `WebChat.Client/State/Connection/` - 4 files (State, Actions, Reducers, Store)
   - `WebChat.Client/State/Approval/` - 4 files (State, Actions, Reducers, Store)

4. **Independence verification:**
   Confirm stores don't reference each other:
   - TopicsStore.cs should not contain "MessagesStore", "StreamingStore", etc.
   - Each store only depends on Dispatcher and its own state types

5. **Immutability verification:**
   Grep reducers for proper patterns:
   - `new Dictionary<` or `new HashSet<` for collection mutations
   - `state with {` for record updates
   - No direct collection mutations like `.Add(`, `.Remove(`
  </action>
  <verify>
All checks pass with zero errors.
  </verify>
  <done>
Phase 2 complete: 5 state slices (22 files total), all stores independent, all reducers immutable, all tests passing, all stores registered in DI.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` - full solution compiles
2. `dotnet test` - all state store tests pass
3. Each store directory contains expected files
4. No cross-store references (stores are independent)
5. All reducers use immutable patterns
6. Program.cs contains all 5 store registrations
</verification>

<success_criteria>
- ApprovalState slice: 4 files, store registers 4 action handlers
- Program.cs registers all 5 stores (TopicsStore, MessagesStore, StreamingStore, ConnectionStore, ApprovalStore)
- All 5 stores can be injected (verified by successful build)
- Unit tests pass for ApprovalStore
- Phase 2 requirements met: SLICE-01 through SLICE-05
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-slices/02-03-SUMMARY.md`
</output>
