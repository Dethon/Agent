---
phase: 02-state-slices
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/State/Streaming/StreamingState.cs
  - WebChat.Client/State/Streaming/StreamingActions.cs
  - WebChat.Client/State/Streaming/StreamingReducers.cs
  - WebChat.Client/State/Streaming/StreamingStore.cs
  - WebChat.Client/State/Connection/ConnectionState.cs
  - WebChat.Client/State/Connection/ConnectionActions.cs
  - WebChat.Client/State/Connection/ConnectionReducers.cs
  - WebChat.Client/State/Connection/ConnectionStore.cs
autonomous: true

must_haves:
  truths:
    - "Developer can dispatch StreamStarted and observe topic added to streaming set"
    - "Developer can dispatch StreamChunk and observe content accumulated"
    - "Developer can dispatch StreamCompleted and observe streaming cleared for topic"
    - "Developer can dispatch ConnectionStatusChanged and observe status update"
    - "ConnectionState reflects accurate SignalR status enum"
    - "StreamingState tracks per-topic streaming content"
  artifacts:
    - path: "WebChat.Client/State/Streaming/StreamingState.cs"
      provides: "Immutable record for streaming content by topic"
      contains: "sealed record StreamingState"
    - path: "WebChat.Client/State/Streaming/StreamingActions.cs"
      provides: "Action records for streaming events"
      contains: "record StreamChunk"
    - path: "WebChat.Client/State/Streaming/StreamingReducers.cs"
      provides: "Pure reducer functions with content accumulation"
      contains: "static class StreamingReducers"
    - path: "WebChat.Client/State/Streaming/StreamingStore.cs"
      provides: "Store wrapper with handler registration"
      contains: "sealed class StreamingStore"
    - path: "WebChat.Client/State/Connection/ConnectionState.cs"
      provides: "Immutable record for connection status"
      contains: "sealed record ConnectionState"
    - path: "WebChat.Client/State/Connection/ConnectionActions.cs"
      provides: "Action records for connection events"
      contains: "record ConnectionStatusChanged"
    - path: "WebChat.Client/State/Connection/ConnectionReducers.cs"
      provides: "Pure reducer functions"
      contains: "static class ConnectionReducers"
    - path: "WebChat.Client/State/Connection/ConnectionStore.cs"
      provides: "Store wrapper with handler registration"
      contains: "sealed class ConnectionStore"
  key_links:
    - from: "StreamingStore"
      to: "Dispatcher"
      via: "RegisterHandler in constructor"
      pattern: "dispatcher\\.RegisterHandler"
    - from: "ConnectionStore"
      to: "Dispatcher"
      via: "RegisterHandler in constructor"
      pattern: "dispatcher\\.RegisterHandler"
    - from: "StreamingReducers.StreamChunk"
      to: "StreamingContent"
      via: "Content accumulation"
      pattern: "Content.*\\+"
---

<objective>
Create StreamingState and ConnectionState slices with their stores, actions, and reducers.

Purpose: Enable streaming content tracking per-topic (for throttled UI updates) and SignalR connection status monitoring (for reconnection handling).

Output: Two complete state slices ready for component consumption in `WebChat.Client/State/Streaming/` and `WebChat.Client/State/Connection/`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-slices/02-CONTEXT.md
@.planning/phases/02-state-slices/02-RESEARCH.md

# Phase 1 infrastructure (available)
@WebChat.Client/State/Store.cs
@WebChat.Client/State/Dispatcher.cs
@WebChat.Client/State/IAction.cs

# Existing streaming types to reference
@WebChat.Client/Services/Streaming/StreamingCoordinator.cs
@WebChat.Client/Services/ChatConnectionService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamingState slice</name>
  <files>
    WebChat.Client/State/Streaming/StreamingState.cs
    WebChat.Client/State/Streaming/StreamingActions.cs
    WebChat.Client/State/Streaming/StreamingReducers.cs
    WebChat.Client/State/Streaming/StreamingStore.cs
  </files>
  <action>
Create the Streaming state slice following the pattern from 02-RESEARCH.md:

**StreamingState.cs:**
Create two records:

```csharp
public sealed record StreamingContent
{
    public string Content { get; init; } = "";
    public string? Reasoning { get; init; }
    public string? ToolCalls { get; init; }
    public string? CurrentMessageId { get; init; }
    public bool IsError { get; init; }
}

public sealed record StreamingState
{
    public IReadOnlyDictionary<string, StreamingContent> StreamingByTopic { get; init; }
        = new Dictionary<string, StreamingContent>();
    public IReadOnlySet<string> StreamingTopics { get; init; } = new HashSet<string>();
    public IReadOnlySet<string> ResumingTopics { get; init; } = new HashSet<string>();

    public static StreamingState Initial => new();
}
```

- Per-topic streaming content tracking (per CONTEXT.md - future-proofs concurrent streams)
- Separate sets for streaming vs resuming status

**StreamingActions.cs:**
- `StreamStarted(string TopicId)` - marks topic as streaming
- `StreamChunk(string TopicId, string? Content, string? Reasoning, string? ToolCalls, string? MessageId)` - accumulates content
- `StreamCompleted(string TopicId)` - clears streaming for topic
- `StreamCancelled(string TopicId)` - clears streaming for topic
- `StreamError(string TopicId, string Error)` - sets error state
- `StartResuming(string TopicId)` - marks topic as resuming
- `StopResuming(string TopicId)` - clears resuming flag
- All implement `IAction`

**StreamingReducers.cs:**
- Static class with `Reduce(StreamingState state, IAction action)` method
- `StreamStarted`: Add topicId to StreamingTopics, initialize empty StreamingContent for topic
- `StreamChunk`: Accumulate content (append to existing Content/Reasoning/ToolCalls strings), update MessageId
- `StreamCompleted/StreamCancelled`: Remove from StreamingByTopic and StreamingTopics
- `StreamError`: Set IsError=true on StreamingContent for topic
- `StartResuming/StopResuming`: Add/remove from ResumingTopics set
- Always create new collections for mutations

**StreamingStore.cs:**
- Sealed class wrapping `Store<StreamingState>`
- Constructor takes `Dispatcher`, registers handlers for all 7 action types
- Expose `State` and `StateObservable` properties
- Implement `IDisposable`
  </action>
  <verify>
Files compile: `dotnet build WebChat.Client`
  </verify>
  <done>
StreamingState slice exists with StreamingContent record, StreamingState record, 7 action types, reducer with content accumulation logic, and store with handler registration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConnectionState slice</name>
  <files>
    WebChat.Client/State/Connection/ConnectionState.cs
    WebChat.Client/State/Connection/ConnectionActions.cs
    WebChat.Client/State/Connection/ConnectionReducers.cs
    WebChat.Client/State/Connection/ConnectionStore.cs
  </files>
  <action>
Create the Connection state slice following the pattern from 02-RESEARCH.md:

**ConnectionState.cs:**
Create enum and record:

```csharp
public enum ConnectionStatus
{
    Disconnected,
    Connecting,
    Connected,
    Reconnecting
}

public sealed record ConnectionState
{
    public ConnectionStatus Status { get; init; } = ConnectionStatus.Disconnected;
    public DateTime? LastConnected { get; init; }
    public int ReconnectAttempts { get; init; }
    public string? Error { get; init; }

    public static ConnectionState Initial => new();
}
```

- Includes LastConnected and ReconnectAttempts (per Claude's discretion in CONTEXT.md)
- Error auto-clears on successful connection

**ConnectionActions.cs:**
- `ConnectionStatusChanged(ConnectionStatus Status)` - generic status update
- `ConnectionConnecting` - transitioning to connecting
- `ConnectionConnected` - successfully connected
- `ConnectionReconnecting` - connection lost, attempting reconnect
- `ConnectionReconnected` - reconnected after loss
- `ConnectionClosed(string? Error)` - connection closed (possibly with error)
- `ConnectionError(string Error)` - explicit error
- All implement `IAction`

**ConnectionReducers.cs:**
- Static class with `Reduce(ConnectionState state, IAction action)` method
- `ConnectionStatusChanged`: Update Status directly
- `ConnectionConnecting`: Set Status=Connecting
- `ConnectionConnected`: Set Status=Connected, LastConnected=DateTime.UtcNow, clear Error, reset ReconnectAttempts=0
- `ConnectionReconnecting`: Set Status=Reconnecting, increment ReconnectAttempts
- `ConnectionReconnected`: Same as Connected (clear error, reset attempts)
- `ConnectionClosed`: Set Status=Disconnected, set Error if provided
- `ConnectionError`: Set Error (don't change status - error can occur in any state)

**ConnectionStore.cs:**
- Sealed class wrapping `Store<ConnectionState>`
- Constructor takes `Dispatcher`, registers handlers for all 7 action types
- Expose `State` and `StateObservable` properties
- Implement `IDisposable`
  </action>
  <verify>
Files compile: `dotnet build WebChat.Client`
  </verify>
  <done>
ConnectionState slice exists with ConnectionStatus enum, ConnectionState record, 7 action types, reducer with proper status transitions, and store with handler registration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for StreamingStore and ConnectionStore</name>
  <files>
    Tests/Unit/WebChat.Client/State/StreamingStoreTests.cs
    Tests/Unit/WebChat.Client/State/ConnectionStoreTests.cs
  </files>
  <action>
Create unit tests verifying store behavior:

**StreamingStoreTests.cs:**
- Test `StreamStarted` adds topic to StreamingTopics and initializes StreamingContent
- Test `StreamChunk` accumulates Content (multiple chunks concatenate)
- Test `StreamChunk` accumulates Reasoning separately from Content
- Test `StreamChunk` accumulates ToolCalls separately
- Test `StreamChunk` updates CurrentMessageId
- Test `StreamCompleted` removes topic from StreamingByTopic and StreamingTopics
- Test `StreamCancelled` removes topic from StreamingByTopic and StreamingTopics
- Test `StreamError` sets IsError=true on StreamingContent
- Test `StartResuming/StopResuming` manages ResumingTopics set
- Test multiple topics can stream independently

**ConnectionStoreTests.cs:**
- Test `ConnectionConnecting` sets Status=Connecting
- Test `ConnectionConnected` sets Status=Connected, clears Error, sets LastConnected, resets ReconnectAttempts
- Test `ConnectionReconnecting` sets Status=Reconnecting, increments ReconnectAttempts
- Test `ConnectionReconnected` same behavior as Connected
- Test `ConnectionClosed` sets Status=Disconnected, sets Error if provided
- Test `ConnectionError` sets Error without changing Status
- Test error auto-clears on successful connection
- Test ReconnectAttempts increments on each reconnect attempt

Use xUnit, create `Dispatcher` and store in each test setup. Verify state after dispatch.
  </action>
  <verify>
Tests pass: `dotnet test --filter "StreamingStoreTests|ConnectionStoreTests"`
  </verify>
  <done>
Unit tests verify StreamingStore handles streaming lifecycle (start, chunk accumulation, complete/cancel/error) and ConnectionStore handles connection state machine transitions correctly.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build WebChat.Client` - compiles without errors
2. `dotnet test --filter "StreamingStoreTests|ConnectionStoreTests"` - all tests pass
3. Verify StreamingReducers accumulates content (grep for `+` or `$"{existing}` patterns)
4. Verify ConnectionReducers clears error on success (grep for `Error = null`)
</verification>

<success_criteria>
- StreamingState slice: 4 files, store registers 7 action handlers, StreamChunk accumulates content
- ConnectionState slice: 4 files, store registers 7 action handlers, proper status transitions
- All reducers use immutable patterns
- Unit tests pass for both stores
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-slices/02-02-SUMMARY.md`
</output>
