---
phase: 04-signalr-integration
plan: 03
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified:
  - WebChat.Client/State/Hub/ReconnectionEffect.cs
  - WebChat.Client/Services/Streaming/StreamResumeService.cs
  - WebChat.Client/Components/Chat/ChatContainer.razor
  - WebChat.Client/Program.cs
  - Tests/Unit/WebChat.Client/State/ReconnectionEffectTests.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "After reconnection, active streams resume automatically"
    - "Selected topic session restarts on reconnection"
    - "StreamResumeService dispatches actions instead of direct state mutations"
    - "ChatContainer no longer handles reconnection directly"
  artifacts:
    - path: "WebChat.Client/State/Hub/ReconnectionEffect.cs"
      provides: "Effect that listens for ConnectionReconnected and triggers resumption"
      min_lines: 40
    - path: "WebChat.Client/Services/Streaming/StreamResumeService.cs"
      provides: "Updated to dispatch actions"
      contains: "dispatcher.Dispatch"
  key_links:
    - from: "ReconnectionEffect"
      to: "ConnectionStore"
      via: "subscription to ConnectionReconnected"
      pattern: "ConnectionStore.*Subscribe"
    - from: "ReconnectionEffect"
      to: "StreamResumeService"
      via: "trigger resumption"
      pattern: "streamResumeService\\.TryResumeStreamAsync"
---

<objective>
Handle reconnection with stream resumption through the store pattern via ReconnectionEffect.

Purpose: Reconnection logic moves from ChatContainer to a centralized effect that responds to ConnectionReconnected actions, resuming streams and sessions automatically.

Output: ReconnectionEffect subscribes to ConnectionStore, triggers StreamResumeService on reconnect, and ChatContainer no longer handles reconnection events directly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-signalr-integration/04-RESEARCH.md
@.planning/phases/04-signalr-integration/04-CONTEXT.md

# Prior plan summaries needed (will be created by plans 01-02)
@.planning/phases/04-signalr-integration/04-01-PLAN.md
@.planning/phases/04-signalr-integration/04-02-PLAN.md

# Existing source files
@WebChat.Client/Services/Streaming/StreamResumeService.cs
@WebChat.Client/Components/Chat/ChatContainer.razor
@WebChat.Client/State/Connection/ConnectionStore.cs
@WebChat.Client/State/Topics/TopicsStore.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReconnectionEffect that listens for ConnectionReconnected</name>
  <files>
    WebChat.Client/State/Hub/ReconnectionEffect.cs
    WebChat.Client/Program.cs
  </files>
  <action>
Create `WebChat.Client/State/Hub/ReconnectionEffect.cs`:

This effect:
1. Subscribes to ConnectionStore for state changes
2. When status transitions to `Connected` from `Reconnecting` (i.e., ConnectionReconnected was dispatched), triggers:
   - Session restart for selected topic
   - Stream resumption for all topics that may have been streaming

```csharp
using System.Reactive.Linq;
using WebChat.Client.Contracts;
using WebChat.Client.Services.Streaming;
using WebChat.Client.State.Connection;
using WebChat.Client.State.Topics;

namespace WebChat.Client.State.Hub;

public sealed class ReconnectionEffect : IDisposable
{
    private readonly IDisposable _subscription;
    private ConnectionStatus _previousStatus = ConnectionStatus.Disconnected;

    public ReconnectionEffect(
        ConnectionStore connectionStore,
        TopicsStore topicsStore,
        IChatSessionService sessionService,
        IStreamResumeService streamResumeService)
    {
        _subscription = connectionStore.StateObservable
            .Subscribe(state =>
            {
                var wasReconnecting = _previousStatus == ConnectionStatus.Reconnecting;
                var isNowConnected = state.Status == ConnectionStatus.Connected;
                _previousStatus = state.Status;

                if (wasReconnecting && isNowConnected)
                {
                    HandleReconnected(topicsStore, sessionService, streamResumeService);
                }
            });
    }

    private static void HandleReconnected(
        TopicsStore topicsStore,
        IChatSessionService sessionService,
        IStreamResumeService streamResumeService)
    {
        var currentState = topicsStore.CurrentState;

        // Restart session for selected topic
        if (currentState.SelectedTopicId is not null)
        {
            var selectedTopic = currentState.Topics
                .FirstOrDefault(t => t.TopicId == currentState.SelectedTopicId);

            if (selectedTopic is not null)
            {
                _ = sessionService.StartSessionAsync(selectedTopic);
            }
        }

        // Resume streams for all topics (fire-and-forget)
        foreach (var topic in currentState.Topics)
        {
            _ = streamResumeService.TryResumeStreamAsync(topic);
        }
    }

    public void Dispose()
    {
        _subscription.Dispose();
    }
}
```

**Program.cs:**
Register as singleton (must be created at startup to subscribe):
```csharp
builder.Services.AddSingleton<ReconnectionEffect>();
```

Also need to resolve it to activate the subscription. Add after `builder.Build()`:
```csharp
// Activate effects that need to run at startup
_ = app.Services.GetRequiredService<ReconnectionEffect>();
```

Note: In Blazor WASM, services are only instantiated when first resolved. Effect needs explicit resolution to start listening.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
  </verify>
  <done>
ReconnectionEffect exists and is registered in DI, subscribing to ConnectionStore and triggering resumption on reconnect.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update StreamResumeService to dispatch actions</name>
  <files>
    WebChat.Client/Services/Streaming/StreamResumeService.cs
  </files>
  <action>
Modify StreamResumeService to dispatch actions instead of calling ChatStateManager:

1. Add `IDispatcher dispatcher` to constructor, keep other dependencies

2. Replace direct state mutations with action dispatches:

Replace `stateManager.TryStartResuming(topic.TopicId)` logic:
- Dispatch `StartResuming(topic.TopicId)` action
- Check if topic is already resuming via store state

Replace `stateManager.IsTopicStreaming(topic.TopicId)`:
- Use StreamingStore to check if topic is streaming

Replace `stateManager.HasMessagesForTopic(topic.TopicId)`:
- Keep using stateManager for now (MessagesStore integration in Phase 5)

Replace `stateManager.SetMessagesForTopic(topic.TopicId, messages)`:
- Dispatch `MessagesLoaded(topic.TopicId, messages)`

Replace `stateManager.StartStreaming(topic.TopicId)`:
- Dispatch `StreamStarted(topic.TopicId)`

Replace `stateManager.UpdateStreamingMessage(topic.TopicId, streamingMessage)`:
- Dispatch `StreamChunk(topic.TopicId, streamingMessage.Content, streamingMessage.Reasoning, streamingMessage.ToolCalls, null)`

Replace `stateManager.StopResuming(topic.TopicId)`:
- Dispatch `StopResuming(topic.TopicId)` in finally block

Replace `stateManager.SetApprovalRequest(pendingApproval)`:
- Dispatch `ShowApproval(topic.TopicId, pendingApproval)` if pendingApproval is not null

3. Add using statements:
```csharp
using WebChat.Client.State;
using WebChat.Client.State.Streaming;
using WebChat.Client.State.Messages;
using WebChat.Client.State.Approval;
```

Note: Keep stateManager dependency for `HasMessagesForTopic`, `GetMessagesForTopic` until those migrate to stores.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
  </verify>
  <done>
StreamResumeService dispatches actions for streaming state changes instead of direct mutations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Remove reconnection handling from ChatContainer and add tests</name>
  <files>
    WebChat.Client/Components/Chat/ChatContainer.razor
    Tests/Unit/WebChat.Client/State/ReconnectionEffectTests.cs
  </files>
  <action>
**ChatContainer.razor:**

1. Remove the `HandleReconnected` method entirely

2. Remove the event subscription in `OnInitializedAsync`:
```csharp
// DELETE this line:
ConnectionService.OnReconnected += HandleReconnected;
```

3. Remove the event unsubscription in `Dispose`:
```csharp
// DELETE this line:
ConnectionService.OnReconnected -= HandleReconnected;
```

4. Keep `OnReconnecting` and `OnStateChanged` subscriptions for now (UI updates still needed)

**ReconnectionEffectTests.cs:**
Create test class:

```csharp
using Moq;
using System.Reactive.Subjects;
using WebChat.Client.Contracts;
using WebChat.Client.Models;
using WebChat.Client.Services.Streaming;
using WebChat.Client.State.Connection;
using WebChat.Client.State.Hub;
using WebChat.Client.State.Topics;

namespace Tests.Unit.WebChat.Client.State;

public sealed class ReconnectionEffectTests : IDisposable
{
    private readonly BehaviorSubject<ConnectionState> _connectionSubject;
    private readonly BehaviorSubject<TopicsState> _topicsSubject;
    private readonly Mock<ConnectionStore> _mockConnectionStore;
    private readonly Mock<TopicsStore> _mockTopicsStore;
    private readonly Mock<IChatSessionService> _mockSessionService;
    private readonly Mock<IStreamResumeService> _mockStreamResumeService;
    private ReconnectionEffect? _sut;

    public ReconnectionEffectTests()
    {
        _connectionSubject = new BehaviorSubject<ConnectionState>(ConnectionState.Initial);
        _topicsSubject = new BehaviorSubject<TopicsState>(TopicsState.Initial);

        // Setup mocks to return observables
        _mockConnectionStore = new Mock<ConnectionStore>(/* constructor params */);
        _mockConnectionStore.Setup(s => s.StateObservable).Returns(_connectionSubject);

        _mockTopicsStore = new Mock<TopicsStore>(/* constructor params */);
        _mockTopicsStore.Setup(s => s.CurrentState).Returns(() => _topicsSubject.Value);

        _mockSessionService = new Mock<IChatSessionService>();
        _mockStreamResumeService = new Mock<IStreamResumeService>();
    }

    // ... test implementations
}
```

Tests:
1. `WhenConnectionReconnected_StartsSessionForSelectedTopic` - verify sessionService.StartSessionAsync called with selected topic
2. `WhenConnectionReconnected_ResumesStreamsForAllTopics` - verify streamResumeService.TryResumeStreamAsync called for each topic
3. `WhenConnectionConnectedWithoutPriorReconnecting_DoesNotTriggerReconnection` - verify nothing called when connecting fresh
4. `WhenConnectionReconnecting_DoesNotTriggerYet` - verify nothing happens while still reconnecting
5. `Dispose_UnsubscribesFromStore` - verify subscription disposed

Note: Testing reactive effects requires simulating state changes via BehaviorSubject.
  </action>
  <verify>
Tests pass: `dotnet test Tests --filter "FullyQualifiedName~ReconnectionEffectTests"`
Build succeeds: `dotnet build`
ChatContainer no longer contains HandleReconnected method.
  </verify>
  <done>
Reconnection handling moved from ChatContainer to ReconnectionEffect. 5 unit tests verify behavior.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` - solution compiles
2. `dotnet test Tests --filter "FullyQualifiedName~ReconnectionEffectTests"` - all 5 tests pass
3. ChatContainer.razor does not contain `HandleReconnected` method
4. ReconnectionEffect automatically resumes streams on reconnection
</verification>

<success_criteria>
- ReconnectionEffect listens for ConnectionReconnected and triggers stream resumption
- StreamResumeService dispatches actions instead of direct state mutations
- ChatContainer no longer handles reconnection events directly
- 5 unit tests verify reconnection flow through stores
- After reconnection, user sees streaming resume exactly where it left off
</success_criteria>

<output>
After completion, create `.planning/phases/04-signalr-integration/04-03-SUMMARY.md`
</output>
