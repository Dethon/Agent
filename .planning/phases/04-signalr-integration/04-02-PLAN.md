---
phase: 04-signalr-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/Services/ChatConnectionService.cs
  - WebChat.Client/State/Hub/ConnectionEventDispatcher.cs
  - WebChat.Client/Program.cs
  - Tests/Unit/WebChat.Client/State/ConnectionEventDispatcherTests.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "HubConnection.Reconnecting fires ConnectionReconnecting action"
    - "HubConnection.Reconnected fires ConnectionReconnected action"
    - "HubConnection.Closed fires ConnectionClosed action"
    - "Successful connection dispatches ConnectionConnected action"
  artifacts:
    - path: "WebChat.Client/State/Hub/ConnectionEventDispatcher.cs"
      provides: "Bridges HubConnection events to store actions"
      min_lines: 30
    - path: "WebChat.Client/Services/ChatConnectionService.cs"
      provides: "Updated to use ConnectionEventDispatcher"
      contains: "ConnectionEventDispatcher"
  key_links:
    - from: "ChatConnectionService"
      to: "ConnectionEventDispatcher"
      via: "event callback delegation"
      pattern: "_connectionEventDispatcher"
    - from: "ConnectionEventDispatcher"
      to: "IDispatcher"
      via: "action dispatch"
      pattern: "dispatcher\\.Dispatch"
---

<objective>
Integrate SignalR connection lifecycle events with ConnectionStore via ConnectionEventDispatcher.

Purpose: Connection state changes flow through the unidirectional pattern, enabling UI components to subscribe to ConnectionStore rather than connection service events.

Output: ChatConnectionService delegates connection events to ConnectionEventDispatcher which dispatches typed actions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-signalr-integration/04-RESEARCH.md
@.planning/phases/04-signalr-integration/04-CONTEXT.md

# Prior summary for ConnectionState
@.planning/phases/02-state-slices/02-02-SUMMARY.md

# Existing source files
@WebChat.Client/Services/ChatConnectionService.cs
@WebChat.Client/State/Connection/ConnectionActions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConnectionEventDispatcher</name>
  <files>
    WebChat.Client/State/Hub/ConnectionEventDispatcher.cs
  </files>
  <action>
Create `WebChat.Client/State/Hub/ConnectionEventDispatcher.cs`:

```csharp
using WebChat.Client.State.Connection;

namespace WebChat.Client.State.Hub;

public sealed class ConnectionEventDispatcher(IDispatcher dispatcher)
{
    public void HandleConnecting()
    {
        dispatcher.Dispatch(new ConnectionConnecting());
    }

    public void HandleConnected()
    {
        dispatcher.Dispatch(new ConnectionConnected());
    }

    public void HandleReconnecting(Exception? exception)
    {
        dispatcher.Dispatch(new ConnectionReconnecting());
    }

    public void HandleReconnected(string? connectionId)
    {
        dispatcher.Dispatch(new ConnectionReconnected());
    }

    public void HandleClosed(Exception? exception)
    {
        dispatcher.Dispatch(new ConnectionClosed(exception?.Message));
    }
}
```

Note: This is a concrete class, not interface-based, since it's purely internal wiring between ChatConnectionService and the dispatcher. If testability needed later, can extract interface.
  </action>
  <verify>
File compiles: `dotnet build WebChat.Client`
  </verify>
  <done>
ConnectionEventDispatcher exists with 5 handler methods mapping to connection actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ChatConnectionService to use ConnectionEventDispatcher</name>
  <files>
    WebChat.Client/Services/ChatConnectionService.cs
  </files>
  <action>
Modify ChatConnectionService:

1. Add constructor parameter: `ConnectionEventDispatcher connectionEventDispatcher`
   - Note: Keep HttpClient as first parameter since it's required

2. Store as private readonly field: `private readonly ConnectionEventDispatcher _connectionEventDispatcher = connectionEventDispatcher;`

3. Update `ConnectAsync()`:

Before `HubConnection.StartAsync()`:
```csharp
_connectionEventDispatcher.HandleConnecting();
```

After successful `HubConnection.StartAsync()`:
```csharp
_connectionEventDispatcher.HandleConnected();
OnStateChanged?.Invoke();  // Keep existing event for backward compatibility
```

4. Update HubConnection event registrations:

```csharp
HubConnection.Closed += exception =>
{
    _connectionEventDispatcher.HandleClosed(exception);
    OnStateChanged?.Invoke();
    return Task.CompletedTask;
};

HubConnection.Reconnecting += exception =>
{
    _connectionEventDispatcher.HandleReconnecting(exception);
    OnReconnecting?.Invoke();
    OnStateChanged?.Invoke();
    return Task.CompletedTask;
};

HubConnection.Reconnected += async connectionId =>
{
    _connectionEventDispatcher.HandleReconnected(connectionId);
    if (OnReconnected is not null)
    {
        await OnReconnected.Invoke();
    }
    OnStateChanged?.Invoke();
};
```

5. Add using statement: `using WebChat.Client.State.Hub;`

Note: Keep existing events (OnStateChanged, OnReconnected, OnReconnecting) for now - they'll be removed in Phase 5 when components migrate to stores.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
ChatConnectionService dispatches connection actions on state changes.
  </verify>
  <done>
ChatConnectionService delegates all connection lifecycle events to ConnectionEventDispatcher while maintaining backward compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register ConnectionEventDispatcher and add tests</name>
  <files>
    WebChat.Client/Program.cs
    Tests/Unit/WebChat.Client/State/ConnectionEventDispatcherTests.cs
  </files>
  <action>
**Program.cs:**
Add registration (before ChatConnectionService since it depends on ConnectionEventDispatcher):
```csharp
builder.Services.AddSingleton<ConnectionEventDispatcher>();
```

Note: No interface needed - direct injection of concrete type.

**ConnectionEventDispatcherTests.cs:**
Create test class:

```csharp
using Moq;
using WebChat.Client.State;
using WebChat.Client.State.Connection;
using WebChat.Client.State.Hub;

namespace Tests.Unit.WebChat.Client.State;

public sealed class ConnectionEventDispatcherTests
{
    private readonly Mock<IDispatcher> _mockDispatcher;
    private readonly ConnectionEventDispatcher _sut;

    public ConnectionEventDispatcherTests()
    {
        _mockDispatcher = new Mock<IDispatcher>();
        _sut = new ConnectionEventDispatcher(_mockDispatcher.Object);
    }

    // Tests...
}
```

Tests:
1. `HandleConnecting_DispatchesConnectionConnecting` - verify ConnectionConnecting action dispatched
2. `HandleConnected_DispatchesConnectionConnected` - verify ConnectionConnected action dispatched
3. `HandleReconnecting_DispatchesConnectionReconnecting` - verify ConnectionReconnecting dispatched (exception parameter ignored)
4. `HandleReconnected_DispatchesConnectionReconnected` - verify ConnectionReconnected dispatched (connectionId parameter ignored)
5. `HandleClosed_WithException_DispatchesConnectionClosedWithErrorMessage` - verify ConnectionClosed(errorMessage) dispatched
6. `HandleClosed_WithoutException_DispatchesConnectionClosedWithNull` - verify ConnectionClosed(null) dispatched

Use Moq `Verify` to assert correct action dispatched.
  </action>
  <verify>
Tests pass: `dotnet test Tests --filter "FullyQualifiedName~ConnectionEventDispatcherTests"`
Build succeeds: `dotnet build`
  </verify>
  <done>
ConnectionEventDispatcher registered in DI. 6 unit tests verify connection event to action mapping.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` - solution compiles
2. `dotnet test Tests --filter "FullyQualifiedName~ConnectionEventDispatcherTests"` - all 6 tests pass
3. Connection state changes dispatch to ConnectionStore
4. Existing component event subscriptions still work (backward compatibility)
</verification>

<success_criteria>
- All SignalR connection lifecycle events (Connecting, Connected, Reconnecting, Reconnected, Closed) dispatch typed actions
- ConnectionStore receives state updates through the dispatcher
- Backward compatibility maintained for ChatContainer event subscriptions
- 6 unit tests verify correct action dispatching
</success_criteria>

<output>
After completion, create `.planning/phases/04-signalr-integration/04-02-SUMMARY.md`
</output>
