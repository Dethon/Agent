---
phase: 04-signalr-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/State/Hub/IHubEventDispatcher.cs
  - WebChat.Client/State/Hub/HubEventDispatcher.cs
  - WebChat.Client/Services/SignalREventSubscriber.cs
  - WebChat.Client/Program.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SignalR topic change events create AddTopic/UpdateTopic/RemoveTopic actions"
    - "SignalR stream change events create StreamStarted/StreamCompleted/StreamCancelled actions"
    - "SignalR approval events create ApprovalResolved actions"
    - "SignalR tool calls events create StreamChunk actions with tool calls"
  artifacts:
    - path: "WebChat.Client/State/Hub/IHubEventDispatcher.cs"
      provides: "Interface for hub event dispatching"
      exports: ["IHubEventDispatcher"]
    - path: "WebChat.Client/State/Hub/HubEventDispatcher.cs"
      provides: "Implementation that maps notifications to actions"
      min_lines: 50
    - path: "WebChat.Client/Services/SignalREventSubscriber.cs"
      provides: "Updated to call HubEventDispatcher instead of ChatNotificationHandler"
      contains: "hubEventDispatcher"
  key_links:
    - from: "SignalREventSubscriber"
      to: "IHubEventDispatcher"
      via: "constructor injection"
      pattern: "IHubEventDispatcher.*hubEventDispatcher"
    - from: "HubEventDispatcher"
      to: "IDispatcher"
      via: "action dispatch"
      pattern: "dispatcher\\.Dispatch"
---

<objective>
Create HubEventDispatcher that transforms SignalR hub notifications into typed store actions.

Purpose: Bridge SignalR event-driven world with action/reducer pattern, enabling testable event handling and unidirectional data flow.

Output: HubEventDispatcher service injected into SignalREventSubscriber, dispatching actions to stores instead of direct state mutations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-signalr-integration/04-RESEARCH.md
@.planning/phases/04-signalr-integration/04-CONTEXT.md

# Prior summaries needed for action types
@.planning/phases/02-state-slices/02-01-SUMMARY.md
@.planning/phases/02-state-slices/02-02-SUMMARY.md
@.planning/phases/02-state-slices/02-03-SUMMARY.md

# Existing source files to modify
@WebChat.Client/Services/SignalREventSubscriber.cs
@WebChat.Client/State/Topics/TopicsActions.cs
@WebChat.Client/State/Streaming/StreamingActions.cs
@WebChat.Client/State/Approval/ApprovalActions.cs
@WebChat.Client/State/Messages/MessagesActions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HubEventDispatcher interface and implementation</name>
  <files>
    WebChat.Client/State/Hub/IHubEventDispatcher.cs
    WebChat.Client/State/Hub/HubEventDispatcher.cs
  </files>
  <action>
Create `WebChat.Client/State/Hub/` directory with two files:

**IHubEventDispatcher.cs:**
- Interface with methods matching SignalREventSubscriber notification types:
  - `void HandleTopicChanged(TopicChangedNotification notification)`
  - `void HandleStreamChanged(StreamChangedNotification notification)`
  - `void HandleNewMessage(NewMessageNotification notification)`
  - `void HandleApprovalResolved(ApprovalResolvedNotification notification)`
  - `void HandleToolCalls(ToolCallsNotification notification)`
- Methods are synchronous because dispatch is synchronous (per RESEARCH.md recommendation)

**HubEventDispatcher.cs:**
- Primary constructor with `IDispatcher dispatcher`
- Implement each handler by mapping notification to action:

For `HandleTopicChanged`:
```csharp
var action = notification.ChangeType switch
{
    TopicChangeType.Created when notification.Topic is not null
        => (IAction)new AddTopic(StoredTopic.FromMetadata(notification.Topic)),
    TopicChangeType.Updated when notification.Topic is not null
        => new UpdateTopic(StoredTopic.FromMetadata(notification.Topic)),
    TopicChangeType.Deleted
        => new RemoveTopic(notification.TopicId),
    _ => throw new ArgumentOutOfRangeException()
};
dispatcher.Dispatch(action);
```

For `HandleStreamChanged`:
```csharp
var action = notification.ChangeType switch
{
    StreamChangeType.Started => (IAction)new StreamStarted(notification.TopicId),
    StreamChangeType.Completed => new StreamCompleted(notification.TopicId),
    StreamChangeType.Cancelled => new StreamCancelled(notification.TopicId),
    _ => throw new ArgumentOutOfRangeException()
};
dispatcher.Dispatch(action);
```

For `HandleNewMessage`:
- Dispatch `LoadMessages(notification.TopicId)` to trigger async message loading
- Note: The actual fetch will be handled by an effect/service, not the dispatcher

For `HandleApprovalResolved`:
- Dispatch `ApprovalResolved(notification.ApprovalId, notification.ToolCalls)`
- If notification.ToolCalls is not empty, also dispatch `StreamChunk` with ToolCalls

For `HandleToolCalls`:
- Dispatch `StreamChunk(notification.TopicId, null, null, notification.ToolCalls, null)`

Use file-scoped namespace `WebChat.Client.State.Hub`.
  </action>
  <verify>
Files compile: `dotnet build WebChat.Client`
  </verify>
  <done>
HubEventDispatcher interface and implementation exist with all 5 handler methods dispatching typed actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SignalREventSubscriber to use HubEventDispatcher</name>
  <files>
    WebChat.Client/Services/SignalREventSubscriber.cs
  </files>
  <action>
Modify SignalREventSubscriber:

1. Change constructor to inject `IHubEventDispatcher hubEventDispatcher` instead of `IChatNotificationHandler notificationHandler`

2. Update each `.On()` registration to call HubEventDispatcher methods synchronously:

```csharp
hubConnection.On<TopicChangedNotification>("OnTopicChanged", notification =>
{
    hubEventDispatcher.HandleTopicChanged(notification);
});
```

Note: Remove async/await since HubEventDispatcher methods are synchronous. SignalR handlers can be sync or async - sync is fine when no async work needed.

For the StreamChanged handler specifically, keep the fire-and-forget pattern for stream resumption:
```csharp
hubConnection.On<StreamChangedNotification>("OnStreamChanged", notification =>
{
    hubEventDispatcher.HandleStreamChanged(notification);
    // Note: Stream resumption effect will handle the async work
});
```

3. Add using statement: `using WebChat.Client.State.Hub;`

4. Remove the using statement for `WebChat.Client.Contracts` if IChatNotificationHandler was the only thing from there being used.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
SignalREventSubscriber no longer references IChatNotificationHandler.
  </verify>
  <done>
SignalREventSubscriber uses HubEventDispatcher for all 5 notification types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register HubEventDispatcher in DI and add unit tests</name>
  <files>
    WebChat.Client/Program.cs
    Tests/Unit/WebChat.Client/State/HubEventDispatcherTests.cs
  </files>
  <action>
**Program.cs:**
Add registration after other state services:
```csharp
builder.Services.AddSingleton<IHubEventDispatcher, HubEventDispatcher>();
```
Add using: `using WebChat.Client.State.Hub;`

**HubEventDispatcherTests.cs:**
Create test class with:
- `private readonly Mock<IDispatcher> _mockDispatcher`
- `private readonly HubEventDispatcher _sut`

Tests:
1. `HandleTopicChanged_Created_DispatchesAddTopic` - verify AddTopic dispatched with correct StoredTopic
2. `HandleTopicChanged_Updated_DispatchesUpdateTopic` - verify UpdateTopic dispatched
3. `HandleTopicChanged_Deleted_DispatchesRemoveTopic` - verify RemoveTopic dispatched with TopicId
4. `HandleStreamChanged_Started_DispatchesStreamStarted` - verify StreamStarted with TopicId
5. `HandleStreamChanged_Completed_DispatchesStreamCompleted` - verify StreamCompleted with TopicId
6. `HandleStreamChanged_Cancelled_DispatchesStreamCancelled` - verify StreamCancelled with TopicId
7. `HandleNewMessage_DispatchesLoadMessages` - verify LoadMessages with TopicId
8. `HandleApprovalResolved_DispatchesApprovalResolved` - verify ApprovalResolved with ApprovalId
9. `HandleToolCalls_DispatchesStreamChunk` - verify StreamChunk with ToolCalls

Use Moq to verify `_mockDispatcher.Verify(d => d.Dispatch(It.Is<ActionType>(a => a.Property == expected)))`.
  </action>
  <verify>
Tests pass: `dotnet test Tests --filter "FullyQualifiedName~HubEventDispatcherTests"`
Build succeeds: `dotnet build`
  </verify>
  <done>
HubEventDispatcher registered in DI. 9 unit tests verify notification-to-action mapping.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` - solution compiles
2. `dotnet test Tests --filter "FullyQualifiedName~HubEventDispatcherTests"` - all 9 tests pass
3. SignalREventSubscriber no longer depends on IChatNotificationHandler
4. All SignalR notifications route through HubEventDispatcher to store actions
</verification>

<success_criteria>
- HubEventDispatcher transforms all 5 notification types to appropriate store actions
- SignalREventSubscriber uses HubEventDispatcher instead of direct state mutations
- 9 unit tests verify correct action dispatching
- No direct ChatStateManager mutations in the SignalR event path
</success_criteria>

<output>
After completion, create `.planning/phases/04-signalr-integration/04-01-SUMMARY.md`
</output>
