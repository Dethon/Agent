---
phase: 04-signalr-integration
plan: 04
type: execute
wave: 2
depends_on: [04-01]
files_modified:
  - WebChat.Client/Services/SignalREventSubscriber.cs
  - WebChat.Client/Contracts/ISignalREventSubscriber.cs
  - WebChat.Client/Program.cs
  - Tests/Unit/WebChat.Client/Services/SignalREventSubscriberTests.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Navigating away and back does not create duplicate event subscriptions"
    - "Event subscription IDisposables are tracked for cleanup"
    - "Unsubscribe method disposes all tracked subscriptions"
    - "Subscribe is idempotent - second call does nothing"
  artifacts:
    - path: "WebChat.Client/Services/SignalREventSubscriber.cs"
      provides: "Updated with disposable tracking and unsubscribe method"
      contains: "List<IDisposable>"
    - path: "WebChat.Client/Contracts/ISignalREventSubscriber.cs"
      provides: "Interface with Subscribe and Unsubscribe methods"
      exports: ["ISignalREventSubscriber"]
  key_links:
    - from: "SignalREventSubscriber"
      to: "HubConnection.On()"
      via: "IDisposable tracking"
      pattern: "_subscriptions\\.Add"
---

<objective>
Manage event subscription lifecycle with proper disposal to prevent memory leaks and duplicate handlers.

Purpose: Ensure SignalR event handlers are registered once, tracked for cleanup, and properly disposed when no longer needed.

Output: SignalREventSubscriber tracks subscription disposables, exposes Unsubscribe method, and prevents duplicate registrations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-signalr-integration/04-RESEARCH.md
@.planning/phases/04-signalr-integration/04-CONTEXT.md

# Prior plan for HubEventDispatcher
@.planning/phases/04-signalr-integration/04-01-PLAN.md

# Existing source files
@WebChat.Client/Services/SignalREventSubscriber.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ISignalREventSubscriber interface</name>
  <files>
    WebChat.Client/Contracts/ISignalREventSubscriber.cs
  </files>
  <action>
Create `WebChat.Client/Contracts/ISignalREventSubscriber.cs`:

```csharp
namespace WebChat.Client.Contracts;

public interface ISignalREventSubscriber : IDisposable
{
    /// <summary>
    /// Registers event handlers for all SignalR hub notifications.
    /// Idempotent - calling multiple times has no effect after first subscription.
    /// </summary>
    void Subscribe();

    /// <summary>
    /// Disposes all registered event handlers.
    /// After calling, Subscribe() can be called again to re-register.
    /// </summary>
    void Unsubscribe();

    /// <summary>
    /// Indicates whether event handlers are currently registered.
    /// </summary>
    bool IsSubscribed { get; }
}
```

The interface extends IDisposable so the subscriber can be disposed when the application shuts down.
  </action>
  <verify>
File compiles: `dotnet build WebChat.Client`
  </verify>
  <done>
ISignalREventSubscriber interface exists with Subscribe, Unsubscribe, IsSubscribed, and IDisposable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SignalREventSubscriber with disposable tracking</name>
  <files>
    WebChat.Client/Services/SignalREventSubscriber.cs
  </files>
  <action>
Modify SignalREventSubscriber to implement ISignalREventSubscriber:

1. Implement `ISignalREventSubscriber` interface

2. Add disposable tracking:
```csharp
private readonly List<IDisposable> _subscriptions = new();
private bool _disposed;
```

3. Rename `_subscribed` to use the interface property:
```csharp
public bool IsSubscribed { get; private set; }
```

4. Update `Subscribe()` to track disposables:
```csharp
public void Subscribe()
{
    if (IsSubscribed || _disposed)
    {
        return;
    }

    var hubConnection = connectionService.HubConnection;
    if (hubConnection is null)
    {
        return;
    }

    _subscriptions.Add(
        hubConnection.On<TopicChangedNotification>("OnTopicChanged", notification =>
        {
            hubEventDispatcher.HandleTopicChanged(notification);
        }));

    _subscriptions.Add(
        hubConnection.On<StreamChangedNotification>("OnStreamChanged", notification =>
        {
            hubEventDispatcher.HandleStreamChanged(notification);
        }));

    _subscriptions.Add(
        hubConnection.On<NewMessageNotification>("OnNewMessage", notification =>
        {
            hubEventDispatcher.HandleNewMessage(notification);
        }));

    _subscriptions.Add(
        hubConnection.On<ApprovalResolvedNotification>("OnApprovalResolved", notification =>
        {
            hubEventDispatcher.HandleApprovalResolved(notification);
        }));

    _subscriptions.Add(
        hubConnection.On<ToolCallsNotification>("OnToolCalls", notification =>
        {
            hubEventDispatcher.HandleToolCalls(notification);
        }));

    IsSubscribed = true;
}
```

5. Implement `Unsubscribe()`:
```csharp
public void Unsubscribe()
{
    foreach (var subscription in _subscriptions)
    {
        subscription.Dispose();
    }
    _subscriptions.Clear();
    IsSubscribed = false;
}
```

6. Implement `Dispose()`:
```csharp
public void Dispose()
{
    if (_disposed)
    {
        return;
    }

    Unsubscribe();
    _disposed = true;
}
```

Key behavior:
- `Subscribe()` is idempotent - second call does nothing
- `Unsubscribe()` allows re-subscription by clearing state
- `Dispose()` prevents further subscriptions
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
  </verify>
  <done>
SignalREventSubscriber tracks all subscription disposables and properly cleans up on Unsubscribe/Dispose.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update DI registration and add tests</name>
  <files>
    WebChat.Client/Program.cs
    Tests/Unit/WebChat.Client/Services/SignalREventSubscriberTests.cs
  </files>
  <action>
**Program.cs:**
Update registration to use interface:
```csharp
// Replace:
builder.Services.AddSingleton<SignalREventSubscriber>();
// With:
builder.Services.AddSingleton<ISignalREventSubscriber, SignalREventSubscriber>();
```

Also update any direct `SignalREventSubscriber` injections in components to use `ISignalREventSubscriber`.

Check ChatContainer.razor - if it injects `SignalREventSubscriber` directly, change to `ISignalREventSubscriber`.

**SignalREventSubscriberTests.cs:**
Create test class:

```csharp
using Domain.DTOs.WebChat;
using Microsoft.AspNetCore.SignalR.Client;
using Moq;
using WebChat.Client.Contracts;
using WebChat.Client.Services;
using WebChat.Client.State.Hub;

namespace Tests.Unit.WebChat.Client.Services;

public sealed class SignalREventSubscriberTests
{
    private readonly Mock<ChatConnectionService> _mockConnectionService;
    private readonly Mock<IHubEventDispatcher> _mockHubEventDispatcher;
    private readonly Mock<HubConnection> _mockHubConnection;
    private readonly SignalREventSubscriber _sut;

    // Constructor sets up mocks...

    // Tests...
}
```

Tests:
1. `Subscribe_WhenNotSubscribed_RegistersAllHandlers` - verify 5 handlers registered
2. `Subscribe_WhenAlreadySubscribed_DoesNothing` - verify idempotent
3. `Subscribe_WhenHubConnectionNull_DoesNothing` - verify null safety
4. `Unsubscribe_DisposesAllSubscriptions` - verify all IDisposables disposed
5. `Unsubscribe_AllowsResubscription` - verify Subscribe works after Unsubscribe
6. `Dispose_DisposesSubscriptions` - verify disposal works
7. `Dispose_PreventsResubscription` - verify Subscribe does nothing after Dispose
8. `IsSubscribed_ReflectsState` - verify property accuracy

Note: Testing HubConnection.On() is tricky since it's part of SignalR client. May need to use integration tests or verify behavior through mock interactions.

Alternative approach: Test at integration level by verifying that handlers receive events when subscribed and don't when unsubscribed.
  </action>
  <verify>
Tests pass: `dotnet test Tests --filter "FullyQualifiedName~SignalREventSubscriberTests"`
Build succeeds: `dotnet build`
  </verify>
  <done>
SignalREventSubscriber registered via interface. 8 tests verify subscription lifecycle management.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` - solution compiles
2. `dotnet test Tests --filter "FullyQualifiedName~SignalREventSubscriberTests"` - all tests pass
3. `IsSubscribed` property reflects accurate state
4. `Unsubscribe()` disposes all tracked handlers
5. Second `Subscribe()` call has no effect (idempotent)
</verification>

<success_criteria>
- SignalREventSubscriber implements ISignalREventSubscriber with Subscribe/Unsubscribe/IsSubscribed
- All .On() registrations tracked via IDisposable list
- Unsubscribe disposes all handlers and allows re-subscription
- Subscribe is idempotent - no duplicate handlers
- Dispose prevents further subscriptions
- No memory leaks from orphaned event handlers
</success_criteria>

<output>
After completion, create `.planning/phases/04-signalr-integration/04-04-SUMMARY.md`
</output>
