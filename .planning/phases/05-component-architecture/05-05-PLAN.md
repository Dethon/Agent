---
phase: 05-component-architecture
plan: 05
type: execute
wave: 3
depends_on: [05-01, 05-02, 05-03, 05-04, 05-06]
files_modified:
  - WebChat.Client/Components/Chat/ChatContainer.razor
  - WebChat.Client/State/Effects/AgentSelectionEffect.cs
  - WebChat.Client/State/Effects/InitializationEffect.cs
autonomous: true

must_haves:
  truths:
    - "ChatContainer reduced to under 100 lines"
    - "ChatContainer is composition root only - no business logic"
    - "All child components receive no props (subscribe to stores directly)"
    - "Initialization handled by effect"
  artifacts:
    - path: "WebChat.Client/Components/Chat/ChatContainer.razor"
      provides: "Composition root under 100 lines"
      min_lines: 30
      max_lines: 100
    - path: "WebChat.Client/State/Effects/InitializationEffect.cs"
      provides: "App initialization on component mount"
      contains: "GetAgentsAsync"
  key_links:
    - from: "ChatContainer.razor"
      to: "child components"
      via: "no props"
      pattern: "<MessageList />"
    - from: "InitializationEffect.cs"
      to: "TopicsStore"
      via: "dispatch SetAgents, TopicsLoaded"
      pattern: "Dispatch.*SetAgents"
---

<objective>
Refactor ChatContainer to thin composition root with initialization effect.

Purpose: ChatContainer (305 lines) becomes a simple layout component (~50 lines) that renders child components. All business logic moves to effects. Child components get data from stores directly - no prop drilling.

Output: ChatContainer under 100 lines, InitializationEffect handles startup, AgentSelectionEffect handles agent change.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-component-architecture/05-CONTEXT.md
@.planning/phases/05-component-architecture/05-RESEARCH.md
@.planning/phases/05-component-architecture/05-01-SUMMARY.md
@.planning/phases/05-component-architecture/05-02-SUMMARY.md
@.planning/phases/05-component-architecture/05-03-SUMMARY.md
@.planning/phases/05-component-architecture/05-04-SUMMARY.md
@.planning/phases/05-component-architecture/05-06-SUMMARY.md
@WebChat.Client/Components/Chat/ChatContainer.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InitializationEffect</name>
  <files>
    WebChat.Client/State/Effects/InitializationEffect.cs
    WebChat.Client/State/Topics/TopicsActions.cs
    WebChat.Client/Program.cs
  </files>
  <action>
First, add Initialize action to TopicsActions.cs:
```csharp
/// <summary>
/// Triggers app initialization (load agents, topics).
/// </summary>
public record Initialize : IAction;
```

Create `WebChat.Client/State/Effects/InitializationEffect.cs`:

```csharp
using WebChat.Client.Contracts;
using WebChat.Client.Models;
using WebChat.Client.Services.Streaming;
using WebChat.Client.State.Messages;
using WebChat.Client.State.Topics;

namespace WebChat.Client.State.Effects;

/// <summary>
/// Handles Initialize action: connects SignalR, loads agents and topics.
/// </summary>
public sealed class InitializationEffect : IDisposable
{
    private readonly Dispatcher _dispatcher;
    private readonly IChatConnectionService _connectionService;
    private readonly IAgentService _agentService;
    private readonly ITopicService _topicService;
    private readonly ILocalStorageService _localStorage;
    private readonly ISignalREventSubscriber _eventSubscriber;
    private readonly IStreamResumeService _streamResumeService;

    public InitializationEffect(
        Dispatcher dispatcher,
        IChatConnectionService connectionService,
        IAgentService agentService,
        ITopicService topicService,
        ILocalStorageService localStorage,
        ISignalREventSubscriber eventSubscriber,
        IStreamResumeService streamResumeService)
    {
        _dispatcher = dispatcher;
        _connectionService = connectionService;
        _agentService = agentService;
        _topicService = topicService;
        _localStorage = localStorage;
        _eventSubscriber = eventSubscriber;
        _streamResumeService = streamResumeService;

        dispatcher.RegisterHandler<Initialize>(HandleInitialize);
    }

    private void HandleInitialize(Initialize action)
    {
        _ = HandleInitializeAsync();
    }

    private async Task HandleInitializeAsync()
    {
        // Connect to SignalR
        await _connectionService.ConnectAsync();
        _eventSubscriber.Subscribe();

        // Load agents
        var agents = await _agentService.GetAgentsAsync();
        _dispatcher.Dispatch(new SetAgents(agents));

        if (agents.Count > 0)
        {
            var savedAgentId = await _localStorage.GetAsync("selectedAgentId");
            var savedAgent = agents.FirstOrDefault(a => a.Id == savedAgentId);
            var agentToSelect = savedAgent ?? agents[0];
            _dispatcher.Dispatch(new SelectAgent(agentToSelect.Id));

            if (savedAgent is null)
            {
                await _localStorage.SetAsync("selectedAgentId", agentToSelect.Id);
            }
        }

        // Load topics
        var serverTopics = await _topicService.GetAllTopicsAsync();
        var topics = serverTopics.Select(StoredTopic.FromMetadata).ToList();
        _dispatcher.Dispatch(new TopicsLoaded(topics));

        // Load history for each topic (fire-and-forget)
        foreach (var topic in topics)
        {
            _ = LoadTopicHistoryAsync(topic);
        }
    }

    private async Task LoadTopicHistoryAsync(StoredTopic topic)
    {
        var history = await _topicService.GetHistoryAsync(topic.ChatId, topic.ThreadId);
        var messages = history.Select(h => new ChatMessageModel
        {
            Role = h.Role,
            Content = h.Content
        }).ToList();
        _dispatcher.Dispatch(new SetMessages(topic.TopicId, messages));

        _ = _streamResumeService.TryResumeStreamAsync(topic);
    }

    public void Dispose()
    {
        // No subscription to dispose
    }
}
```

Register in Program.cs:
```csharp
builder.Services.AddSingleton<InitializationEffect>();
```

And eagerly instantiate:
```csharp
host.Services.GetRequiredService<InitializationEffect>();
```
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
InitializationEffect.cs exists
InitializationEffect.cs contains `RegisterHandler<Initialize>`
TopicsActions.cs contains `public record Initialize`
Program.cs contains `InitializationEffect`
  </verify>
  <done>InitializationEffect handles app startup: SignalR connect, agents, topics</done>
</task>

<task type="auto">
  <name>Task 2: Create AgentSelectionEffect</name>
  <files>
    WebChat.Client/State/Effects/AgentSelectionEffect.cs
    WebChat.Client/Program.cs
  </files>
  <action>
Create `WebChat.Client/State/Effects/AgentSelectionEffect.cs`:

```csharp
using WebChat.Client.Contracts;
using WebChat.Client.State.Topics;

namespace WebChat.Client.State.Effects;

/// <summary>
/// Handles SelectAgent action side effects: clear session, save to localStorage.
/// </summary>
public sealed class AgentSelectionEffect : IDisposable
{
    private readonly TopicsStore _topicsStore;
    private readonly IChatSessionService _sessionService;
    private readonly ILocalStorageService _localStorage;
    private string? _previousAgentId;

    public AgentSelectionEffect(
        Dispatcher dispatcher,
        TopicsStore topicsStore,
        IChatSessionService sessionService,
        ILocalStorageService localStorage)
    {
        _topicsStore = topicsStore;
        _sessionService = sessionService;
        _localStorage = localStorage;

        // Subscribe to store to detect agent changes
        _topicsStore.StateObservable.Subscribe(HandleStateChange);
    }

    private void HandleStateChange(TopicsState state)
    {
        if (state.SelectedAgentId != _previousAgentId && _previousAgentId is not null)
        {
            // Agent changed - clear session and save
            _sessionService.ClearSession();
            _ = _localStorage.SetAsync("selectedAgentId", state.SelectedAgentId ?? "");
        }
        _previousAgentId = state.SelectedAgentId;
    }

    public void Dispose()
    {
        // Subscription is to the store, which manages its own lifecycle
    }
}
```

Register in Program.cs:
```csharp
builder.Services.AddSingleton<AgentSelectionEffect>();
```

And eagerly instantiate:
```csharp
host.Services.GetRequiredService<AgentSelectionEffect>();
```
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
AgentSelectionEffect.cs exists
AgentSelectionEffect.cs contains `ClearSession`
AgentSelectionEffect.cs contains `SetAsync`
Program.cs contains `AgentSelectionEffect`
  </verify>
  <done>AgentSelectionEffect handles agent change side effects</done>
</task>

<task type="auto">
  <name>Task 3: Simplify ChatContainer to composition root</name>
  <files>
    WebChat.Client/Components/Chat/ChatContainer.razor
  </files>
  <action>
Refactor ChatContainer.razor to minimal composition root with NO prop drilling:

```razor
@page "/"
@inherits StoreSubscriberComponent
@inject IDispatcher Dispatcher

<ApprovalModal />

<div class="chat-layout">
    <TopicList />

    <div class="chat-container">
        <MessageList />

        <ConnectionStatus />

        <div class="input-area">
            <ChatInput />
        </div>
    </div>
</div>

@code {
    protected override void OnInitialized()
    {
        Dispatcher.Dispatch(new Initialize());
    }
}
```

Key changes:
1. Remove ALL injections except IDispatcher
2. Remove ALL private fields
3. Remove ALL event handlers (moved to effects)
4. Remove StateManager usage completely
5. Remove ConnectionService event subscriptions
6. Remove StreamResumeService.SetRenderCallback
7. Remove Dispose method (StoreSubscriberComponent handles it)
8. OnInitialized just dispatches Initialize action
9. Child components receive NO props - they all subscribe to stores directly:
   - TopicList: subscribes to TopicsStore, StreamingStore, MessagesStore
   - MessageList: subscribes to MessagesStore, TopicsStore, StreamingStore (completed in 05-06)
   - ConnectionStatus: subscribes to ConnectionStore
   - ChatInput: subscribes to TopicsStore, StreamingStore, ConnectionStore
   - ApprovalModal: subscribes to ApprovalStore

The @using statements can be simplified to just what's needed.

Note: ConnectionStatus serves as the "header" component mentioned in success criteria - it displays connection state at the top of the message area. No separate header extraction is needed since ConnectionStatus provides the header functionality.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
ChatContainer.razor is under 100 lines total
ChatContainer.razor contains `@inherits StoreSubscriberComponent`
ChatContainer.razor contains `Dispatcher.Dispatch(new Initialize())`
ChatContainer.razor contains `<MessageList />` (no props)
ChatContainer.razor does NOT contain `StateManager`
ChatContainer.razor does NOT contain multiple event handler methods
ChatContainer.razor does NOT contain `TopicId=` or other prop passing
  </verify>
  <done>ChatContainer is thin composition root under 100 lines with no prop drilling</done>
</task>

</tasks>

<verification>
After all tasks:
1. `dotnet build WebChat.Client` compiles without errors
2. ChatContainer.razor:
   - Under 100 lines total (target ~50 lines)
   - Inherits StoreSubscriberComponent
   - Dispatches Initialize on mount
   - No StateManager usage
   - No business logic
   - No prop drilling to child components
3. InitializationEffect handles app startup
4. AgentSelectionEffect handles agent change side effects
5. All effects registered and instantiated
</verification>

<success_criteria>
- ChatContainer reduced from 305 to under 100 lines
- ChatContainer dispatches Initialize, effects handle all startup logic
- Agent selection side effects handled by AgentSelectionEffect
- Child components receive NO props (all subscribe to stores directly)
- No ChatStateManager references in ChatContainer
- ConnectionStatus serves as header component (displays connection state)
</success_criteria>

<output>
After completion, create `.planning/phases/05-component-architecture/05-05-SUMMARY.md`
</output>
