---
phase: 05-component-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/Components/Chat/ConnectionStatus.razor
  - WebChat.Client/Components/ChatInput.razor
  - WebChat.Client/State/Streaming/StreamingActions.cs
autonomous: true

must_haves:
  truths:
    - "ConnectionStatus renders based on ConnectionStore state"
    - "ChatInput dispatches actions instead of EventCallback"
    - "Components inherit StoreSubscriberComponent"
  artifacts:
    - path: "WebChat.Client/Components/Chat/ConnectionStatus.razor"
      provides: "Connection status display from store"
      contains: "@inherits StoreSubscriberComponent"
    - path: "WebChat.Client/Components/ChatInput.razor"
      provides: "Input with action dispatch"
      contains: "Dispatcher.Dispatch"
  key_links:
    - from: "ConnectionStatus.razor"
      to: "ConnectionStore"
      via: "Subscribe in OnInitialized"
      pattern: "Subscribe.*ConnectionStore"
    - from: "ChatInput.razor"
      to: "IDispatcher"
      via: "inject and dispatch"
      pattern: "@inject IDispatcher"
---

<objective>
Migrate leaf components (ConnectionStatus, ChatInput) to store-based pattern.

Purpose: Establish the component migration pattern with simplest components first. These components have no children and minimal state - ideal for demonstrating the store subscription and action dispatch patterns.

Output: Two components migrated to use stores instead of parameters/events.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-component-architecture/05-CONTEXT.md
@.planning/phases/05-component-architecture/05-RESEARCH.md
@WebChat.Client/State/StoreSubscriberComponent.cs
@WebChat.Client/State/Connection/ConnectionStore.cs
@WebChat.Client/State/Streaming/StreamingStore.cs
@WebChat.Client/State/IDispatcher.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate ConnectionStatus to store subscription</name>
  <files>
    WebChat.Client/Components/Chat/ConnectionStatus.razor
  </files>
  <action>
Refactor ConnectionStatus.razor to:
1. Add `@inherits StoreSubscriberComponent` directive
2. Inject `ConnectionStore` instead of using parameters
3. Remove `[Parameter]` properties (IsConnected, IsReconnecting)
4. Add private fields `_isConnected` and `_isReconnecting`
5. Override `OnInitialized()` to subscribe to `ConnectionStore.StateObservable`:
   - Use `Subscribe(ConnectionStore.StateObservable, state => state.Status, status => { ... })` selector
   - Map `ConnectionStatus.Connected` to `_isConnected = true`
   - Map `ConnectionStatus.Reconnecting` to `_isReconnecting = true`
6. Keep the existing markup that renders based on `_isConnected` and `_isReconnecting`

The component should be under 30 lines total.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
Component file contains `@inherits StoreSubscriberComponent`
Component file contains `Subscribe(ConnectionStore.StateObservable`
Component file does NOT contain `[Parameter]`
  </verify>
  <done>ConnectionStatus renders connection state from ConnectionStore subscription</done>
</task>

<task type="auto">
  <name>Task 2: Add SendMessage action and migrate ChatInput</name>
  <files>
    WebChat.Client/State/Streaming/StreamingActions.cs
    WebChat.Client/Components/ChatInput.razor
  </files>
  <action>
First, add new action to StreamingActions.cs:
```csharp
public record SendMessage(string? TopicId, string Message) : IAction;
```

Then refactor ChatInput.razor to:
1. Inject `IDispatcher` (keep existing `IJSRuntime` injection)
2. Inject `TopicsStore` and `StreamingStore` for reading state
3. Add `@inherits StoreSubscriberComponent`
4. Remove `[Parameter]` for OnSend, OnCancel, IsStreaming, Disabled
5. Add private fields: `_topicId`, `_isStreaming`, `_disabled`
6. Override `OnInitialized()`:
   - Subscribe to `TopicsStore.StateObservable` for `SelectedTopicId` and `SelectedAgentId`
   - Subscribe to `StreamingStore.StateObservable` for streaming status of selected topic
   - Compute `_disabled` from `SelectedAgentId` being null
7. Update `HandleSubmit()`:
   - Dispatch `new SendMessage(_topicId, message)` instead of `OnSend.InvokeAsync(message)`
   - Keep the textarea reset JS call
8. Update `HandleCancel()`:
   - Dispatch `new CancelStreaming(_topicId)` instead of `OnCancel.InvokeAsync()`
   - Add `CancelStreaming(string TopicId)` action to StreamingActions.cs

Note: CancelStreaming action added to StreamingActions.cs:
```csharp
public record CancelStreaming(string TopicId) : IAction;
```

Keep existing markup but reference the new private fields.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
ChatInput.razor contains `@inherits StoreSubscriberComponent`
ChatInput.razor contains `@inject IDispatcher`
ChatInput.razor contains `Dispatcher.Dispatch(new SendMessage`
StreamingActions.cs contains `public record SendMessage`
StreamingActions.cs contains `public record CancelStreaming`
  </verify>
  <done>ChatInput dispatches SendMessage and CancelStreaming actions instead of using EventCallback</done>
</task>

<task type="auto">
  <name>Task 3: Add ConnectionStore injection to ChatInput</name>
  <files>
    WebChat.Client/Components/ChatInput.razor
  </files>
  <action>
Update ChatInput to also consider connection status for the disabled state:
1. Inject `ConnectionStore`
2. Subscribe to `ConnectionStore.StateObservable` for connection status
3. Update `_disabled` computation: `_disabled = string.IsNullOrEmpty(_selectedAgentId) || !_isConnected`

This makes ChatInput fully self-contained - it reads all the state it needs from stores rather than receiving it via parameters.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
ChatInput.razor contains `@inject ConnectionStore`
ChatInput.razor contains connection status subscription
  </verify>
  <done>ChatInput determines disabled state from both TopicsStore and ConnectionStore</done>
</task>

</tasks>

<verification>
After all tasks:
1. `dotnet build WebChat.Client` compiles without errors
2. ConnectionStatus.razor:
   - Under 30 lines
   - Inherits StoreSubscriberComponent
   - Subscribes to ConnectionStore
   - No parameters
3. ChatInput.razor:
   - Under 80 lines
   - Inherits StoreSubscriberComponent
   - Injects IDispatcher, TopicsStore, StreamingStore, ConnectionStore
   - Dispatches SendMessage and CancelStreaming actions
   - No EventCallback parameters
</verification>

<success_criteria>
- ConnectionStatus displays connection state from ConnectionStore (not parameters)
- ChatInput dispatches actions for send/cancel (not EventCallback)
- Both components inherit StoreSubscriberComponent
- Both components compile and are syntactically correct
- SendMessage and CancelStreaming actions exist in StreamingActions.cs
</success_criteria>

<output>
After completion, create `.planning/phases/05-component-architecture/05-01-SUMMARY.md`
</output>
