---
phase: 05-component-architecture
plan: 06
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - WebChat.Client/Components/Chat/MessageList.razor
  - WebChat.Client/State/Messages/MessagesActions.cs
autonomous: true

must_haves:
  truths:
    - "MessageList subscribes to MessagesStore for messages by topic"
    - "MessageList subscribes to TopicsStore for selected topic ID and agent"
    - "MessageList subscribes to StreamingStore for streaming status"
    - "MessageList dispatches SendMessage for suggestion clicks"
    - "Component has no [Parameter] attributes"
  artifacts:
    - path: "WebChat.Client/Components/Chat/MessageList.razor"
      provides: "Message display with store subscriptions"
      contains: "@inherits StoreSubscriberComponent"
  key_links:
    - from: "MessageList.razor"
      to: "MessagesStore"
      via: "Subscribe in OnInitialized"
      pattern: "Subscribe.*MessagesStore"
    - from: "MessageList.razor"
      to: "TopicsStore"
      via: "Subscribe for selected topic"
      pattern: "Subscribe.*TopicsStore"
    - from: "MessageList.razor"
      to: "StreamingStore"
      via: "Subscribe for streaming status"
      pattern: "Subscribe.*StreamingStore"
---

<objective>
Migrate MessageList to store-based pattern with multiple subscriptions.

Purpose: MessageList currently receives all data via parameters (Messages, TopicId, IsStreaming, SelectedAgent). It should subscribe directly to stores to complete the component architecture migration. This enables ChatContainer to become a true composition root with no prop drilling.

Output: MessageList subscribes to MessagesStore, TopicsStore, and StreamingStore with no parameters.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-component-architecture/05-CONTEXT.md
@.planning/phases/05-component-architecture/05-01-SUMMARY.md
@WebChat.Client/State/StoreSubscriberComponent.cs
@WebChat.Client/State/Messages/MessagesStore.cs
@WebChat.Client/State/Topics/TopicsStore.cs
@WebChat.Client/State/Streaming/StreamingStore.cs
@WebChat.Client/Components/Chat/MessageList.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate MessageList to store subscriptions</name>
  <files>
    WebChat.Client/Components/Chat/MessageList.razor
  </files>
  <action>
Refactor MessageList.razor to use store subscriptions:

1. Add directives at top:
```razor
@inherits StoreSubscriberComponent
@inject MessagesStore MessagesStore
@inject TopicsStore TopicsStore
@inject StreamingStore StreamingStore
@inject IDispatcher Dispatcher
@inject IJSRuntime Js
```

2. Remove ALL `[Parameter]` properties:
   - Messages, TopicId, IsStreaming, SelectedAgent, OnSuggestionClicked

3. Add private fields:
```csharp
private IReadOnlyList<ChatMessageModel> _messages = [];
private string? _topicId;
private bool _isStreaming;
private AgentInfo? _selectedAgent;
private ElementReference _messagesArea;
private bool _shouldAutoScroll = true;
```

4. Override `OnInitialized()` with subscriptions:
```csharp
protected override void OnInitialized()
{
    // Subscribe to selected topic ID
    Subscribe(TopicsStore.StateObservable,
        state => state.SelectedTopicId,
        id => {
            _topicId = id;
            UpdateMessages();
        });

    // Subscribe to selected agent
    Subscribe(TopicsStore.StateObservable,
        state => state.Agents.FirstOrDefault(a => a.Id == state.SelectedAgentId),
        agent => _selectedAgent = agent);

    // Subscribe to messages for current topic
    Subscribe(MessagesStore.StateObservable,
        state => state,
        _ => UpdateMessages());

    // Subscribe to streaming status for current topic
    Subscribe(StreamingStore.StateObservable,
        state => _topicId != null && state.ActiveStreams.ContainsKey(_topicId),
        streaming => _isStreaming = streaming);
}

private void UpdateMessages()
{
    if (_topicId != null)
    {
        _messages = MessagesStore.State.MessagesByTopic.GetValueOrDefault(_topicId, []);
    }
    else
    {
        _messages = [];
    }
}
```

5. Update suggestion click handler to dispatch action:
```csharp
private void HandleSuggestionClicked(string suggestion)
{
    Dispatcher.Dispatch(new SendMessage(_topicId, suggestion));
}
```

6. Keep existing methods:
   - CheckAndUpdateAutoScroll()
   - SetShouldAutoScroll(bool value)
   - OnAfterRenderAsync(bool firstRender)

7. Update markup references:
   - `Messages` -> `_messages`
   - `TopicId` -> `_topicId`
   - `IsStreaming` -> `_isStreaming`
   - `SelectedAgent` -> `_selectedAgent`
   - `OnSuggestionClicked` -> `HandleSuggestionClicked`

The EmptyState child component still receives SelectedAgent as a prop (it's a simple display component).
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
MessageList.razor contains `@inherits StoreSubscriberComponent`
MessageList.razor contains `@inject MessagesStore`
MessageList.razor contains `@inject TopicsStore`
MessageList.razor contains `@inject StreamingStore`
MessageList.razor contains `Dispatcher.Dispatch(new SendMessage`
MessageList.razor does NOT contain `[Parameter]`
  </verify>
  <done>MessageList subscribes to stores and dispatches actions for suggestions</done>
</task>

<task type="auto">
  <name>Task 2: Handle streaming status subscription correctly</name>
  <files>
    WebChat.Client/Components/Chat/MessageList.razor
  </files>
  <action>
Refine the streaming status subscription to properly track topic changes:

The streaming subscription needs to re-evaluate when _topicId changes. Update the approach:

1. Create a combined subscription that depends on both topic and streaming state:
```csharp
// In OnInitialized, replace streaming subscription with:
Subscribe(StreamingStore.StateObservable,
    state => state.ActiveStreams,
    _ => UpdateStreamingStatus());

private void UpdateStreamingStatus()
{
    _isStreaming = _topicId != null && StreamingStore.State.ActiveStreams.ContainsKey(_topicId);
}
```

2. Call UpdateStreamingStatus() when topic changes:
```csharp
Subscribe(TopicsStore.StateObservable,
    state => state.SelectedTopicId,
    id => {
        _topicId = id;
        UpdateMessages();
        UpdateStreamingStatus();
    });
```

3. Keep the component under 80 lines in the @code block.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
MessageList.razor properly tracks streaming status per topic
Code block is under 80 lines
  </verify>
  <done>MessageList correctly tracks streaming status when topic changes</done>
</task>

</tasks>

<verification>
After all tasks:
1. `dotnet build WebChat.Client` compiles without errors
2. MessageList.razor:
   - Inherits StoreSubscriberComponent
   - Subscribes to MessagesStore, TopicsStore, StreamingStore
   - Dispatches SendMessage for suggestion clicks
   - No parameters
   - Code block under 80 lines
3. MessageList displays correct messages for selected topic
4. MessageList shows streaming indicator for active topic
</verification>

<success_criteria>
- MessageList displays messages from MessagesStore (not parameters)
- MessageList reads selected topic from TopicsStore (not parameter)
- MessageList reads streaming status from StreamingStore (not parameter)
- Suggestion clicks dispatch SendMessage action
- Component inherits StoreSubscriberComponent
- No [Parameter] attributes remain
</success_criteria>

<output>
After completion, create `.planning/phases/05-component-architecture/05-06-SUMMARY.md`
</output>
