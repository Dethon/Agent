---
phase: 05-component-architecture
plan: 04
type: execute
wave: 2
depends_on: [05-01, 05-02]
files_modified:
  - WebChat.Client/State/Effects/SendMessageEffect.cs
  - WebChat.Client/State/Effects/TopicSelectionEffect.cs
  - WebChat.Client/State/Effects/TopicDeleteEffect.cs
  - WebChat.Client/Program.cs
autonomous: true

must_haves:
  truths:
    - "SendMessageEffect handles message send coordination"
    - "TopicSelectionEffect handles topic switch with history load"
    - "TopicDeleteEffect handles topic deletion with streaming cancel"
    - "Effects are registered in DI container"
  artifacts:
    - path: "WebChat.Client/State/Effects/SendMessageEffect.cs"
      provides: "Message send coordination"
      contains: "RegisterHandler<SendMessage>"
    - path: "WebChat.Client/State/Effects/TopicSelectionEffect.cs"
      provides: "Topic selection with history load"
      contains: "RegisterHandler<SelectTopic>"
    - path: "WebChat.Client/State/Effects/TopicDeleteEffect.cs"
      provides: "Topic deletion with cleanup"
      contains: "RegisterHandler<RemoveTopic>"
  key_links:
    - from: "SendMessageEffect.cs"
      to: "IStreamingCoordinator"
      via: "StreamResponseAsync call"
      pattern: "StreamingCoordinator\\.StreamResponseAsync"
    - from: "TopicSelectionEffect.cs"
      to: "ITopicService"
      via: "GetHistoryAsync call"
      pattern: "TopicService\\.GetHistoryAsync"
---

<objective>
Create Effect classes for complex operations that require async coordination.

Purpose: Effects handle multi-step async operations that components should not manage. This separates business logic from render logic, making components thin and testable.

Output: Three Effect classes for SendMessage, TopicSelection, and TopicDelete.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-component-architecture/05-CONTEXT.md
@.planning/phases/05-component-architecture/05-RESEARCH.md
@WebChat.Client/State/Hub/ReconnectionEffect.cs
@WebChat.Client/State/Dispatcher.cs
@WebChat.Client/State/Topics/TopicsStore.cs
@WebChat.Client/State/Streaming/StreamingActions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SendMessageEffect</name>
  <files>
    WebChat.Client/State/Effects/SendMessageEffect.cs
  </files>
  <action>
Create new file `WebChat.Client/State/Effects/SendMessageEffect.cs`:

```csharp
using WebChat.Client.Contracts;
using WebChat.Client.Models;
using WebChat.Client.Services.Streaming;
using WebChat.Client.Services.Utilities;
using WebChat.Client.State.Messages;
using WebChat.Client.State.Streaming;
using WebChat.Client.State.Topics;

namespace WebChat.Client.State.Effects;

/// <summary>
/// Handles SendMessage action coordination: topic creation, session start, streaming.
/// </summary>
public sealed class SendMessageEffect : IDisposable
{
    private readonly Dispatcher _dispatcher;
    private readonly TopicsStore _topicsStore;
    private readonly IChatSessionService _sessionService;
    private readonly IStreamingCoordinator _streamingCoordinator;
    private readonly ITopicService _topicService;

    public SendMessageEffect(
        Dispatcher dispatcher,
        TopicsStore topicsStore,
        IChatSessionService sessionService,
        IStreamingCoordinator streamingCoordinator,
        ITopicService topicService)
    {
        _dispatcher = dispatcher;
        _topicsStore = topicsStore;
        _sessionService = sessionService;
        _streamingCoordinator = streamingCoordinator;
        _topicService = topicService;

        dispatcher.RegisterHandler<SendMessage>(HandleSendMessage);
    }

    private void HandleSendMessage(SendMessage action)
    {
        _ = HandleSendMessageAsync(action);
    }

    private async Task HandleSendMessageAsync(SendMessage action)
    {
        var state = _topicsStore.State;
        StoredTopic topic;

        if (string.IsNullOrEmpty(action.TopicId))
        {
            // Create new topic
            var topicName = action.Message.Length > 50 ? action.Message[..50] + "..." : action.Message;
            var topicId = TopicIdGenerator.GenerateTopicId();
            topic = new StoredTopic
            {
                TopicId = topicId,
                ChatId = TopicIdGenerator.GetChatIdForTopic(topicId),
                ThreadId = TopicIdGenerator.GetThreadIdForTopic(topicId),
                AgentId = state.SelectedAgentId!,
                Name = topicName,
                CreatedAt = DateTime.UtcNow
            };

            var success = await _sessionService.StartSessionAsync(topic);
            if (!success) return;

            _dispatcher.Dispatch(new AddTopic(topic));
            _dispatcher.Dispatch(new SelectTopic(topic.TopicId));
            _dispatcher.Dispatch(new SetMessages(topic.TopicId, []));
            await _topicService.SaveTopicAsync(topic.ToMetadata(), isNew: true);
        }
        else
        {
            topic = state.Topics.First(t => t.TopicId == action.TopicId);
            if (_sessionService.CurrentTopic?.TopicId != topic.TopicId)
            {
                await _sessionService.StartSessionAsync(topic);
            }
        }

        // Add user message
        _dispatcher.Dispatch(new AddMessage(topic.TopicId, new ChatMessageModel
        {
            Role = "user",
            Content = action.Message
        }));

        // Start streaming
        _dispatcher.Dispatch(new StreamStarted(topic.TopicId));

        // Kick off streaming (fire-and-forget)
        _ = _streamingCoordinator.StreamResponseAsync(topic, action.Message);
    }

    public void Dispose()
    {
        // No subscription to dispose, handler is registered with dispatcher
    }
}
```

Note: The effect needs SetMessages action - add to MessagesActions.cs if not present:
```csharp
public record SetMessages(string TopicId, IReadOnlyList<ChatMessageModel> Messages) : IAction;
```
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
SendMessageEffect.cs exists
SendMessageEffect.cs contains `RegisterHandler<SendMessage>`
SendMessageEffect.cs contains `StreamResponseAsync`
  </verify>
  <done>SendMessageEffect handles message send with topic creation, session start, and streaming coordination</done>
</task>

<task type="auto">
  <name>Task 2: Create TopicSelectionEffect</name>
  <files>
    WebChat.Client/State/Effects/TopicSelectionEffect.cs
  </files>
  <action>
Create new file `WebChat.Client/State/Effects/TopicSelectionEffect.cs`:

```csharp
using WebChat.Client.Contracts;
using WebChat.Client.Models;
using WebChat.Client.Services.Streaming;
using WebChat.Client.State.Messages;
using WebChat.Client.State.Topics;

namespace WebChat.Client.State.Effects;

/// <summary>
/// Handles SelectTopic action: loads history, starts session, resumes streaming.
/// </summary>
public sealed class TopicSelectionEffect : IDisposable
{
    private readonly Dispatcher _dispatcher;
    private readonly TopicsStore _topicsStore;
    private readonly MessagesStore _messagesStore;
    private readonly IChatSessionService _sessionService;
    private readonly ITopicService _topicService;
    private readonly IStreamResumeService _streamResumeService;

    public TopicSelectionEffect(
        Dispatcher dispatcher,
        TopicsStore topicsStore,
        MessagesStore messagesStore,
        IChatSessionService sessionService,
        ITopicService topicService,
        IStreamResumeService streamResumeService)
    {
        _dispatcher = dispatcher;
        _topicsStore = topicsStore;
        _messagesStore = messagesStore;
        _sessionService = sessionService;
        _topicService = topicService;
        _streamResumeService = streamResumeService;

        dispatcher.RegisterHandler<SelectTopic>(HandleSelectTopic);
    }

    private void HandleSelectTopic(SelectTopic action)
    {
        if (action.TopicId is null) return;

        _ = HandleSelectTopicAsync(action.TopicId);
    }

    private async Task HandleSelectTopicAsync(string topicId)
    {
        var topic = _topicsStore.State.Topics.FirstOrDefault(t => t.TopicId == topicId);
        if (topic is null) return;

        // Check if messages already loaded
        var hasMessages = _messagesStore.State.MessagesByTopic.ContainsKey(topicId);
        if (!hasMessages)
        {
            await _sessionService.StartSessionAsync(topic);
            var history = await _topicService.GetHistoryAsync(topic.ChatId, topic.ThreadId);
            var messages = history.Select(h => new ChatMessageModel
            {
                Role = h.Role,
                Content = h.Content
            }).ToList();
            _dispatcher.Dispatch(new SetMessages(topicId, messages));
        }

        // Try to resume any active streaming
        _ = _streamResumeService.TryResumeStreamAsync(topic);
    }

    public void Dispose()
    {
        // No subscription to dispose
    }
}
```
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
TopicSelectionEffect.cs exists
TopicSelectionEffect.cs contains `RegisterHandler<SelectTopic>`
TopicSelectionEffect.cs contains `GetHistoryAsync`
  </verify>
  <done>TopicSelectionEffect handles topic selection with history load and stream resume</done>
</task>

<task type="auto">
  <name>Task 3: Create TopicDeleteEffect and register effects in DI</name>
  <files>
    WebChat.Client/State/Effects/TopicDeleteEffect.cs
    WebChat.Client/Program.cs
  </files>
  <action>
First create `WebChat.Client/State/Effects/TopicDeleteEffect.cs`:

```csharp
using WebChat.Client.Contracts;
using WebChat.Client.State.Approval;
using WebChat.Client.State.Streaming;
using WebChat.Client.State.Topics;

namespace WebChat.Client.State.Effects;

/// <summary>
/// Handles RemoveTopic action: cancels streaming, deletes from server, clears approval.
/// </summary>
public sealed class TopicDeleteEffect : IDisposable
{
    private readonly Dispatcher _dispatcher;
    private readonly TopicsStore _topicsStore;
    private readonly StreamingStore _streamingStore;
    private readonly IChatMessagingService _messagingService;
    private readonly ITopicService _topicService;

    public TopicDeleteEffect(
        Dispatcher dispatcher,
        TopicsStore topicsStore,
        StreamingStore streamingStore,
        IChatMessagingService messagingService,
        ITopicService topicService)
    {
        _dispatcher = dispatcher;
        _topicsStore = topicsStore;
        _streamingStore = streamingStore;
        _messagingService = messagingService;
        _topicService = topicService;

        dispatcher.RegisterHandler<RemoveTopic>(HandleRemoveTopic);
    }

    private void HandleRemoveTopic(RemoveTopic action)
    {
        _ = HandleRemoveTopicAsync(action.TopicId);
    }

    private async Task HandleRemoveTopicAsync(string topicId)
    {
        var topic = _topicsStore.State.Topics.FirstOrDefault(t => t.TopicId == topicId);
        if (topic is null) return;

        // Cancel any active streaming
        if (_streamingStore.State.ActiveStreams.ContainsKey(topicId))
        {
            await _messagingService.CancelTopicAsync(topicId);
            _dispatcher.Dispatch(new StreamStopped(topicId));
        }

        // Delete from server
        await _topicService.DeleteTopicAsync(topicId, topic.ChatId, topic.ThreadId);

        // Clear approval if this was the selected topic
        if (_topicsStore.State.SelectedTopicId == topicId)
        {
            _dispatcher.Dispatch(new ClearApproval());
        }

        // Note: The reducer handles removing from state when RemoveTopic is dispatched
        // The effect handles the async side effects (cancel, delete from server)
    }

    public void Dispose()
    {
        // No subscription to dispose
    }
}
```

Then update `WebChat.Client/Program.cs` to register effects:

Find the DI registration section (where stores are registered) and add:
```csharp
// Effects (must be singletons to maintain subscriptions)
builder.Services.AddSingleton<SendMessageEffect>();
builder.Services.AddSingleton<TopicSelectionEffect>();
builder.Services.AddSingleton<TopicDeleteEffect>();
```

Also ensure effects are instantiated at startup. After `await builder.Build().RunAsync();` is NOT possible, so we need to use a different approach.

Option 1: Use IHostedService pattern
Option 2: Eager instantiation via GetRequiredService

The simplest approach is to request the effects from the service provider after building:

```csharp
var host = builder.Build();

// Eagerly instantiate effects so they register handlers
host.Services.GetRequiredService<ReconnectionEffect>();
host.Services.GetRequiredService<SendMessageEffect>();
host.Services.GetRequiredService<TopicSelectionEffect>();
host.Services.GetRequiredService<TopicDeleteEffect>();

await host.RunAsync();
```

If ReconnectionEffect is already registered and instantiated this way, add the new effects to that pattern.
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client`
TopicDeleteEffect.cs exists
TopicDeleteEffect.cs contains `RegisterHandler<RemoveTopic>`
Program.cs contains `SendMessageEffect`
Program.cs contains `TopicSelectionEffect`
Program.cs contains `TopicDeleteEffect`
  </verify>
  <done>TopicDeleteEffect handles deletion cleanup and all effects registered in DI</done>
</task>

</tasks>

<verification>
After all tasks:
1. `dotnet build WebChat.Client` compiles without errors
2. Effect files exist in `WebChat.Client/State/Effects/`:
   - SendMessageEffect.cs
   - TopicSelectionEffect.cs
   - TopicDeleteEffect.cs
3. All effects register handlers with Dispatcher
4. All effects are registered in Program.cs DI
5. Effects are eagerly instantiated at startup
</verification>

<success_criteria>
- SendMessageEffect coordinates topic creation, session start, and streaming
- TopicSelectionEffect loads history and resumes streaming on topic select
- TopicDeleteEffect cancels streaming and deletes from server
- All effects use fire-and-forget pattern for async operations
- Effects are registered as singletons and instantiated at startup
</success_criteria>

<output>
After completion, create `.planning/phases/05-component-architecture/05-04-SUMMARY.md`
</output>
