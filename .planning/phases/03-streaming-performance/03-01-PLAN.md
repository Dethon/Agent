---
phase: 03-streaming-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/State/Streaming/StreamingSelectors.cs
  - WebChat.Client/State/RenderCoordinator.cs
  - WebChat.Client/State/StoreSubscriberComponent.cs
  - WebChat.Client/Program.cs
  - Tests/Unit/WebChat.Client/State/RenderCoordinatorTests.cs
autonomous: true

must_haves:
  truths:
    - "RenderCoordinator provides 50ms-sampled observable for any topic's streaming content"
    - "StoreSubscriberComponent has SubscribeWithInvoke method that marshals to UI thread without additional throttling"
    - "StoreSubscriberComponent has ClearSubscriptions method for subscription cleanup"
    - "Streaming selectors can select per-topic content without triggering on other topic updates"
    - "Existing Subscribe methods already use InvokeAsync for thread-safe UI updates"
  artifacts:
    - path: "WebChat.Client/State/Streaming/StreamingSelectors.cs"
      provides: "Topic-scoped selectors for streaming content"
      exports: ["StreamingSelectors.SelectStreamingContent", "StreamingSelectors.SelectIsStreaming"]
    - path: "WebChat.Client/State/RenderCoordinator.cs"
      provides: "Centralized 50ms render tick service"
      exports: ["RenderCoordinator"]
    - path: "WebChat.Client/State/StoreSubscriberComponent.cs"
      provides: "SubscribeWithInvoke and ClearSubscriptions methods"
      contains: "SubscribeWithInvoke"
  key_links:
    - from: "WebChat.Client/State/RenderCoordinator.cs"
      to: "StreamingStore.StateObservable"
      via: "CreateStreamingObservable method"
      pattern: "Sample.*TimeSpan.*FromMilliseconds.*50"
    - from: "WebChat.Client/State/StoreSubscriberComponent.cs"
      to: "System.Reactive.Linq"
      via: "Sample operator import"
      pattern: "using System\\.Reactive\\.Linq"
---

<objective>
Create RenderCoordinator service and throttled subscription infrastructure for 50ms render windows.

Purpose: Establish the core plumbing that ensures streaming updates are batched into 50ms render windows using Rx.NET Sample operator, preventing UI freezes from high-frequency updates.

Output: RenderCoordinator service, StreamingSelectors for per-topic content, SubscribeWithInvoke and ClearSubscriptions methods on StoreSubscriberComponent.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-performance/03-CONTEXT.md
@.planning/phases/03-streaming-performance/03-RESEARCH.md
@WebChat.Client/State/Store.cs
@WebChat.Client/State/StoreSubscriberComponent.cs
@WebChat.Client/State/Streaming/StreamingStore.cs
@WebChat.Client/State/Streaming/StreamingState.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamingSelectors for topic-scoped content selection</name>
  <files>WebChat.Client/State/Streaming/StreamingSelectors.cs</files>
  <action>
Create static StreamingSelectors class with factory methods for topic-scoped selection:

1. `SelectStreamingContent(string topicId)` - returns `Func<StreamingState, StreamingContent?>` that extracts content for a specific topic
2. `SelectIsStreaming(string topicId)` - returns `Func<StreamingState, bool>` that checks if topic is streaming
3. `SelectStreamingTopics()` - returns `Func<StreamingState, IReadOnlySet<string>>` for the set of streaming topics

These are selector factories that return selectors, enabling topic-specific subscriptions.

Pattern:
```csharp
public static class StreamingSelectors
{
    public static Func<StreamingState, StreamingContent?> SelectStreamingContent(string topicId)
        => state => state.StreamingByTopic.GetValueOrDefault(topicId);
}
```
  </action>
  <verify>File compiles with `dotnet build WebChat.Client`</verify>
  <done>StreamingSelectors.cs exists with 3 selector factory methods</done>
</task>

<task type="auto">
  <name>Task 2: Create RenderCoordinator service with 50ms Sample operator</name>
  <files>WebChat.Client/State/RenderCoordinator.cs, WebChat.Client/Program.cs</files>
  <action>
Create RenderCoordinator service that provides throttled observables:

1. Constructor injects StreamingStore
2. `CreateStreamingObservable(string topicId)` returns:
   - StreamingStore.StateObservable
   - Select(StreamingSelectors.SelectStreamingContent(topicId))
   - Sample(TimeSpan.FromMilliseconds(50)) - use Sample NOT Throttle (Throttle is debounce in Rx.NET)
   - DistinctUntilChanged()
3. `CreateIsStreamingObservable(string topicId)` - same pattern for IsStreaming boolean
4. Make class `sealed` and implement IDisposable (even though no subscriptions owned, for consistency)

IMPORTANT: Use `Sample` operator, NOT `Throttle`. Rx.NET Throttle is actually debounce (resets on each event). Sample emits the latest value at fixed intervals which is what we need for periodic render ticks.

IMPORTANT: This is the ONLY place where Sample is applied. Consumer code (SubscribeWithInvoke) does NOT apply Sample again - RenderCoordinator owns the throttling responsibility.

Register in Program.cs as singleton: `builder.Services.AddSingleton<RenderCoordinator>()`
  </action>
  <verify>`dotnet build WebChat.Client` succeeds and RenderCoordinator is injectable</verify>
  <done>RenderCoordinator service exists with Sample-based throttled observables and is registered in DI</done>
</task>

<task type="auto">
  <name>Task 3: Add SubscribeWithInvoke and ClearSubscriptions methods to StoreSubscriberComponent and write tests</name>
  <files>WebChat.Client/State/StoreSubscriberComponent.cs, Tests/Unit/WebChat.Client/State/RenderCoordinatorTests.cs</files>
  <action>
1. Add `ClearSubscriptions` method to StoreSubscriberComponent for re-subscription scenarios:

```csharp
/// <summary>
/// Clear all current subscriptions. Use when component needs to re-subscribe
/// (e.g., when TopicId parameter changes).
/// </summary>
protected void ClearSubscriptions()
{
    _subscriptions.Clear();
}
```

2. Add `SubscribeWithInvoke` method to StoreSubscriberComponent for pre-throttled observables:

```csharp
/// <summary>
/// Subscribe to an already-throttled observable (e.g., from RenderCoordinator).
/// Only marshals to UI thread via InvokeAsync - does NOT apply additional throttling.
/// Use this for observables that already have Sample applied by RenderCoordinator.
/// </summary>
protected void SubscribeWithInvoke<T>(
    IObservable<T> throttledObservable,
    Action<T> onNext)
{
    var subscription = throttledObservable
        .Subscribe(value =>
        {
            InvokeAsync(() =>
            {
                if (_disposed) return;
                onNext(value);
                StateHasChanged();
            });
        });
    _subscriptions.Add(subscription);
}
```

NOTE: This method does NOT apply Sample - RenderCoordinator already handles throttling. The name "SubscribeWithInvoke" clarifies that its only responsibility is InvokeAsync marshaling, not throttling.

3. Create RenderCoordinatorTests.cs with tests:
   - `CreateStreamingObservable_ReturnsObservable_ForTopic` - verifies observable is created
   - `CreateStreamingObservable_EmitsAtSampleInterval` - verifies Sample behavior (use TestScheduler if available, or simple timing test)
   - `CreateStreamingObservable_EmitsNull_WhenTopicNotStreaming`
   - `CreateIsStreamingObservable_ReturnsCorrectBoolean`
  </action>
  <verify>`dotnet test Tests --filter "RenderCoordinator"` passes all tests</verify>
  <done>SubscribeWithInvoke and ClearSubscriptions methods exist; RenderCoordinator tests pass</done>
</task>

</tasks>

<verification>
1. `dotnet build WebChat.Client` succeeds
2. `dotnet test Tests --filter "RenderCoordinator"` passes
3. RenderCoordinator is injectable in any component
4. Sample operator is used (not Throttle) - grep for `\.Sample\(`
5. Sample is applied ONLY in RenderCoordinator, not in SubscribeWithInvoke
</verification>

<success_criteria>
- RenderCoordinator creates 50ms-sampled observables for topic-specific streaming content
- StoreSubscriberComponent has SubscribeWithInvoke method (no Sample - just InvokeAsync marshaling)
- StoreSubscriberComponent has ClearSubscriptions method for re-subscription cleanup
- StreamingSelectors enable topic-scoped content selection
- All new code follows InvokeAsync pattern for thread safety
- Tests verify Sample behavior
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-performance/03-01-SUMMARY.md`
</output>
