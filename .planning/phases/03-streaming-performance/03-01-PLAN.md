---
phase: 03-streaming-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/State/Streaming/StreamingSelectors.cs
  - WebChat.Client/State/RenderCoordinator.cs
  - WebChat.Client/State/StoreSubscriberComponent.cs
  - WebChat.Client/Program.cs
  - Tests/Unit/WebChat.Client/State/RenderCoordinatorTests.cs
autonomous: true

must_haves:
  truths:
    - "RenderCoordinator provides 50ms-sampled observable for any topic's streaming content"
    - "StoreSubscriberComponent has throttled subscription method using Sample operator"
    - "Streaming selectors can select per-topic content without triggering on other topic updates"
  artifacts:
    - path: "WebChat.Client/State/Streaming/StreamingSelectors.cs"
      provides: "Topic-scoped selectors for streaming content"
      exports: ["StreamingSelectors.SelectStreamingContent", "StreamingSelectors.SelectIsStreaming"]
    - path: "WebChat.Client/State/RenderCoordinator.cs"
      provides: "Centralized 50ms render tick service"
      exports: ["RenderCoordinator"]
    - path: "WebChat.Client/State/StoreSubscriberComponent.cs"
      provides: "SubscribeThrottled method for sampled subscriptions"
      contains: "SubscribeThrottled"
  key_links:
    - from: "WebChat.Client/State/RenderCoordinator.cs"
      to: "StreamingStore.StateObservable"
      via: "CreateStreamingObservable method"
      pattern: "Sample.*TimeSpan.*FromMilliseconds.*50"
    - from: "WebChat.Client/State/StoreSubscriberComponent.cs"
      to: "System.Reactive.Linq"
      via: "Sample operator import"
      pattern: "using System\\.Reactive\\.Linq"
---

<objective>
Create RenderCoordinator service and throttled subscription infrastructure for 50ms render windows.

Purpose: Establish the core plumbing that ensures streaming updates are batched into 50ms render windows using Rx.NET Sample operator, preventing UI freezes from high-frequency updates.

Output: RenderCoordinator service, StreamingSelectors for per-topic content, SubscribeThrottled method on StoreSubscriberComponent.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-performance/03-CONTEXT.md
@.planning/phases/03-streaming-performance/03-RESEARCH.md
@WebChat.Client/State/Store.cs
@WebChat.Client/State/StoreSubscriberComponent.cs
@WebChat.Client/State/Streaming/StreamingStore.cs
@WebChat.Client/State/Streaming/StreamingState.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamingSelectors for topic-scoped content selection</name>
  <files>WebChat.Client/State/Streaming/StreamingSelectors.cs</files>
  <action>
Create static StreamingSelectors class with factory methods for topic-scoped selection:

1. `SelectStreamingContent(string topicId)` - returns `Func<StreamingState, StreamingContent?>` that extracts content for a specific topic
2. `SelectIsStreaming(string topicId)` - returns `Func<StreamingState, bool>` that checks if topic is streaming
3. `SelectStreamingTopics()` - returns `Func<StreamingState, IReadOnlySet<string>>` for the set of streaming topics

These are selector factories that return selectors, enabling topic-specific subscriptions.

Pattern:
```csharp
public static class StreamingSelectors
{
    public static Func<StreamingState, StreamingContent?> SelectStreamingContent(string topicId)
        => state => state.StreamingByTopic.GetValueOrDefault(topicId);
}
```
  </action>
  <verify>File compiles with `dotnet build WebChat.Client`</verify>
  <done>StreamingSelectors.cs exists with 3 selector factory methods</done>
</task>

<task type="auto">
  <name>Task 2: Create RenderCoordinator service with 50ms Sample operator</name>
  <files>WebChat.Client/State/RenderCoordinator.cs, WebChat.Client/Program.cs</files>
  <action>
Create RenderCoordinator service that provides throttled observables:

1. Constructor injects StreamingStore
2. `CreateStreamingObservable(string topicId)` returns:
   - StreamingStore.StateObservable
   - Select(StreamingSelectors.SelectStreamingContent(topicId))
   - Sample(TimeSpan.FromMilliseconds(50)) - use Sample NOT Throttle (Throttle is debounce in Rx.NET)
   - DistinctUntilChanged()
3. `CreateIsStreamingObservable(string topicId)` - same pattern for IsStreaming boolean
4. Make class `sealed` and implement IDisposable (even though no subscriptions owned, for consistency)

IMPORTANT: Use `Sample` operator, NOT `Throttle`. Rx.NET Throttle is actually debounce (resets on each event). Sample emits the latest value at fixed intervals which is what we need for periodic render ticks.

Register in Program.cs as singleton: `builder.Services.AddSingleton<RenderCoordinator>()`
  </action>
  <verify>`dotnet build WebChat.Client` succeeds and RenderCoordinator is injectable</verify>
  <done>RenderCoordinator service exists with Sample-based throttled observables and is registered in DI</done>
</task>

<task type="auto">
  <name>Task 3: Add SubscribeThrottled method to StoreSubscriberComponent and write tests</name>
  <files>WebChat.Client/State/StoreSubscriberComponent.cs, Tests/Unit/WebChat.Client/State/RenderCoordinatorTests.cs</files>
  <action>
1. Add `SubscribeThrottled` method to StoreSubscriberComponent:

```csharp
protected void SubscribeThrottled<T>(
    IObservable<T> observable,
    TimeSpan throttleInterval,
    Action<T> onNext)
{
    var subscription = observable
        .Sample(throttleInterval)
        .Subscribe(value =>
        {
            InvokeAsync(() =>
            {
                if (_disposed) return;
                onNext(value);
                StateHasChanged();
            });
        });
    _subscriptions.Add(subscription);
}
```

2. Create RenderCoordinatorTests.cs with tests:
   - `CreateStreamingObservable_ReturnsObservable_ForTopic` - verifies observable is created
   - `CreateStreamingObservable_EmitsAtSampleInterval` - verifies Sample behavior (use TestScheduler if available, or simple timing test)
   - `CreateStreamingObservable_EmitsNull_WhenTopicNotStreaming`
   - `CreateIsStreamingObservable_ReturnsCorrectBoolean`
  </action>
  <verify>`dotnet test Tests --filter "RenderCoordinator"` passes all tests</verify>
  <done>SubscribeThrottled method exists and RenderCoordinator tests pass</done>
</task>

</tasks>

<verification>
1. `dotnet build WebChat.Client` succeeds
2. `dotnet test Tests --filter "RenderCoordinator"` passes
3. RenderCoordinator is injectable in any component
4. Sample operator is used (not Throttle) - grep for `\.Sample\(`
</verification>

<success_criteria>
- RenderCoordinator creates 50ms-sampled observables for topic-specific streaming content
- StoreSubscriberComponent has SubscribeThrottled method with Sample operator
- StreamingSelectors enable topic-scoped content selection
- All new code follows InvokeAsync pattern for thread safety
- Tests verify Sample behavior
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-performance/03-01-SUMMARY.md`
</output>
