---
phase: 03-streaming-performance
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - WebChat.Client/Components/Chat/MessageList.razor
  - WebChat.Client/Components/Chat/StreamingMessageDisplay.razor
  - WebChat.Client/wwwroot/js/app.js
autonomous: true

must_haves:
  truths:
    - "MessageList subscribes to streaming state with 50ms Sample throttle"
    - "Streaming content updates only re-render the streaming message area"
    - "Smart auto-scroll only scrolls when user is at bottom"
    - "Topic sidebar does not re-render during streaming"
  artifacts:
    - path: "WebChat.Client/Components/Chat/MessageList.razor"
      provides: "Store-integrated message list with throttled streaming subscription"
      contains: "RenderCoordinator"
    - path: "WebChat.Client/Components/Chat/StreamingMessageDisplay.razor"
      provides: "Isolated streaming message component"
      contains: "StreamingContent"
  key_links:
    - from: "WebChat.Client/Components/Chat/MessageList.razor"
      to: "RenderCoordinator"
      via: "injected service"
      pattern: "@inject RenderCoordinator"
    - from: "WebChat.Client/Components/Chat/StreamingMessageDisplay.razor"
      to: "StreamingContent"
      via: "parameter binding"
      pattern: "\\[Parameter\\].*StreamingContent"
---

<objective>
Wire MessageList component to use RenderCoordinator for throttled streaming updates with smart auto-scroll.

Purpose: Connect the throttling infrastructure to the message display, ensuring streaming updates are batched at 50ms intervals and only re-render the streaming message area, not the sidebar or other components.

Output: MessageList integrated with RenderCoordinator, StreamingMessageDisplay component for isolated rendering, smart auto-scroll with smooth behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-performance/03-CONTEXT.md
@.planning/phases/03-streaming-performance/03-RESEARCH.md
@.planning/phases/03-streaming-performance/03-01-SUMMARY.md
@WebChat.Client/Components/Chat/MessageList.razor
@WebChat.Client/Components/ChatMessage.razor
@WebChat.Client/Models/ChatMessageModel.cs
@WebChat.Client/State/RenderCoordinator.cs
@WebChat.Client/State/StoreSubscriberComponent.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamingMessageDisplay component for isolated rendering</name>
  <files>WebChat.Client/Components/Chat/StreamingMessageDisplay.razor</files>
  <action>
Create a new component that handles streaming message display with store subscription:

```razor
@using WebChat.Client.State
@using WebChat.Client.State.Streaming
@using WebChat.Client.Models
@inherits StoreSubscriberComponent
@inject RenderCoordinator RenderCoordinator

@code {
    [Parameter, EditorRequired] public string TopicId { get; set; } = "";

    private StreamingContent? _streamingContent;
    private string _previousTopicId = "";

    protected override void OnParametersSet()
    {
        if (_previousTopicId != TopicId)
        {
            _previousTopicId = TopicId;
            ResubscribeToTopic();
        }
    }

    private void ResubscribeToTopic()
    {
        // Clear existing subscriptions (inherited from StoreSubscriberComponent)
        ClearSubscriptions();

        if (string.IsNullOrEmpty(TopicId)) return;

        // Subscribe to throttled streaming content for this topic only
        // Use SubscribeWithInvoke since RenderCoordinator already applies 50ms Sample
        SubscribeWithInvoke(
            RenderCoordinator.CreateStreamingObservable(TopicId),
            content => _streamingContent = content);
    }
}

@if (_streamingContent is not null)
{
    <ChatMessage Message="@CreateMessageModel()" IsStreaming="true"/>
}

@code {
    private ChatMessageModel CreateMessageModel() => new()
    {
        Role = "assistant",
        Content = _streamingContent?.Content ?? "",
        Reasoning = _streamingContent?.Reasoning,
        ToolCalls = _streamingContent?.ToolCalls,
        IsError = _streamingContent?.IsError ?? false
    };
}
```

The component:
1. Inherits StoreSubscriberComponent for subscription management
2. Uses RenderCoordinator.CreateStreamingObservable for 50ms-sampled updates
3. Uses SubscribeWithInvoke (NOT SubscribeThrottled) since RenderCoordinator already applies Sample
4. Re-subscribes when TopicId changes using ClearSubscriptions()
5. Only renders when _streamingContent is not null
6. Isolation: this component re-renders independently of parent

IMPORTANT: Uses ChatMessageModel from WebChat.Client.Models namespace (verified to exist at WebChat.Client/Models/ChatMessageModel.cs).
  </action>
  <verify>Build succeeds with `dotnet build WebChat.Client`</verify>
  <done>StreamingMessageDisplay component exists with isolated store subscription</done>
</task>

<task type="auto">
  <name>Task 2: Update MessageList to use StreamingMessageDisplay and smart auto-scroll</name>
  <files>WebChat.Client/Components/Chat/MessageList.razor, WebChat.Client/wwwroot/js/app.js</files>
  <action>
1. Update MessageList.razor to use StreamingMessageDisplay:

Replace the existing streaming message rendering:
```razor
@if (IsStreaming && StreamingMessage is not null)
{
    <ChatMessage Message="@StreamingMessage" IsStreaming="true"/>
}
```

With:
```razor
@if (IsStreaming && !string.IsNullOrEmpty(TopicId))
{
    <StreamingMessageDisplay TopicId="@TopicId"/>
}
```

Add TopicId parameter to MessageList:
```csharp
[Parameter] public string TopicId { get; set; } = "";
```

2. Update auto-scroll to use smooth behavior:

In app.js, verify/update chatScroll.scrollToBottom to use smooth scroll for streaming:
```javascript
window.chatScroll = {
    isAtBottom: function(element) {
        if (!element) return true;
        const threshold = 50;
        return element.scrollHeight - element.scrollTop - element.clientHeight <= threshold;
    },

    scrollToBottom: function(element, smooth) {
        if (!element) return;
        element.scrollTo({
            top: element.scrollHeight,
            behavior: smooth ? 'smooth' : 'instant'
        });
    }
};
```

3. Modify OnAfterRenderAsync to use smooth scroll:
```csharp
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (_shouldAutoScroll)
    {
        await Js.InvokeVoidAsync("chatScroll.scrollToBottom", _messagesArea, true); // smooth=true
    }
}
```

4. Remove StreamingMessage parameter since streaming is now handled by child component:
- Remove: `[Parameter] public ChatMessageModel? StreamingMessage { get; set; }`
- Keep IsStreaming for showing/hiding StreamingMessageDisplay
  </action>
  <verify>Build succeeds with `dotnet build WebChat.Client`</verify>
  <done>MessageList uses StreamingMessageDisplay component with smooth auto-scroll</done>
</task>

<task type="auto">
  <name>Task 3: Update ChatContainer to pass TopicId to MessageList</name>
  <files>WebChat.Client/Components/Chat/ChatContainer.razor</files>
  <action>
Update ChatContainer.razor to pass TopicId parameter to MessageList:

1. Find the MessageList usage and add TopicId:
```razor
<MessageList @ref="_messageList"
             Messages="@StateManager.CurrentMessages"
             TopicId="@(StateManager.SelectedTopic?.TopicId ?? "")"
             IsStreaming="@StateManager.IsCurrentTopicStreaming"
             SelectedAgent="@SelectedAgent"
             OnSuggestionClicked="SendSuggestion"/>
```

2. Remove the StreamingMessage parameter since MessageList no longer uses it:
- Remove: `StreamingMessage="@StateManager.CurrentStreamingMessage"`

The streaming content is now fetched directly by StreamingMessageDisplay from the store via RenderCoordinator, not passed down from ChatContainer. This eliminates the prop-drilling that caused cascade re-renders.
  </action>
  <verify>Build succeeds with `dotnet build WebChat.Client`</verify>
  <done>ChatContainer passes TopicId to MessageList, streaming data flows through stores not props</done>
</task>

</tasks>

<verification>
1. `dotnet build WebChat.Client` succeeds
2. Streaming content is displayed via StreamingMessageDisplay
3. Auto-scroll uses smooth behavior
4. No StreamingMessage prop drilling (streaming state comes from store)
5. MessageList receives TopicId parameter
</verification>

<success_criteria>
- MessageList subscribes to streaming state via RenderCoordinator with 50ms Sample
- StreamingMessageDisplay re-renders independently (sidebar not affected)
- Smart auto-scroll only scrolls when user at bottom, uses smooth animation
- Topic sidebar does not flicker during streaming (no prop-driven cascade)
- Streaming updates batched at 50ms intervals (not every token)
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-performance/03-03-SUMMARY.md`
</output>
