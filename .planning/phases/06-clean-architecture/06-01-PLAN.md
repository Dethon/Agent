---
phase: 06-clean-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Domain/Contracts/IHubNotificationSender.cs
  - Infrastructure/Clients/Messaging/HubNotifier.cs
  - Agent/Hubs/HubNotificationAdapter.cs
  - Agent/Hubs/Notifier.cs
  - Agent/Modules/InjectorModule.cs
autonomous: true

must_haves:
  truths:
    - "INotifier implementation lives in Infrastructure layer"
    - "Agent layer only contains adapter for IHubContext"
    - "Dependency flow is Domain <- Infrastructure <- Agent"
  artifacts:
    - path: "Domain/Contracts/IHubNotificationSender.cs"
      provides: "Abstraction for hub notification sending"
      exports: ["IHubNotificationSender"]
    - path: "Infrastructure/Clients/Messaging/HubNotifier.cs"
      provides: "INotifier implementation using IHubNotificationSender"
      exports: ["HubNotifier"]
    - path: "Agent/Hubs/HubNotificationAdapter.cs"
      provides: "IHubNotificationSender implementation using IHubContext<ChatHub>"
      exports: ["HubNotificationAdapter"]
  key_links:
    - from: "HubNotifier"
      to: "IHubNotificationSender"
      via: "constructor injection"
      pattern: "HubNotifier.*IHubNotificationSender"
    - from: "HubNotificationAdapter"
      to: "IHubContext<ChatHub>"
      via: "constructor injection"
      pattern: "HubNotificationAdapter.*IHubContext"
    - from: "InjectorModule"
      to: "HubNotifier, HubNotificationAdapter"
      via: "DI registration"
      pattern: "AddSingleton.*INotifier.*HubNotifier"
---

<objective>
Migrate INotifier implementation from Agent/Hubs to Infrastructure layer while maintaining functionality.

Purpose: The current Notifier class in Agent/Hubs violates clean architecture - business logic (notification routing) should not live in the composition root. By abstracting the hub dependency, we can move the INotifier implementation to Infrastructure where it belongs.

Output: INotifier implementation in Infrastructure that delegates hub-specific work to an adapter in Agent.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-clean-architecture/06-CONTEXT.md

@Domain/Contracts/INotifier.cs
@Agent/Hubs/Notifier.cs
@Agent/Modules/InjectorModule.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IHubNotificationSender interface and HubNotifier implementation</name>
  <files>
    Domain/Contracts/IHubNotificationSender.cs
    Infrastructure/Clients/Messaging/HubNotifier.cs
  </files>
  <action>
1. Create `IHubNotificationSender` interface in `Domain/Contracts/`:
   - Single method: `Task SendAsync(string methodName, object notification, CancellationToken cancellationToken)`
   - This abstracts the SignalR `SendAsync` pattern without knowing about IHubContext

2. Create `HubNotifier` class in `Infrastructure/Clients/Messaging/`:
   - Implements `INotifier` (same as current Notifier)
   - Takes `IHubNotificationSender` via constructor injection (not IHubContext)
   - Each notification method calls `_sender.SendAsync("OnXxx", notification, cancellationToken)`
   - Method names: "OnTopicChanged", "OnStreamChanged", "OnNewMessage", "OnApprovalResolved", "OnToolCalls"
   - Same async pattern as current Notifier, just delegates to IHubNotificationSender

Rationale: This allows Infrastructure to implement INotifier without knowing about SignalR specifics. The hub context dependency is pushed to the Agent layer where it belongs.
  </action>
  <verify>
    - `dotnet build Domain/Domain.csproj` succeeds
    - `dotnet build Infrastructure/Infrastructure.csproj` succeeds
    - Grep confirms HubNotifier implements INotifier: `grep -l "HubNotifier.*:.*INotifier" Infrastructure/`
  </verify>
  <done>
    - IHubNotificationSender interface exists in Domain/Contracts
    - HubNotifier class exists in Infrastructure/Clients/Messaging
    - HubNotifier implements INotifier and uses IHubNotificationSender
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HubNotificationAdapter and update DI registration</name>
  <files>
    Agent/Hubs/HubNotificationAdapter.cs
    Agent/Hubs/Notifier.cs
    Agent/Modules/InjectorModule.cs
  </files>
  <action>
1. Create `HubNotificationAdapter` class in `Agent/Hubs/`:
   - Implements `IHubNotificationSender` from Domain/Contracts
   - Takes `IHubContext<ChatHub>` via constructor injection
   - `SendAsync` method: `await _hubContext.Clients.All.SendAsync(methodName, notification, cancellationToken)`
   - This is the only class that knows about IHubContext<ChatHub>

2. Delete the old `Notifier.cs` file from Agent/Hubs (it's replaced by HubNotifier in Infrastructure)

3. Update `AddWebClient()` in `InjectorModule.cs`:
   - Remove: `.AddSingleton<INotifier, Notifier>()`
   - Add: `.AddSingleton<IHubNotificationSender, HubNotificationAdapter>()`
   - Add: `.AddSingleton<INotifier, HubNotifier>()`
   - Order matters: IHubNotificationSender must be registered before INotifier (which depends on it)

Rationale: The adapter pattern keeps SignalR-specific code in Agent while allowing Infrastructure to implement the business logic of notification routing.
  </action>
  <verify>
    - `dotnet build Agent/Agent.csproj` succeeds
    - Old Notifier.cs file no longer exists: `test ! -f Agent/Hubs/Notifier.cs`
    - Grep confirms adapter registration: `grep "IHubNotificationSender.*HubNotificationAdapter" Agent/`
    - Full solution builds: `dotnet build`
  </verify>
  <done>
    - HubNotificationAdapter exists in Agent/Hubs implementing IHubNotificationSender
    - Old Notifier.cs deleted from Agent/Hubs
    - DI registration updated in InjectorModule.cs
    - Agent project builds successfully
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify layer compliance and run tests</name>
  <files>None (verification only)</files>
  <action>
1. Verify dependency flow:
   - Domain has no using statements for Infrastructure or Agent
   - Infrastructure has no using statements for Agent
   - Only Agent references both Infrastructure and Domain

2. Verify INotifier implementation location:
   - `grep -r "class.*:.*INotifier" --include="*.cs"` should only show Infrastructure/Clients/Messaging/HubNotifier.cs
   - No INotifier implementations in Agent/ (except the old deleted one)

3. Run full test suite:
   - `dotnet test Tests/Tests.csproj`
   - All existing tests should pass (notification behavior unchanged)

4. Verify ChatHub still works:
   - ChatHub.cs should still inject INotifier (unchanged)
   - The injected INotifier is now HubNotifier from Infrastructure

Rationale: This ensures the refactoring maintained existing behavior while improving architecture.
  </action>
  <verify>
    - `grep -r "using Agent" Infrastructure/` returns no results
    - `grep -r "using Infrastructure" Domain/` returns no results
    - `dotnet test` passes all tests
    - `grep -l "INotifier" Agent/Hubs/ChatHub.cs` confirms ChatHub still uses INotifier
  </verify>
  <done>
    - No layer violations detected
    - All tests pass
    - ChatHub continues to function with injected INotifier
    - ARCH-01 requirement satisfied: INotifier implementation in Infrastructure
  </done>
</task>

</tasks>

<verification>
1. Build verification: `dotnet build` succeeds for entire solution
2. Test verification: `dotnet test` passes all existing tests
3. Layer verification:
   - `grep -r "using Agent" Infrastructure/` returns empty
   - `grep -r "using Infrastructure" Domain/` returns empty
4. Implementation location: HubNotifier.cs exists in Infrastructure/Clients/Messaging/
</verification>

<success_criteria>
- INotifier implementation (HubNotifier) exists in Infrastructure/Clients/Messaging
- IHubNotificationSender interface exists in Domain/Contracts
- HubNotificationAdapter exists in Agent/Hubs (the only SignalR-aware class)
- Old Notifier.cs deleted from Agent/Hubs
- DI registration updated in InjectorModule.cs
- All tests pass
- No layer violations
</success_criteria>

<output>
After completion, create `.planning/phases/06-clean-architecture/06-01-SUMMARY.md`
</output>
