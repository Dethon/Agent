---
phase: 08-user-identity
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - WebChat.Client/Components/UserIdentityPicker.razor
  - WebChat.Client/State/Effects/UserIdentityEffect.cs
  - WebChat.Client/Extensions/ServiceCollectionExtensions.cs
  - WebChat.Client/Program.cs
  - WebChat.Client/Layout/MainLayout.razor
  - WebChat.Client/wwwroot/css/app.css
autonomous: true

must_haves:
  truths:
    - "User sees circular avatar button in header when app loads"
    - "Clicking avatar button opens dropdown with available users"
    - "Selecting a user closes dropdown and shows their avatar"
    - "Selected user persists across page refresh"
    - "Question mark icon shown when no user selected"
  artifacts:
    - path: "WebChat.Client/Components/UserIdentityPicker.razor"
      provides: "Circular avatar dropdown component"
      contains: "avatar-button"
    - path: "WebChat.Client/State/Effects/UserIdentityEffect.cs"
      provides: "Effect for loading users and localStorage persistence"
      contains: "UserIdentityEffect"
    - path: "WebChat.Client/Layout/MainLayout.razor"
      provides: "Header integration"
      contains: "UserIdentityPicker"
  key_links:
    - from: "UserIdentityPicker"
      to: "UserIdentityStore"
      via: "StoreSubscriberComponent subscription"
      pattern: "Subscribe.*StateObservable"
    - from: "UserIdentityEffect"
      to: "ILocalStorageService"
      via: "localStorage persistence"
      pattern: "localStorage\\.(Get|Set)Async"
    - from: "MainLayout.razor"
      to: "UserIdentityPicker"
      via: "component inclusion"
      pattern: "<UserIdentityPicker"
---

<objective>
Create the UserIdentityPicker UI component with circular avatar button and dropdown, integrate it into the header, and wire up the initialization effect for loading users and persisting selection to localStorage.

Purpose: Delivers the user-facing identity picker that satisfies USER-01, USER-02, USER-03 requirements. Users can select their identity, and the selection persists across sessions.

Output: Working avatar picker in header, localStorage persistence, full user identity flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-user-identity/08-CONTEXT.md
@.planning/phases/08-user-identity/08-RESEARCH.md
@.planning/phases/08-user-identity/08-01-SUMMARY.md

# Reference patterns
@WebChat.Client/Components/AgentSelector.razor
@WebChat.Client/State/Effects/InitializationEffect.cs
@WebChat.Client/State/StoreSubscriberComponent.cs
@WebChat.Client/Layout/MainLayout.razor
@WebChat.Client/Extensions/ServiceCollectionExtensions.cs
@WebChat.Client/wwwroot/css/app.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserIdentityEffect for loading and persisting user selection</name>
  <files>
    WebChat.Client/State/Effects/UserIdentityEffect.cs
    WebChat.Client/Extensions/ServiceCollectionExtensions.cs
    WebChat.Client/Program.cs
  </files>
  <action>
Create UserIdentityEffect following InitializationEffect pattern. This effect:
1. Loads users.json via HttpClient on Initialize action
2. Loads saved user selection from localStorage
3. Persists user selection to localStorage on SelectUser action

**UserIdentityEffect.cs:**
```csharp
using System.Net.Http.Json;
using WebChat.Client.Contracts;
using WebChat.Client.Models;
using WebChat.Client.State.Topics;
using WebChat.Client.State.UserIdentity;

namespace WebChat.Client.State.Effects;

public sealed class UserIdentityEffect : IDisposable
{
    private readonly Dispatcher _dispatcher;
    private readonly HttpClient _http;
    private readonly ILocalStorageService _localStorage;
    private const string StorageKey = "selectedUserId";

    public UserIdentityEffect(
        Dispatcher dispatcher,
        HttpClient http,
        ILocalStorageService localStorage)
    {
        _dispatcher = dispatcher;
        _http = http;
        _localStorage = localStorage;

        dispatcher.RegisterHandler<Initialize>(HandleInitialize);
        dispatcher.RegisterHandler<SelectUser>(HandleSelectUser);
    }

    private void HandleInitialize(Initialize action)
    {
        _ = LoadUsersAsync();
    }

    private async Task LoadUsersAsync()
    {
        _dispatcher.Dispatch(new LoadUsers());

        try
        {
            var users = await _http.GetFromJsonAsync<List<UserConfig>>("users.json");
            _dispatcher.Dispatch(new UsersLoaded(users ?? []));

            // Restore saved selection
            var savedUserId = await _localStorage.GetAsync(StorageKey);
            if (!string.IsNullOrEmpty(savedUserId) && users?.Any(u => u.Id == savedUserId) == true)
            {
                _dispatcher.Dispatch(new SelectUser(savedUserId));
            }
        }
        catch (HttpRequestException)
        {
            _dispatcher.Dispatch(new UsersLoaded([]));
        }
        catch (JsonException)
        {
            _dispatcher.Dispatch(new UsersLoaded([]));
        }
    }

    private void HandleSelectUser(SelectUser action)
    {
        _ = _localStorage.SetAsync(StorageKey, action.UserId);
    }

    public void Dispose()
    {
        // No subscriptions to dispose
    }
}
```

**Update ServiceCollectionExtensions.cs** - add UserIdentityStore to AddWebChatStores():
```csharp
using WebChat.Client.State.UserIdentity;
// ... existing usings

// In AddWebChatStores(), add:
services.AddScoped<UserIdentityStore>();
```

**Update Program.cs** - activate UserIdentityEffect at startup:
```csharp
// After other effect activations, add:
_ = app.Services.GetRequiredService<UserIdentityEffect>();
```

Also add to AddWebChatEffects():
```csharp
services.AddScoped<UserIdentityEffect>();
```
  </action>
  <verify>
    - Build succeeds: `dotnet build WebChat.Client/WebChat.Client.csproj`
    - UserIdentityEffect registered in DI
    - UserIdentityStore registered in DI
    - Effect activated in Program.cs
  </verify>
  <done>UserIdentityEffect loads users.json on Initialize, restores selection from localStorage, and persists new selections. Store and Effect registered in DI and activated at startup.</done>
</task>

<task type="auto">
  <name>Task 2: Create UserIdentityPicker component and integrate into header</name>
  <files>
    WebChat.Client/Components/UserIdentityPicker.razor
    WebChat.Client/Layout/MainLayout.razor
    WebChat.Client/wwwroot/css/app.css
  </files>
  <action>
Create UserIdentityPicker.razor following AgentSelector dropdown pattern but with circular avatar styling:

**UserIdentityPicker.razor:**
```razor
@inherits StoreSubscriberComponent
@inject UserIdentityStore Store
@inject IDispatcher Dispatcher

<div class="user-identity-picker @(_dropdownOpen ? "open" : "")">
    <button class="avatar-button" @onclick="ToggleDropdown" @onclick:stopPropagation="true" title="@(_selectedUser?.Username ?? "Select user")">
        @if (_selectedUser is not null)
        {
            <img src="@_selectedUser.AvatarUrl" alt="@_selectedUser.Username" class="avatar-image" />
        }
        else
        {
            <div class="avatar-placeholder">?</div>
        }
    </button>

    @if (_dropdownOpen)
    {
        <div class="dropdown-backdrop" @onclick="CloseDropdown"></div>
        <div class="user-dropdown-menu">
            @foreach (var user in _availableUsers)
            {
                <div class="user-dropdown-item @(user.Id == _selectedUser?.Id ? "selected" : "")"
                     @onclick="() => SelectUser(user)">
                    <img src="@user.AvatarUrl" alt="@user.Username" class="user-avatar-small" />
                    <span>@user.Username</span>
                </div>
            }
        </div>
    }
</div>

@code {
    private bool _dropdownOpen;
    private UserConfig? _selectedUser;
    private IReadOnlyList<UserConfig> _availableUsers = [];

    protected override void OnInitialized()
    {
        Subscribe(
            Store.StateObservable,
            state => (state.SelectedUserId, state.AvailableUsers),
            tuple =>
            {
                var (selectedId, users) = tuple;
                _availableUsers = users;
                _selectedUser = users.FirstOrDefault(u => u.Id == selectedId);
            });
    }

    private void ToggleDropdown()
    {
        _dropdownOpen = !_dropdownOpen;
    }

    private void CloseDropdown()
    {
        _dropdownOpen = false;
    }

    private void SelectUser(UserConfig user)
    {
        _dropdownOpen = false;
        if (user.Id != _selectedUser?.Id)
        {
            Dispatcher.Dispatch(new SelectUser(user.Id));
        }
    }
}
```

Add required using statements at top:
```razor
@using WebChat.Client.Models
@using WebChat.Client.State
@using WebChat.Client.State.UserIdentity
```

**Update MainLayout.razor** - add UserIdentityPicker to header-right div:
```razor
@using WebChat.Client.Components

<!-- In header-right div, add before theme-toggle button: -->
<UserIdentityPicker />
```

**Add CSS to app.css** - append to end of file:
```css
/* ===================================
   User Identity Picker
   =================================== */

.user-identity-picker {
    position: relative;
}

.avatar-button {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    overflow: hidden;
    border: 2px solid var(--border-color);
    background: var(--bg-tertiary);
    cursor: pointer;
    padding: 0;
    transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    display: flex;
    align-items: center;
    justify-content: center;
}

.avatar-button:hover {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-light);
}

.avatar-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
}

.avatar-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--bg-tertiary);
    color: var(--text-muted);
    font-size: 18px;
    font-weight: 600;
}

.user-dropdown-menu {
    position: absolute;
    top: calc(100% + 8px);
    right: 0;
    min-width: 180px;
    background-color: var(--bg-elevated);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    z-index: 100;
    overflow: hidden;
    animation: dropdownSlide 0.15s ease-out;
}

.user-dropdown-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    cursor: pointer;
    transition: background-color var(--transition-fast);
    color: var(--text-primary);
    font-size: 0.875rem;
}

.user-dropdown-item:hover {
    background-color: var(--bg-tertiary);
}

.user-dropdown-item.selected {
    background-color: var(--accent-subtle);
    color: var(--accent);
}

.user-avatar-small {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
}
```
  </action>
  <verify>
    - Build succeeds: `dotnet build WebChat.Client/WebChat.Client.csproj`
    - Run app: `dotnet run --project WebChat/WebChat.csproj` or use existing dev server
    - Visual verification:
      1. Avatar button appears in header (right side, before theme toggle)
      2. Shows "?" when no user selected
      3. Clicking opens dropdown with 3 users
      4. Selecting user shows their avatar
      5. Refresh page - selection persists
      6. Selected user highlighted in dropdown
  </verify>
  <done>UserIdentityPicker component displays circular avatar button in header. Dropdown shows available users with avatar + username. Selection updates state and persists to localStorage. Backdrop click closes dropdown.</done>
</task>

</tasks>

<verification>
1. `dotnet build WebChat.Client/WebChat.Client.csproj` succeeds
2. App runs without errors
3. Manual testing:
   - Fresh load shows "?" avatar (no selection)
   - Click avatar -> dropdown opens with 3 users
   - Click user -> dropdown closes, avatar shows selected user
   - Refresh page -> same user still selected
   - Click avatar again -> can switch users
   - Selected user has different background color in dropdown
</verification>

<success_criteria>
- USER-01: User can set username via compact picker UI (circular avatar button + dropdown)
- USER-02: Username persists in localStorage across sessions (refresh preserves selection)
- USER-03: Avatar determined by hardcoded username->avatar lookup (users.json config)
- No console errors
- Follows existing codebase patterns (StoreSubscriberComponent, backdrop dropdown, CSS variables)
</success_criteria>

<output>
After completion, create `.planning/phases/08-user-identity/08-02-SUMMARY.md`
</output>
