---
phase: 08-user-identity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - WebChat.Client/Models/UserConfig.cs
  - WebChat.Client/State/UserIdentity/UserIdentityState.cs
  - WebChat.Client/State/UserIdentity/UserIdentityActions.cs
  - WebChat.Client/State/UserIdentity/UserIdentityReducers.cs
  - WebChat.Client/State/UserIdentity/UserIdentityStore.cs
  - WebChat.Client/wwwroot/users.json
  - WebChat.Client/wwwroot/avatars/alice.png
  - WebChat.Client/wwwroot/avatars/bob.png
  - WebChat.Client/wwwroot/avatars/charlie.png
autonomous: true

must_haves:
  truths:
    - "UserIdentityStore exists and follows established Store<T> pattern"
    - "users.json config file defines available users with avatars"
    - "State can be loaded from and saved to localStorage"
  artifacts:
    - path: "WebChat.Client/Models/UserConfig.cs"
      provides: "User configuration record type"
      contains: "record UserConfig"
    - path: "WebChat.Client/State/UserIdentity/UserIdentityStore.cs"
      provides: "Redux-like store for user identity"
      contains: "class UserIdentityStore"
    - path: "WebChat.Client/wwwroot/users.json"
      provides: "User definitions with avatars"
      contains: "avatarUrl"
  key_links:
    - from: "UserIdentityStore"
      to: "Dispatcher"
      via: "RegisterHandler pattern"
      pattern: "dispatcher\\.RegisterHandler"
    - from: "UserIdentityStore"
      to: "ILocalStorageService"
      via: "constructor injection"
      pattern: "ILocalStorageService"
---

<objective>
Create the state management infrastructure for user identity, including the Store pattern implementation, user configuration model, and static configuration file with avatar images.

Purpose: Establishes the foundation that the UI picker component will consume. Follows existing TopicsStore/MessagesStore patterns for consistency.

Output: UserIdentityStore with state/actions/reducers, UserConfig model, users.json config file, and 3 placeholder avatar images.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-user-identity/08-CONTEXT.md
@.planning/phases/08-user-identity/08-RESEARCH.md

# Reference patterns
@WebChat.Client/State/Topics/TopicsStore.cs
@WebChat.Client/State/Topics/TopicsState.cs
@WebChat.Client/State/Topics/TopicsActions.cs
@WebChat.Client/State/Topics/TopicsReducers.cs
@WebChat.Client/Models/ChatMessageModel.cs
@WebChat.Client/Contracts/ILocalStorageService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserConfig model and users.json configuration</name>
  <files>
    WebChat.Client/Models/UserConfig.cs
    WebChat.Client/wwwroot/users.json
    WebChat.Client/wwwroot/avatars/alice.png
    WebChat.Client/wwwroot/avatars/bob.png
    WebChat.Client/wwwroot/avatars/charlie.png
  </files>
  <action>
Create UserConfig record type in Models folder:
```csharp
namespace WebChat.Client.Models;

public record UserConfig(string Id, string Username, string AvatarUrl);
```

Create users.json in wwwroot with 3 initial users:
```json
[
  { "id": "alice", "username": "Alice", "avatarUrl": "avatars/alice.png" },
  { "id": "bob", "username": "Bob", "avatarUrl": "avatars/bob.png" },
  { "id": "charlie", "username": "Charlie", "avatarUrl": "avatars/charlie.png" }
]
```

Create wwwroot/avatars/ directory and add 3 placeholder avatar images (80x80 PNG). Can use simple colored circles or download free avatar icons. The images just need to exist and be valid PNGs - styling/quality can be improved later.
  </action>
  <verify>
    - File exists: WebChat.Client/Models/UserConfig.cs
    - File exists: WebChat.Client/wwwroot/users.json
    - JSON is valid: parse users.json with dotnet test or manual check
    - Avatar files exist in wwwroot/avatars/
  </verify>
  <done>UserConfig record type exists. users.json defines 3 users with id, username, and avatarUrl. Avatar images exist in wwwroot/avatars/.</done>
</task>

<task type="auto">
  <name>Task 2: Create UserIdentity state management (State/Actions/Reducers/Store)</name>
  <files>
    WebChat.Client/State/UserIdentity/UserIdentityState.cs
    WebChat.Client/State/UserIdentity/UserIdentityActions.cs
    WebChat.Client/State/UserIdentity/UserIdentityReducers.cs
    WebChat.Client/State/UserIdentity/UserIdentityStore.cs
  </files>
  <action>
Create State/UserIdentity/ directory and implement the Redux-like pattern following TopicsStore as reference:

**UserIdentityState.cs:**
```csharp
namespace WebChat.Client.State.UserIdentity;

public sealed record UserIdentityState
{
    public string? SelectedUserId { get; init; }
    public IReadOnlyList<UserConfig> AvailableUsers { get; init; } = [];
    public bool IsLoading { get; init; }

    public static UserIdentityState Initial => new();
}
```

**UserIdentityActions.cs:**
```csharp
namespace WebChat.Client.State.UserIdentity;

public record LoadUsers : IAction;
public record UsersLoaded(IReadOnlyList<UserConfig> Users) : IAction;
public record SelectUser(string UserId) : IAction;
public record ClearUser : IAction;
```

**UserIdentityReducers.cs:**
```csharp
namespace WebChat.Client.State.UserIdentity;

public static class UserIdentityReducers
{
    public static UserIdentityState Reduce(UserIdentityState state, IAction action) => action switch
    {
        LoadUsers => state with { IsLoading = true },
        UsersLoaded a => state with { AvailableUsers = a.Users, IsLoading = false },
        SelectUser a => state with { SelectedUserId = a.UserId },
        ClearUser => state with { SelectedUserId = null },
        _ => state
    };
}
```

**UserIdentityStore.cs:**
Follow TopicsStore pattern - register handlers with Dispatcher, expose State and StateObservable:
```csharp
namespace WebChat.Client.State.UserIdentity;

public sealed class UserIdentityStore : IDisposable
{
    private readonly Store<UserIdentityState> _store;

    public UserIdentityStore(Dispatcher dispatcher)
    {
        _store = new Store<UserIdentityState>(UserIdentityState.Initial);

        dispatcher.RegisterHandler<LoadUsers>(action =>
            _store.Dispatch(action, UserIdentityReducers.Reduce));

        dispatcher.RegisterHandler<UsersLoaded>(action =>
            _store.Dispatch(action, UserIdentityReducers.Reduce));

        dispatcher.RegisterHandler<SelectUser>(action =>
            _store.Dispatch(action, UserIdentityReducers.Reduce));

        dispatcher.RegisterHandler<ClearUser>(action =>
            _store.Dispatch(action, UserIdentityReducers.Reduce));
    }

    public UserIdentityState State => _store.State;
    public IObservable<UserIdentityState> StateObservable => _store.StateObservable;
    public void Dispose() => _store.Dispose();
}
```

Add necessary using statements:
- `using WebChat.Client.Models;` in State files
- `using WebChat.Client.State;` for IAction, Store<T>, Dispatcher
  </action>
  <verify>
    - Build succeeds: `dotnet build WebChat.Client/WebChat.Client.csproj`
    - All 4 files exist in State/UserIdentity/
    - UserIdentityStore follows same pattern as TopicsStore (Dispatcher injection, RegisterHandler calls)
  </verify>
  <done>UserIdentityStore implements Store<UserIdentityState> with LoadUsers, UsersLoaded, SelectUser, ClearUser actions and corresponding reducers. Store registers handlers with Dispatcher following TopicsStore pattern.</done>
</task>

</tasks>

<verification>
1. `dotnet build WebChat.Client/WebChat.Client.csproj` succeeds
2. users.json is valid JSON with 3 user entries
3. Avatar images exist and are valid image files
4. State files follow established naming and pattern conventions
</verification>

<success_criteria>
- UserConfig model exists with Id, Username, AvatarUrl properties
- users.json config file contains 3 users with avatar URLs
- Avatar images exist in wwwroot/avatars/
- UserIdentityStore compiles and follows TopicsStore pattern
- No breaking changes to existing code
</success_criteria>

<output>
After completion, create `.planning/phases/08-user-identity/08-01-SUMMARY.md`
</output>
