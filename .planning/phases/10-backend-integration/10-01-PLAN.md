---
phase: 10-backend-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Agent/Hubs/ChatHub.cs
  - Agent/Services/UserConfigService.cs
  - Agent/wwwroot/users.json
autonomous: true

must_haves:
  truths:
    - "RegisterUser validates userId against users.json"
    - "SendMessage rejects calls from unregistered connections"
    - "Context.Items stores userId and username per connection"
  artifacts:
    - path: "Agent/Hubs/ChatHub.cs"
      provides: "RegisterUser method, registration guard on SendMessage"
      contains: "Context.Items"
    - path: "Agent/Services/UserConfigService.cs"
      provides: "Server-side user lookup from users.json"
      exports: ["UserConfigService", "UserConfig"]
    - path: "Agent/wwwroot/users.json"
      provides: "Server-side copy of user definitions"
  key_links:
    - from: "Agent/Hubs/ChatHub.cs"
      to: "Agent/Services/UserConfigService.cs"
      via: "DI injection"
      pattern: "UserConfigService"
    - from: "ChatHub.RegisterUser"
      to: "Context.Items"
      via: "per-connection storage"
      pattern: "Context\\.Items\\["
---

<objective>
Server-side user registration and connection identity tracking.

Purpose: Enable backend to know who is sending messages by requiring user registration after connection. This is the foundation for personalized agent responses (BACK-01).

Output: ChatHub with RegisterUser method, registration guard on SendMessage, and UserConfigService for server-side user lookup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-backend-integration/10-CONTEXT.md
@.planning/phases/10-backend-integration/10-RESEARCH.md

# Key source files
@Agent/Hubs/ChatHub.cs
@WebChat.Client/wwwroot/users.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserConfigService for server-side user lookup</name>
  <files>
    Agent/Services/UserConfigService.cs
    Agent/wwwroot/users.json
    Agent/Modules/CoreModule.cs
  </files>
  <action>
Create a service to load and cache users.json on the server side:

1. Copy `WebChat.Client/wwwroot/users.json` to `Agent/wwwroot/users.json` (identical content)

2. Create `Agent/Services/UserConfigService.cs`:
   - Define `UserConfig` record: `record UserConfig(string Id, string Username, string AvatarUrl)`
   - Class `UserConfigService` with primary constructor taking `IWebHostEnvironment`
   - Private `Lazy<IReadOnlyList<UserConfig>>` field for cached users
   - Load from `env.WebRootFileProvider.GetFileInfo("users.json")` in lazy initializer
   - Method `GetUserById(string userId)` returns `UserConfig?`
   - Method `GetAllUsers()` returns `IReadOnlyList<UserConfig>`

3. Register in DI (Agent/Modules/CoreModule.cs):
   - Add `services.AddSingleton<UserConfigService>();`

Note: Use `System.Text.Json` for deserialization. The lazy loading ensures the file is read once on first access.
  </action>
  <verify>
Build succeeds: `dotnet build Agent/Agent.csproj`
Verify users.json exists in wwwroot: `ls Agent/wwwroot/users.json`
  </verify>
  <done>
UserConfigService loads users.json and provides GetUserById lookup. Service is registered in DI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add RegisterUser hub method with Context.Items storage</name>
  <files>Agent/Hubs/ChatHub.cs</files>
  <action>
Add user registration to ChatHub:

1. Inject `UserConfigService` via primary constructor

2. Add `RegisterUser` method:
   ```csharp
   public Task RegisterUser(string userId)
   {
       var user = userConfigService.GetUserById(userId);
       if (user is null)
       {
           throw new HubException($"Invalid user ID: {userId}");
       }

       Context.Items["UserId"] = userId;
       Context.Items["Username"] = user.Username;
       return Task.CompletedTask;
   }
   ```

3. Add private helper to get registered username:
   ```csharp
   private string? GetRegisteredUsername()
   {
       return Context.Items.TryGetValue("Username", out var username)
           ? username as string
           : null;
   }
   ```

4. Add private helper to check registration:
   ```csharp
   private bool IsRegistered => Context.Items.ContainsKey("UserId");
   ```

Use `Microsoft.AspNetCore.SignalR.HubException` for the exception (already available from SignalR namespace).
  </action>
  <verify>
Build succeeds: `dotnet build Agent/Agent.csproj`
  </verify>
  <done>
RegisterUser method stores userId and username in Context.Items. GetRegisteredUsername helper available for use.
  </done>
</task>

<task type="auto">
  <name>Task 3: Guard SendMessage with registration check</name>
  <files>Agent/Hubs/ChatHub.cs</files>
  <action>
Add registration validation to SendMessage:

1. At the start of `SendMessage`, add registration guard:
   ```csharp
   if (!IsRegistered)
   {
       yield return new ChatStreamMessage
       {
           Error = "User not registered. Please call RegisterUser first.",
           IsComplete = true
       };
       yield break;
   }
   ```

2. The existing code passes `"web-user"` to `EnqueuePromptAndGetResponses`:
   ```csharp
   var responses = messengerClient.EnqueuePromptAndGetResponses(topicId, message, "web-user", cancellationToken);
   ```

   Keep this as `"web-user"` for now - Plan 02 will update this to pass the senderId from client.

This ensures only registered users can send messages. The username from Context.Items will be used for agent personalization in Plan 02.
  </action>
  <verify>
Build succeeds: `dotnet build Agent/Agent.csproj`
  </verify>
  <done>
SendMessage returns error for unregistered connections. Registration check uses IsRegistered helper.
  </done>
</task>

</tasks>

<verification>
1. Solution builds without errors: `dotnet build`
2. users.json exists at `Agent/wwwroot/users.json`
3. UserConfigService is registered in DI
4. ChatHub has RegisterUser method with Context.Items storage
5. SendMessage guards against unregistered connections
</verification>

<success_criteria>
- RegisterUser validates userId against server-side users.json and stores in Context.Items
- SendMessage rejects calls from unregistered connections with clear error message
- UserConfigService provides synchronous user lookup (lazy-loaded, cached)
- No breaking changes to existing functionality (just added registration requirement)
</success_criteria>

<output>
After completion, create `.planning/phases/10-backend-integration/10-01-SUMMARY.md`
</output>
