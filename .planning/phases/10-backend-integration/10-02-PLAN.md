---
phase: 10-backend-integration
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - Agent/Hubs/ChatHub.cs
  - WebChat.Client/Services/ChatMessagingService.cs
  - WebChat.Client/Contracts/IChatMessagingService.cs
  - WebChat.Client/Contracts/IChatConnectionService.cs
  - WebChat.Client/Services/ChatConnectionService.cs
  - WebChat.Client/Services/Streaming/StreamingService.cs
  - WebChat.Client/State/Effects/InitializationEffect.cs
  - Infrastructure/Agents/McpAgent.cs
autonomous: true

must_haves:
  truths:
    - "Client sends senderId with every message"
    - "Client re-registers on reconnection"
    - "Agent receives username in prompt context"
    - "Agent addresses user by name naturally"
  artifacts:
    - path: "Agent/Hubs/ChatHub.cs"
      provides: "SendMessage accepts senderId parameter, passes username to agent"
      contains: "GetRegisteredUsername"
    - path: "WebChat.Client/Services/ChatMessagingService.cs"
      provides: "SendMessageAsync passes senderId to hub"
      contains: "senderId"
    - path: "WebChat.Client/State/Effects/InitializationEffect.cs"
      provides: "RegisterUser call after connection and on reconnection"
      contains: "RegisterUser"
    - path: "Infrastructure/Agents/McpAgent.cs"
      provides: "Username in prompt context"
      contains: "You are chatting with"
  key_links:
    - from: "WebChat.Client/Services/ChatMessagingService.cs"
      to: "ChatHub.SendMessage"
      via: "SignalR StreamAsync"
      pattern: "SendMessage.*senderId"
    - from: "ChatHub.SendMessage"
      to: "EnqueuePromptAndGetResponses"
      via: "GetRegisteredUsername"
      pattern: "GetRegisteredUsername"
    - from: "ChatMonitor"
      to: "IAgentFactory.Create"
      via: "ChatPrompt.Sender passed as userId parameter"
      pattern: "Create.*userId"
---

<objective>
Wire senderId through message flow and pass username to agent for personalization.

Purpose: Complete the backend integration by sending user identity with messages (BACK-02) and enabling personalized agent responses (BACK-03). Client re-registers on reconnection for continuity.

Output: Full message flow includes senderId, agent receives username context, client handles reconnection gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-backend-integration/10-CONTEXT.md
@.planning/phases/10-backend-integration/10-RESEARCH.md
@.planning/phases/10-backend-integration/10-01-SUMMARY.md

# Key source files
@Agent/Hubs/ChatHub.cs
@WebChat.Client/Services/ChatMessagingService.cs
@WebChat.Client/Contracts/IChatConnectionService.cs
@WebChat.Client/Services/ChatConnectionService.cs
@WebChat.Client/Services/Streaming/StreamingService.cs
@WebChat.Client/State/Effects/InitializationEffect.cs
@Infrastructure/Agents/McpAgent.cs
@Infrastructure/Clients/Messaging/WebChatMessengerClient.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update client to send senderId and register on connection</name>
  <files>
    WebChat.Client/Contracts/IChatConnectionService.cs
    WebChat.Client/Services/ChatConnectionService.cs
    WebChat.Client/Contracts/IChatMessagingService.cs
    WebChat.Client/Services/ChatMessagingService.cs
    WebChat.Client/Services/Streaming/StreamingService.cs
    WebChat.Client/State/Effects/InitializationEffect.cs
  </files>
  <action>
Update client-side message flow to include senderId and register user:

1. **IChatConnectionService.cs** - Expose HubConnection for registration calls:
   ```csharp
   HubConnection? HubConnection { get; }
   ```

2. **ChatConnectionService.cs** - Implement the HubConnection property (already exists as private field, just expose it via interface):
   ```csharp
   public HubConnection? HubConnection => _hubConnection;
   ```

3. **IChatMessagingService.cs** - Add senderId parameter:
   ```csharp
   IAsyncEnumerable<ChatStreamMessage> SendMessageAsync(string topicId, string message, string? senderId);
   ```

4. **ChatMessagingService.cs** - Pass senderId to hub:
   ```csharp
   public async IAsyncEnumerable<ChatStreamMessage> SendMessageAsync(string topicId, string message, string? senderId)
   {
       // ... existing null checks ...
       var stream = hubConnection.StreamAsync<ChatStreamMessage>("SendMessage", topicId, message, senderId);
       // ... rest unchanged ...
   }
   ```

5. **StreamingService.cs** - Find where SendMessageAsync is called and pass senderId:
   - Inject `UserIdentityStore` if not already
   - Get `senderId` from `_userIdentityStore.State.SelectedUserId`
   - Pass it to `SendMessageAsync`

6. **InitializationEffect.cs** - Register user after connection:
   - After `_connectionService.ConnectAsync()` succeeds in HandleInitialize:
     ```csharp
     var userId = _userIdentityStore.State.SelectedUserId;
     if (!string.IsNullOrEmpty(userId) && _connectionService.HubConnection is not null)
     {
         await _connectionService.HubConnection.InvokeAsync("RegisterUser", userId);
     }
     ```
   - Subscribe to `_connectionService.OnReconnected`:
     ```csharp
     _connectionService.OnReconnected += async () =>
     {
         var userId = _userIdentityStore.State.SelectedUserId;
         if (!string.IsNullOrEmpty(userId) && _connectionService.HubConnection is not null)
         {
             await _connectionService.HubConnection.InvokeAsync("RegisterUser", userId);
         }
     };
     ```
  </action>
  <verify>
Build succeeds: `dotnet build WebChat.Client/WebChat.Client.csproj`
  </verify>
  <done>
Client sends senderId with every message. Client registers user after initial connection and on every reconnection. IChatConnectionService exposes HubConnection property.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ChatHub to accept senderId and pass username to agent</name>
  <files>
    Agent/Hubs/ChatHub.cs
  </files>
  <action>
Update server-side message handling:

1. **ChatHub.cs** - Update SendMessage signature:
   ```csharp
   public async IAsyncEnumerable<ChatStreamMessage> SendMessage(
       string topicId,
       string message,
       string? senderId,  // NEW parameter
       [EnumeratorCancellation] CancellationToken cancellationToken)
   ```

2. In SendMessage, use the registered username for agent (not senderId from client):
   ```csharp
   var username = GetRegisteredUsername() ?? "Anonymous";
   var responses = messengerClient.EnqueuePromptAndGetResponses(
       topicId, message, username, cancellationToken);
   ```

   Note: We use `GetRegisteredUsername()` (from Context.Items set in RegisterUser) rather than trusting the client-provided senderId. The senderId is for message attribution/broadcasting, but the username for the agent comes from the validated registration.

**Important context on parameter naming:** The existing `IAgentFactory.Create(AgentKey agentKey, string userId, string? botTokenHash)` method has a parameter named `userId` which receives the username string (e.g., "Alice"). This is inherited naming from before user identity was implemented - originally it received "web-user" or similar placeholders. The naming is technically misleading but changing it would require updates across Domain, Infrastructure, and multiple call sites. For this phase, we pass the username through this parameter as-is, documenting that `userId` receives the display username, not a user ID.

The flow is:
- Client sends (topicId, message, senderId)
- Hub validates registration, gets username from Context.Items
- Hub passes username to EnqueuePromptAndGetResponses as `sender`
- WebChatMessengerClient puts sender in ChatPrompt
- ChatMonitor passes ChatPrompt.Sender to agentFactory.Create as userId parameter (which receives username value)
  </action>
  <verify>
Build succeeds: `dotnet build Agent/Agent.csproj`
  </verify>
  <done>
ChatHub.SendMessage accepts senderId parameter. Registered username (not client-provided senderId) passed to agent via the existing userId parameter pathway.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add username context to agent prompts</name>
  <files>
    Infrastructure/Agents/McpAgent.cs
  </files>
  <action>
Update McpAgent to include username in the prompt context:

1. In `McpAgent.CreateRunOptions`, add username context before existing prompts:
   ```csharp
   private ChatClientAgentRunOptions CreateRunOptions(ThreadSession session)
   {
       var timeContext = $"Current time: {DateTime.UtcNow:yyyy-MM-dd HH:mm} UTC";
       var userContext = !string.IsNullOrEmpty(_userId)
           ? $"You are chatting with {_userId}."
           : null;

       var prompts = session.ClientManager.Prompts
           .Prepend(BasePrompt.Instructions);

       if (!string.IsNullOrEmpty(_customInstructions))
       {
           prompts = prompts.Prepend(_customInstructions);
       }

       if (!string.IsNullOrEmpty(userContext))
       {
           prompts = prompts.Prepend(userContext);
       }

       prompts = prompts.Prepend(timeContext);

       return new ChatClientAgentRunOptions(new ChatOptions
       {
           Tools = [.. session.ClientManager.Tools],
           Instructions = string.Join("\n\n", prompts)
       });
   }
   ```

Note: The `_userId` field in McpAgent already exists and receives the value from `firstPrompt.Sender` via ChatMonitor -> agentFactory.Create. We're now passing the username (e.g., "Alice") instead of "web-user", so the prompt will say "You are chatting with Alice."

The agent uses this naturally - no forced greeting patterns. The agent simply knows who it's talking to.
  </action>
  <verify>
Build succeeds: `dotnet build Infrastructure/Infrastructure.csproj`
Full solution builds: `dotnet build`
  </verify>
  <done>
Agent prompt includes "You are chatting with {username}." when a registered user is chatting. Agent can address user by name naturally.
  </done>
</task>

</tasks>

<verification>
1. Full solution builds: `dotnet build`
2. Client sends senderId with SendMessageAsync calls
3. Client registers user after initial connection
4. Client re-registers user on reconnection
5. ChatHub.SendMessage accepts senderId parameter
6. Agent prompt includes username context
7. No anonymous/unregistered users can send messages (from Plan 01)
</verification>

<success_criteria>
- Messages include senderId from client to server
- Client registers after connection and re-registers on reconnection
- Agent receives "You are chatting with {username}." in prompt context
- Agent naturally addresses user by name when contextually appropriate
- Unregistered connections still blocked (Plan 01 foundation)
</success_criteria>

<output>
After completion, create `.planning/phases/10-backend-integration/10-02-SUMMARY.md`
</output>
