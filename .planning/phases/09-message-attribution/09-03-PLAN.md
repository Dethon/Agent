---
phase: 09-message-attribution
plan: 03
type: execute
wave: 3
depends_on: ["09-01", "09-02"]
files_modified:
  - WebChat.Client/State/Effects/SendMessageEffect.cs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User messages include sender identity data when created"
    - "SenderId matches UserIdentityStore.State.SelectedUserId"
    - "SenderUsername and SenderAvatarUrl come from matching UserConfig"
  artifacts:
    - path: "WebChat.Client/State/Effects/SendMessageEffect.cs"
      provides: "Sender data population in message creation"
      contains: "UserIdentityStore"
  key_links:
    - from: "SendMessageEffect.cs"
      to: "UserIdentityStore"
      via: "constructor injection"
      pattern: "UserIdentityStore"
    - from: "SendMessageEffect.HandleSendMessageAsync"
      to: "ChatMessageModel"
      via: "sender field population"
      pattern: "SenderId.*SenderUsername.*SenderAvatarUrl"
---

<objective>
Fix the data population gap that prevents sender identity from flowing into user messages.

Purpose: The UI components (ChatMessage, AvatarImage, MessageList) are fully implemented but receive null sender data because SendMessageEffect never populates SenderId, SenderUsername, or SenderAvatarUrl when creating ChatMessageModel.

Output: SendMessageEffect that injects UserIdentityStore, looks up current user, and populates sender fields on user messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase context
@.planning/phases/09-message-attribution/09-VERIFICATION.md

# Files to modify
@WebChat.Client/State/Effects/SendMessageEffect.cs

# Related types
@WebChat.Client/State/UserIdentity/UserIdentityStore.cs
@WebChat.Client/State/UserIdentity/UserIdentityState.cs
@WebChat.Client/Models/UserConfig.cs
@WebChat.Client/Models/ChatMessageModel.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire UserIdentityStore into SendMessageEffect</name>
  <files>WebChat.Client/State/Effects/SendMessageEffect.cs</files>
  <action>
Modify SendMessageEffect to inject UserIdentityStore and populate sender fields:

1. Add using statement for UserIdentity namespace:
   `using WebChat.Client.State.UserIdentity;`

2. Add UserIdentityStore field:
   `private readonly UserIdentityStore _userIdentityStore;`

3. Add UserIdentityStore parameter to constructor (after messagingService):
   `UserIdentityStore userIdentityStore`

   And assign it:
   `_userIdentityStore = userIdentityStore;`

4. In HandleSendMessageAsync, before creating ChatMessageModel (around line 94-99), lookup current user:
   ```csharp
   var identityState = _userIdentityStore.State;
   var currentUser = identityState.AvailableUsers
       .FirstOrDefault(u => u.Id == identityState.SelectedUserId);
   ```

5. Update ChatMessageModel creation to include sender fields:
   ```csharp
   _dispatcher.Dispatch(new AddMessage(topic.TopicId, new ChatMessageModel
   {
       Role = "user",
       Content = action.Message,
       SenderId = currentUser?.Id,
       SenderUsername = currentUser?.Username,
       SenderAvatarUrl = currentUser?.AvatarUrl
   }));
   ```

Note: If no user is selected (currentUser is null), the sender fields remain null. This is acceptable - the UI will show fallback avatars just as it does now. The important case is when a user IS selected, their identity flows through.
  </action>
  <verify>
1. Build succeeds: `dotnet build WebChat.Client`
2. Grep confirms UserIdentityStore injection: `grep -n "UserIdentityStore" WebChat.Client/State/Effects/SendMessageEffect.cs`
3. Grep confirms sender field population: `grep -n "SenderId\|SenderUsername\|SenderAvatarUrl" WebChat.Client/State/Effects/SendMessageEffect.cs`
  </verify>
  <done>
SendMessageEffect injects UserIdentityStore and populates SenderId, SenderUsername, SenderAvatarUrl when creating user messages. Build passes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Sender identity data now flows into user messages</what-built>
  <how-to-verify>
1. Start the WebChat application: `dotnet run --project WebChat`
2. Open browser to https://localhost:7001
3. Select a user from the avatar picker in the header (e.g., Alice)
4. Type and send a message

**Expected results:**
- Message bubble shows Alice's avatar (image, not fallback initials)
- Hover over message bubble shows "Alice" tooltip
- Message bubble has green gradient (own message styling)
- Send 2-3 more messages - only first shows avatar, rest show placeholder space

5. Optional: Open another browser/incognito, select Bob, send a message to the same topic
- Bob's message should show Bob's avatar with purple gradient
- Alice's view should show Bob's message with Bob's avatar

6. Receive an agent response
- Agent message should have no avatar column (full width)
  </how-to-verify>
  <resume-signal>Type "approved" if avatar/username/styling work correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Build passes: `dotnet build WebChat.Client`
2. SendMessageEffect contains UserIdentityStore injection
3. ChatMessageModel creation includes SenderId, SenderUsername, SenderAvatarUrl
4. Human verification confirms visual behavior matches expectations
</verification>

<success_criteria>
1. User messages display sender avatar image (not just fallback)
2. Hovering over message bubble shows sender username tooltip
3. Own messages have green gradient styling
4. Message grouping works correctly (avatar on first of consecutive messages)
5. Agent messages unchanged (full-width, no avatar)
</success_criteria>

<output>
After completion, create `.planning/phases/09-message-attribution/09-03-SUMMARY.md`
</output>
